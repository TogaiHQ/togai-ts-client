/* tslint:disable */
/* eslint-disable */
/**
 * Togai Apis
 * APIs for Togai App
 *
 * The version of the OpenAPI document: 1.0
 * Contact: engg@togai.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Structure of an account
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * Identifier of the account
     * @type {string}
     * @memberof Account
     */
    'id': string;
    /**
     * Name of the customer
     * @type {string}
     * @memberof Account
     */
    'name': string;
    /**
     * [ISO_4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency in which the account must be invoiced Defaults to Base currency. 
     * @type {string}
     * @memberof Account
     */
    'invoiceCurrency': string;
    /**
     * list of aliases of the account
     * @type {Array<AccountAliases>}
     * @memberof Account
     */
    'aliases'?: Array<AccountAliases>;
    /**
     * Status of the account
     * @type {string}
     * @memberof Account
     */
    'status': AccountStatusEnum;
}

export const AccountStatusEnum = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type AccountStatusEnum = typeof AccountStatusEnum[keyof typeof AccountStatusEnum];

/**
 * 
 * @export
 * @interface AccountAliases
 */
export interface AccountAliases {
    /**
     * 
     * @type {string}
     * @memberof AccountAliases
     */
    'alias'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountAliases
     */
    'status'?: AccountAliasesStatusEnum;
}

export const AccountAliasesStatusEnum = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type AccountAliasesStatusEnum = typeof AccountAliasesStatusEnum[keyof typeof AccountAliasesStatusEnum];

/**
 * 
 * @export
 * @interface AccountPaginatedResponse
 */
export interface AccountPaginatedResponse {
    /**
     * 
     * @type {Array<Account>}
     * @memberof AccountPaginatedResponse
     */
    'data'?: Array<Account>;
    /**
     * 
     * @type {string}
     * @memberof AccountPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof AccountPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * Request to activate currencies of a price plan
 * @export
 * @interface ActivatePricePlanRequest
 */
export interface ActivatePricePlanRequest {
    /**
     * List of currencies to activate
     * @type {Array<string>}
     * @memberof ActivatePricePlanRequest
     */
    'currencies': Array<string>;
}
/**
 * Payload to add aliases from account
 * @export
 * @interface AddAccountAliasesRequest
 */
export interface AddAccountAliasesRequest {
    /**
     * List of aliases to add
     * @type {Array<string>}
     * @memberof AddAccountAliasesRequest
     */
    'aliases'?: Array<string>;
}
/**
 * Request to adding currency to a price plan
 * @export
 * @interface AddCurrencyToPricePlanRequest
 */
export interface AddCurrencyToPricePlanRequest {
    /**
     * Currency to be added
     * @type {string}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'currency': string;
    /**
     * List of usage rates
     * @type {Array<UsageRate>}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'usageRates': Array<UsageRate>;
}
/**
 * Request to associate a price plan to an account
 * @export
 * @interface AssociatePricePlanRequest
 */
export interface AssociatePricePlanRequest {
    /**
     * Id of the price plan
     * @type {string}
     * @memberof AssociatePricePlanRequest
     */
    'pricePlanId': string;
    /**
     * Date of effectiveness of the association. - Expected only if the account already has a price plan associated with it. 
     * @type {string}
     * @memberof AssociatePricePlanRequest
     */
    'effectiveFrom': string;
    /**
     * Date until which the association must be effective. - Expected only if effectiveFrom is present. 
     * @type {string}
     * @memberof AssociatePricePlanRequest
     */
    'effectiveUntil': string;
    /**
     * 
     * @type {PricePlanDetailsOverride}
     * @memberof AssociatePricePlanRequest
     */
    'pricePlanDetailsOverride'?: PricePlanDetailsOverride;
}
/**
 * 
 * @export
 * @interface AssociatePricePlanResponse
 */
export interface AssociatePricePlanResponse {
    /**
     * Identifier of the account
     * @type {string}
     * @memberof AssociatePricePlanResponse
     */
    'accountId': string;
    /**
     * Name of the customer
     * @type {string}
     * @memberof AssociatePricePlanResponse
     */
    'accountName': string;
    /**
     * 
     * @type {Array<PlanOverride>}
     * @memberof AssociatePricePlanResponse
     */
    'pricingSchedules': Array<PlanOverride>;
}
/**
 * Metric to be recorded
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * Name of the event attribute
     * @type {string}
     * @memberof Attribute
     */
    'name': string;
    /**
     * Value of the event attribute
     * @type {string}
     * @memberof Attribute
     */
    'value': string;
    /**
     * Unit with which the attribute value was measured. Natively supported units - \"Meters, Miles, Kilometers, Grams, Kilograms, ounces, Pounds, Minutes, Hours, Seconds, Milliseconds, Microseconds, None\". Clients are free to add any other custom units.
     * @type {string}
     * @memberof Attribute
     */
    'unit'?: string;
}
/**
 * 
 * @export
 * @interface BaseSuccessResponse
 */
export interface BaseSuccessResponse {
    /**
     * 
     * @type {boolean}
     * @memberof BaseSuccessResponse
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface Computation
 */
export interface Computation {
    /**
     * Optional identifier describing the matcher and computation pair
     * @type {string}
     * @memberof Computation
     */
    'id'?: string;
    /**
     * Condition to be applied on event. Upon matching it the corresponding computation will be considered for usage_meter unit calculation. The result of the matcher needs to be truthy (https://jsonlogic.com/truthy.html) in order to be considered as a match. 
     * @type {string}
     * @memberof Computation
     */
    'matcher'?: string;
    /**
     * Computation to be applied on an event if it matches the matcher In case of a COUNT aggregation type, computation should be passed as \'1\' 
     * @type {string}
     * @memberof Computation
     */
    'computation': string;
}
/**
 * Payload to create account
 * @export
 * @interface CreateAccountRequest
 */
export interface CreateAccountRequest {
    /**
     * Identifier of the account
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'id': string;
    /**
     * Name of the customer
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'name': string;
    /**
     * [ISO_4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency in which the account must be invoiced Defaults to Base currency. 
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'invoiceCurrency'?: string;
    /**
     * Aliases are tags that are associated with an account. Multiple aliases are allowed for a single account.
     * @type {Array<string>}
     * @memberof CreateAccountRequest
     */
    'aliases'?: Array<string>;
}
/**
 * Payload to create customer
 * @export
 * @interface CreateCustomerRequest
 */
export interface CreateCustomerRequest {
    /**
     * Customer identifier
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'id': string;
    /**
     * Name of the customer
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'name': string;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'primaryEmail': string;
    /**
     * billing address of the customer
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'billingAddress': string;
    /**
     * 
     * @type {CreateAccountRequest}
     * @memberof CreateCustomerRequest
     */
    'account'?: CreateAccountRequest;
}
/**
 * 
 * @export
 * @interface CreateCustomerResponse
 */
export interface CreateCustomerResponse {
    /**
     * Identifier of customer
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'id': string;
    /**
     * Name of the customer
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'name': string;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'primaryEmail': string;
    /**
     * billing address of the customer
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'billingAddress': string;
    /**
     * 
     * @type {Account}
     * @memberof CreateCustomerResponse
     */
    'account'?: Account;
}
/**
 * Request to create event schema
 * @export
 * @interface CreateEventSchemaRequest
 */
export interface CreateEventSchemaRequest {
    /**
     * Name of the event. Must be unique for an organization.
     * @type {string}
     * @memberof CreateEventSchemaRequest
     */
    'name': string;
    /**
     * Description of the event
     * @type {string}
     * @memberof CreateEventSchemaRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<EventAttributeSchema>}
     * @memberof CreateEventSchemaRequest
     */
    'attributes': Array<EventAttributeSchema>;
    /**
     * 
     * @type {Array<DimensionsSchema>}
     * @memberof CreateEventSchemaRequest
     */
    'dimensions': Array<DimensionsSchema>;
}
/**
 * 
 * @export
 * @interface CreatePricePlanDetails
 */
export interface CreatePricePlanDetails {
    /**
     * 
     * @type {PricingCycleConfig}
     * @memberof CreatePricePlanDetails
     */
    'pricingCycleConfig': PricingCycleConfig;
    /**
     * List of usage rate cards
     * @type {Array<UsageRateCard>}
     * @memberof CreatePricePlanDetails
     */
    'usageRateCards': Array<UsageRateCard>;
}
/**
 * Request to create a price plan
 * @export
 * @interface CreatePricePlanRequest
 */
export interface CreatePricePlanRequest {
    /**
     * Name of the price plan
     * @type {string}
     * @memberof CreatePricePlanRequest
     */
    'name': string;
    /**
     * Description of price plan
     * @type {string}
     * @memberof CreatePricePlanRequest
     */
    'description'?: string;
    /**
     * 
     * @type {CreatePricePlanDetails}
     * @memberof CreatePricePlanRequest
     */
    'pricePlanDetails': CreatePricePlanDetails;
}
/**
 * Request to create usage meter
 * @export
 * @interface CreateUsageMeterRequest
 */
export interface CreateUsageMeterRequest {
    /**
     * Name of the event. Must be unique for an organization.
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'name': string;
    /**
     * Description of the event
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'description'?: string;
    /**
     * Type of usage meter
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'type': CreateUsageMeterRequestTypeEnum;
    /**
     * Aggregation to be applied on usage meter result
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'aggregation': CreateUsageMeterRequestAggregationEnum;
    /**
     * 
     * @type {Array<Computation>}
     * @memberof CreateUsageMeterRequest
     */
    'computations'?: Array<Computation>;
}

export const CreateUsageMeterRequestTypeEnum = {
    Counter: 'COUNTER'
} as const;

export type CreateUsageMeterRequestTypeEnum = typeof CreateUsageMeterRequestTypeEnum[keyof typeof CreateUsageMeterRequestTypeEnum];
export const CreateUsageMeterRequestAggregationEnum = {
    Count: 'COUNT',
    Sum: 'SUM'
} as const;

export type CreateUsageMeterRequestAggregationEnum = typeof CreateUsageMeterRequestAggregationEnum[keyof typeof CreateUsageMeterRequestAggregationEnum];

/**
 * Structure of customer
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * Identifier of customer
     * @type {string}
     * @memberof Customer
     */
    'id': string;
    /**
     * Name of the customer
     * @type {string}
     * @memberof Customer
     */
    'name': string;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof Customer
     */
    'primaryEmail': string;
    /**
     * billing address of the customer
     * @type {string}
     * @memberof Customer
     */
    'billingAddress': string;
    /**
     * Status of the customer
     * @type {string}
     * @memberof Customer
     */
    'status': CustomerStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'updatedAt': string;
}

export const CustomerStatusEnum = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type CustomerStatusEnum = typeof CustomerStatusEnum[keyof typeof CustomerStatusEnum];

/**
 * 
 * @export
 * @interface CustomerPaginatedResponse
 */
export interface CustomerPaginatedResponse {
    /**
     * 
     * @type {Array<Customer>}
     * @memberof CustomerPaginatedResponse
     */
    'data'?: Array<Customer>;
    /**
     * 
     * @type {string}
     * @memberof CustomerPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof CustomerPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * Structure of dimensions
 * @export
 * @interface DimensionsSchema
 */
export interface DimensionsSchema {
    /**
     * Name of the event dimension
     * @type {string}
     * @memberof DimensionsSchema
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * error description
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
}
/**
 * Contents of the event
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * Name of the event to be recorded.
     * @type {string}
     * @memberof Event
     */
    'schemaName': string;
    /**
     * A unique value to identify the event instance. This unique value should be generated by the client and it acts as the **idempotency key**. Togai server will use this key to recognize subsequent retries of the same request and avoid metering multiple times for that same request. This id can be created in any format but we recommend using UUIDv4 to reduce collision occurance.    NOTE1: Expiry time for idempotency validation will be until the end of the billing cycle. Any request which comes after the billing cycle with the same id will be treated as new request and ingested for metering.   NOTE2: If the billing cycle is not configured for the idempotency validation will be until **10 days** of the event ingestion.
     * @type {string}
     * @memberof Event
     */
    'id': string;
    /**
     * Source time stamp of the event. This timestamp must be in ISO 8601 format.
     * @type {string}
     * @memberof Event
     */
    'timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'accountId': string;
    /**
     * 
     * @type {Array<Attribute>}
     * @memberof Event
     */
    'attributes': Array<Attribute>;
    /**
     * Dimensions are tags/labels associated with the events. This dimensions can be used to configure billing, for queries, analytics and reports.
     * @type {{ [key: string]: string; }}
     * @memberof Event
     */
    'dimensions': { [key: string]: string; };
}
/**
 * Structure of an event attribute
 * @export
 * @interface EventAttributeSchema
 */
export interface EventAttributeSchema {
    /**
     * Name of the event attribute.
     * @type {string}
     * @memberof EventAttributeSchema
     */
    'name': string;
    /**
     * Unit for the attribute
     * @type {string}
     * @memberof EventAttributeSchema
     */
    'default_unit'?: string;
}
/**
 * Information related to ingestion of an event
 * @export
 * @interface EventPipelineInfo
 */
export interface EventPipelineInfo {
    /**
     * 
     * @type {EventPipelineInfoEventSchema}
     * @memberof EventPipelineInfo
     */
    'eventSchema'?: EventPipelineInfoEventSchema;
    /**
     * 
     * @type {Array<EventPipelineInfoUsageMetersInner>}
     * @memberof EventPipelineInfo
     */
    'usageMeters'?: Array<EventPipelineInfoUsageMetersInner>;
    /**
     * 
     * @type {Array<EventPipelineInfoPricePlansInner>}
     * @memberof EventPipelineInfo
     */
    'pricePlans'?: Array<EventPipelineInfoPricePlansInner>;
    /**
     * 
     * @type {EventPipelineInfoAccount}
     * @memberof EventPipelineInfo
     */
    'account'?: EventPipelineInfoAccount;
    /**
     * 
     * @type {EventPipelineInfoCustomer}
     * @memberof EventPipelineInfo
     */
    'customer'?: EventPipelineInfoCustomer;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoAccount
 */
export interface EventPipelineInfoAccount {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoAccount
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoAccount
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoCustomer
 */
export interface EventPipelineInfoCustomer {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoCustomer
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoCustomer
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoEventSchema
 */
export interface EventPipelineInfoEventSchema {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoEventSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof EventPipelineInfoEventSchema
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoPricePlansInner
 */
export interface EventPipelineInfoPricePlansInner {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlansInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlansInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlansInner
     */
    'scheduleId': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlansInner
     */
    'cycleStart': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlansInner
     */
    'cycleEnd': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventPipelineInfoPricePlansInner
     */
    'usageMeters'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoUsageMetersInner
 */
export interface EventPipelineInfoUsageMetersInner {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoUsageMetersInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoUsageMetersInner
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof EventPipelineInfoUsageMetersInner
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoUsageMetersInner
     */
    'status': EventPipelineInfoUsageMetersInnerStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof EventPipelineInfoUsageMetersInner
     */
    'units'?: number;
}

export const EventPipelineInfoUsageMetersInnerStatusEnum = {
    FilteredOut: 'PROCESSED_FILTERED_OUT',
    UnitsComputed: 'PROCESSED_UNITS_COMPUTED'
} as const;

export type EventPipelineInfoUsageMetersInnerStatusEnum = typeof EventPipelineInfoUsageMetersInnerStatusEnum[keyof typeof EventPipelineInfoUsageMetersInnerStatusEnum];

/**
 * Structure of an event schema
 * @export
 * @interface EventSchema
 */
export interface EventSchema {
    /**
     * Name of the event. Must be unique for an organization.
     * @type {string}
     * @memberof EventSchema
     */
    'name': string;
    /**
     * Description of the event
     * @type {string}
     * @memberof EventSchema
     */
    'description'?: string;
    /**
     * Version of event schema
     * @type {number}
     * @memberof EventSchema
     */
    'version': number;
    /**
     * Status of event schema * DRAFT - Schema is in draft state  * ACTIVE - Schema is currently active  * INACTIVE - Schema is currently inactive * ARCHIVED - Older version of event schema 
     * @type {string}
     * @memberof EventSchema
     */
    'status'?: EventSchemaStatusEnum;
    /**
     * 
     * @type {Array<EventAttributeSchema>}
     * @memberof EventSchema
     */
    'attributes': Array<EventAttributeSchema>;
    /**
     * 
     * @type {Array<DimensionsSchema>}
     * @memberof EventSchema
     */
    'dimensions'?: Array<DimensionsSchema>;
    /**
     * 
     * @type {string}
     * @memberof EventSchema
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSchema
     */
    'updatedAt'?: string;
}

export const EventSchemaStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type EventSchemaStatusEnum = typeof EventSchemaStatusEnum[keyof typeof EventSchemaStatusEnum];

/**
 * 
 * @export
 * @interface EventSchemaListData
 */
export interface EventSchemaListData {
    /**
     * Name of the event. Must be unique for an organization.
     * @type {string}
     * @memberof EventSchemaListData
     */
    'name': string;
    /**
     * Description of the event
     * @type {string}
     * @memberof EventSchemaListData
     */
    'description'?: string;
    /**
     * Version of event schema
     * @type {number}
     * @memberof EventSchemaListData
     */
    'version': number;
    /**
     * Status of event schema * DRAFT - Schema is in draft state  * ACTIVE - Schema is currently active  * INACTIVE - Schema is currently inactive * ARCHIVED - Older version of event schema 
     * @type {string}
     * @memberof EventSchemaListData
     */
    'status'?: EventSchemaListDataStatusEnum;
    /**
     * 
     * @type {Array<EventAttributeSchema>}
     * @memberof EventSchemaListData
     */
    'attributes': Array<EventAttributeSchema>;
    /**
     * 
     * @type {Array<DimensionsSchema>}
     * @memberof EventSchemaListData
     */
    'dimensions'?: Array<DimensionsSchema>;
    /**
     * 
     * @type {string}
     * @memberof EventSchemaListData
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSchemaListData
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventSchemaListData
     */
    'usageMetersCount'?: number;
}

export const EventSchemaListDataStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type EventSchemaListDataStatusEnum = typeof EventSchemaListDataStatusEnum[keyof typeof EventSchemaListDataStatusEnum];

/**
 * 
 * @export
 * @interface EventSchemaListDataAllOf
 */
export interface EventSchemaListDataAllOf {
    /**
     * 
     * @type {number}
     * @memberof EventSchemaListDataAllOf
     */
    'usageMetersCount'?: number;
}
/**
 * 
 * @export
 * @interface EventSchemaListPaginatedResponse
 */
export interface EventSchemaListPaginatedResponse {
    /**
     * 
     * @type {Array<EventSchemaListData>}
     * @memberof EventSchemaListPaginatedResponse
     */
    'data'?: Array<EventSchemaListData>;
    /**
     * 
     * @type {string}
     * @memberof EventSchemaListPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof EventSchemaListPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * Response for event schema versions
 * @export
 * @interface EventSchemaVersionsResponse
 */
export interface EventSchemaVersionsResponse {
    /**
     * 
     * @type {Array<EventSchema>}
     * @memberof EventSchemaVersionsResponse
     */
    'data': Array<EventSchema>;
}
/**
 * Raw usage event ingested by the business team and the status of the event ingestion.
 * @export
 * @interface EventWithStatus
 */
export interface EventWithStatus {
    /**
     * 
     * @type {Event}
     * @memberof EventWithStatus
     */
    'eventPayload': Event;
    /**
     * 
     * @type {IngestionStatus}
     * @memberof EventWithStatus
     */
    'ingestionStatus': IngestionStatus;
}
/**
 * 
 * @export
 * @interface EventWithStatusAndEventPipelineInfo
 */
export interface EventWithStatusAndEventPipelineInfo {
    /**
     * 
     * @type {Event}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'eventPayload': Event;
    /**
     * 
     * @type {IngestionStatus}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'ingestionStatus': IngestionStatus;
    /**
     * 
     * @type {EventPipelineInfo}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'EventPipelineInfo'?: EventPipelineInfo;
}
/**
 * 
 * @export
 * @interface EventWithStatusAndEventPipelineInfoAllOf
 */
export interface EventWithStatusAndEventPipelineInfoAllOf {
    /**
     * 
     * @type {EventPipelineInfo}
     * @memberof EventWithStatusAndEventPipelineInfoAllOf
     */
    'EventPipelineInfo'?: EventPipelineInfo;
}
/**
 * Get single event response
 * @export
 * @interface GetEventResponse
 */
export interface GetEventResponse {
    /**
     * 
     * @type {Array<EventWithStatusAndEventPipelineInfo>}
     * @memberof GetEventResponse
     */
    'events': Array<EventWithStatusAndEventPipelineInfo>;
}
/**
 * Get batch events response
 * @export
 * @interface GetEventsResponse
 */
export interface GetEventsResponse {
    /**
     * 
     * @type {Array<EventWithStatus>}
     * @memberof GetEventsResponse
     */
    'events': Array<EventWithStatus>;
    /**
     * 
     * @type {string}
     * @memberof GetEventsResponse
     */
    'nextToken'?: string;
}
/**
 * Request to get metrics from togai
 * @export
 * @interface GetMetricsRequest
 */
export interface GetMetricsRequest {
    /**
     * 
     * @type {string}
     * @memberof GetMetricsRequest
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof GetMetricsRequest
     */
    'endTime': string;
    /**
     * 
     * @type {Array<MetricQuery>}
     * @memberof GetMetricsRequest
     */
    'metricQueries': Array<MetricQuery>;
}
/**
 * Response to GetMetrics Request
 * @export
 * @interface GetMetricsResponse
 */
export interface GetMetricsResponse {
    /**
     * 
     * @type {Array<MetricQueryResponse>}
     * @memberof GetMetricsResponse
     */
    'results': Array<MetricQueryResponse>;
}
/**
 * Payload for ingesting batch events
 * @export
 * @interface IngestBatchEventRequest
 */
export interface IngestBatchEventRequest {
    /**
     * 
     * @type {Array<Event>}
     * @memberof IngestBatchEventRequest
     */
    'events': Array<Event>;
}
/**
 * 
 * @export
 * @interface IngestBatchEventResponse
 */
export interface IngestBatchEventResponse {
    /**
     * 
     * @type {Array<IngestError>}
     * @memberof IngestBatchEventResponse
     */
    'errors': Array<IngestError>;
}
/**
 * 
 * @export
 * @interface IngestError
 */
export interface IngestError {
    /**
     * 
     * @type {string}
     * @memberof IngestError
     */
    'message'?: string;
    /**
     * 
     * @type {Event}
     * @memberof IngestError
     */
    'eventPayload'?: Event;
}
/**
 * Payload for ingesting events
 * @export
 * @interface IngestEventRequest
 */
export interface IngestEventRequest {
    /**
     * 
     * @type {Event}
     * @memberof IngestEventRequest
     */
    'event'?: Event;
}
/**
 * 
 * @export
 * @interface IngestEventResponse
 */
export interface IngestEventResponse {
    /**
     * On successful ingestion acceptance request, ingestion request id will be returned. This ingestion id can be used by clients to query the status of ingestion (IN_PROGRESS, COMPLETED).
     * @type {string}
     * @memberof IngestEventResponse
     */
    'ingestionRequestId': string;
}
/**
 * Status about the event ingestion.
 * @export
 * @interface IngestionStatus
 */
export interface IngestionStatus {
    /**
     * Ingestion status
     * @type {string}
     * @memberof IngestionStatus
     */
    'status': IngestionStatusStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof IngestionStatus
     */
    'statusDescription'?: string;
}

export const IngestionStatusStatusEnum = {
    IngestionInProgress: 'INGESTION_IN_PROGRESS',
    IngestionFailed: 'INGESTION_FAILED',
    IngestionFailedSchemaNotDefined: 'INGESTION_FAILED_SCHEMA_NOT_DEFINED',
    IngestionFailedUnitsInvalid: 'INGESTION_FAILED_UNITS_INVALID',
    IngestionFailedEventInvalid: 'INGESTION_FAILED_EVENT_INVALID',
    IngestionCompletedNoMatchingMeters: 'INGESTION_COMPLETED_NO_MATCHING_METERS',
    IngestionCompletedEventMetered: 'INGESTION_COMPLETED_EVENT_METERED',
    IngestionCompletedEventNotMetered: 'INGESTION_COMPLETED_EVENT_NOT_METERED',
    Unknown: 'UNKNOWN'
} as const;

export type IngestionStatusStatusEnum = typeof IngestionStatusStatusEnum[keyof typeof IngestionStatusStatusEnum];

/**
 * 
 * @export
 * @interface MetricDataPoints
 */
export interface MetricDataPoints {
    /**
     * 
     * @type {MetricDataPointsGroupedBy}
     * @memberof MetricDataPoints
     */
    'groupedBy'?: MetricDataPointsGroupedBy;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetricDataPoints
     */
    'timestamps': Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof MetricDataPoints
     */
    'metricValues': Array<number>;
}
/**
 * 
 * @export
 * @interface MetricDataPointsGroupedBy
 */
export interface MetricDataPointsGroupedBy {
    /**
     * 
     * @type {string}
     * @memberof MetricDataPointsGroupedBy
     */
    'fieldName': string;
    /**
     * 
     * @type {string}
     * @memberof MetricDataPointsGroupedBy
     */
    'fieldValue': string;
}
/**
 * Define the metric you would like to get - allowed options are EVENTS - Aggregation of raw events, USAGE - Aggregated usage value from Usage meters, REVENUE - Aggregated of revenue value from Pricing Plans 
 * @export
 * @enum {string}
 */

export const MetricName = {
    Events: 'EVENTS',
    Usage: 'USAGE',
    Revenue: 'REVENUE'
} as const;

export type MetricName = typeof MetricName[keyof typeof MetricName];


/**
 * Object representing a single metrics query
 * @export
 * @interface MetricQuery
 */
export interface MetricQuery {
    /**
     * Mandatory  for all request.  User defined ID for identifying the request for your internal reference 
     * @type {string}
     * @memberof MetricQuery
     */
    'id': string;
    /**
     * 
     * @type {MetricName}
     * @memberof MetricQuery
     */
    'name': MetricName;
    /**
     * Set the aggregation period. Allowed periods are DAY, WEEK, MONTH
     * @type {string}
     * @memberof MetricQuery
     */
    'aggregationPeriod': MetricQueryAggregationPeriodEnum;
    /**
     * Group your metric with a groupBy field.  Allowed fields are ACCOUNT_ID, EVENT_STATUS, SCHEMA_NAME, USAGE_METER_ID.  Please refer the table above for the list of combinations allowed in the groupBy 
     * @type {string}
     * @memberof MetricQuery
     */
    'groupBy'?: string;
    /**
     * Configurations. | Metric Name | Config Key | Allowed Values  | Default value |              Description             | |-------------|------------|-----------------|---------------|--------------------------------------| | REVENUE     | CURRENCY   | BASE or INVOICE | BASE          | currency to return the revenue in    | 
     * @type {{ [key: string]: string; }}
     * @memberof MetricQuery
     */
    'configs'?: { [key: string]: string; };
    /**
     * Field Values” required when “Field Name” is present.  You can find a list of Field Values (FilterEntry Name) combinations allowed in the table mentioned above the body param. 
     * @type {Array<MetricQueryFilterEntry>}
     * @memberof MetricQuery
     */
    'filters'?: Array<MetricQueryFilterEntry>;
}

export const MetricQueryAggregationPeriodEnum = {
    Day: 'DAY',
    Week: 'WEEK',
    Month: 'MONTH'
} as const;

export type MetricQueryAggregationPeriodEnum = typeof MetricQueryAggregationPeriodEnum[keyof typeof MetricQueryAggregationPeriodEnum];

/**
 *  | Metric Name | FilterEntry Name |    Allowed groupBy fields                 |      Default Values      |                 Allowed Values                  | |-------------|------------------|-------------------------------------------|--------------------------|-------------------------------------------------| | EVENTS      | ACCOUNT_ID       | ACCOUNT_ID, EVENT_STATUS, SCHEMA_NAME     | None                     | *\\<one or more valid accounts IDs>              | | EVENTS      | CUSTOMER_ID      | ACCOUNT_ID, EVENT_STATUS, SCHEMA_NAME     | None                     | *\\<at most one valid customer ID>               | | EVENTS      | SCHEMA_NAME      | ACCOUNT_ID, EVENT_STATUS, SCHEMA_NAME     | None                     | *\\<at most one valid schema names>              | | EVENTS      | EVENT_STATUS     | ACCOUNT_ID, EVENT_STATUS, SCHEMA_NAME     | [PROCESSED, UNPROCESSED] | oneOrMoreOf PROCESSED, UNPROCESSED, IN_PROGRESS | | USAGE       | ACCOUNT_ID       | ACCOUNT_ID, USAGE_METER_ID                | None                     | *\\<one or more valid accounts ID>               | | USAGE       | CUSTOMER_ID      | ACCOUNT_ID, USAGE_METER_ID                | None                     | *\\<at most one valid customer ID>               | | USAGE       | USAGE_METER_ID   | ACCOUNT_ID, USAGE_METER_ID                | None                     | *\\<one or more valid usage meter name>          | | REVENUE     | ACCOUNT_ID       | ACCOUNT_ID, USAGE_METER_ID                | None                     | *\\<one or more valid accounts ID>               | | REVENUE     | CUSTOMER_ID      | ACCOUNT_ID, USAGE_METER_ID                | None                     | *\\<at most one valid customer ID>               | | REVENUE     | USAGE_METER_ID   | ACCOUNT_ID, USAGE_METER_ID                | None                     | *\\<one or more valid usage meter name>          | | EVENTS      | ORGANIZATION_ID  | ACCOUNT_ID, USAGE_METER_ID                | <From auth token>        |                                                 | | USAGE       | ORGANIZATION_ID  | ACCOUNT_ID, USAGE_METER_ID                | <From auth token>        |                                                 | | REVENUE     | ORGANIZATION_ID  | ACCOUNT_ID, USAGE_METER_ID                | <From auth token>        |                                                 | 
 * @export
 * @interface MetricQueryFilterEntry
 */
export interface MetricQueryFilterEntry {
    /**
     * 
     * @type {string}
     * @memberof MetricQueryFilterEntry
     */
    'fieldName': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetricQueryFilterEntry
     */
    'fieldValues': Array<string>;
}
/**
 * Response to GetMetrics Request
 * @export
 * @interface MetricQueryResponse
 */
export interface MetricQueryResponse {
    /**
     * 
     * @type {string}
     * @memberof MetricQueryResponse
     */
    'id': string;
    /**
     * 
     * @type {MetricName}
     * @memberof MetricQueryResponse
     */
    'name': MetricName;
    /**
     * 
     * @type {Array<MetricDataPoints>}
     * @memberof MetricQueryResponse
     */
    'data': Array<MetricDataPoints>;
}
/**
 * 
 * @export
 * @interface OrganizationSetting
 */
export interface OrganizationSetting {
    /**
     * Base currency of the organization
     * @type {string}
     * @memberof OrganizationSetting
     */
    'baseCurrency'?: string;
}
/**
 * 
 * @export
 * @interface PaginationOptions
 */
export interface PaginationOptions {
    /**
     * 
     * @type {number}
     * @memberof PaginationOptions
     */
    'pageSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginationOptions
     */
    'sortOrder'?: PaginationOptionsSortOrderEnum;
}

export const PaginationOptionsSortOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type PaginationOptionsSortOrderEnum = typeof PaginationOptionsSortOrderEnum[keyof typeof PaginationOptionsSortOrderEnum];

/**
 * Represents effectiveness period and config of a price plan. i.e, price plan bound by time.
 * @export
 * @interface PlanOverride
 */
export interface PlanOverride {
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'pricePlanId': string;
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'pricePlanName': string;
    /**
     * 
     * @type {PricePlanDetailsOverride}
     * @memberof PlanOverride
     */
    'pricePlanDetailsOverride'?: PricePlanDetailsOverride;
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'endDate': string;
}
/**
 * Price plan entity
 * @export
 * @interface PricePlan
 */
export interface PricePlan {
    /**
     * Price plan id
     * @type {string}
     * @memberof PricePlan
     */
    'id': string;
    /**
     * Name of the price plan
     * @type {string}
     * @memberof PricePlan
     */
    'name': string;
    /**
     * Description of price plan
     * @type {string}
     * @memberof PricePlan
     */
    'description'?: string;
    /**
     * Status of Price plan
     * @type {string}
     * @memberof PricePlan
     */
    'status': PricePlanStatusEnum;
    /**
     * 
     * @type {Array<PricingSchedule>}
     * @memberof PricePlan
     */
    'pricingSchedule': Array<PricingSchedule>;
}

export const PricePlanStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type PricePlanStatusEnum = typeof PricePlanStatusEnum[keyof typeof PricePlanStatusEnum];

/**
 * 
 * @export
 * @interface PricePlanDetails
 */
export interface PricePlanDetails {
    /**
     * 
     * @type {Array<string>}
     * @memberof PricePlanDetails
     */
    'supportedCurrencies': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PricePlanDetails
     */
    'activeCurrencies': Array<string>;
    /**
     * 
     * @type {PricingCycleConfig}
     * @memberof PricePlanDetails
     */
    'pricingCycleConfig': PricingCycleConfig;
    /**
     * 
     * @type {Array<UsageRateCard>}
     * @memberof PricePlanDetails
     */
    'usageRateCards': Array<UsageRateCard>;
}
/**
 * 
 * @export
 * @interface PricePlanDetailsOverride
 */
export interface PricePlanDetailsOverride {
    /**
     * 
     * @type {PricingCycleConfig}
     * @memberof PricePlanDetailsOverride
     */
    'pricingCycleConfig'?: PricingCycleConfig;
    /**
     * 
     * @type {Array<UsageRateCard>}
     * @memberof PricePlanDetailsOverride
     */
    'usageRateCards'?: Array<UsageRateCard>;
}
/**
 * Data of price plan list
 * @export
 * @interface PricePlanListData
 */
export interface PricePlanListData {
    /**
     * Identifier of price plan
     * @type {string}
     * @memberof PricePlanListData
     */
    'id': string;
    /**
     * Name of the price plan
     * @type {string}
     * @memberof PricePlanListData
     */
    'name': string;
    /**
     * Description of price plan
     * @type {string}
     * @memberof PricePlanListData
     */
    'description'?: string;
    /**
     * Status of Price plan
     * @type {string}
     * @memberof PricePlanListData
     */
    'status': PricePlanListDataStatusEnum;
    /**
     * Usage meters id linked to the price plan
     * @type {Array<string>}
     * @memberof PricePlanListData
     */
    'usageMeters': Array<string>;
    /**
     * 
     * @type {PricePlanDetails}
     * @memberof PricePlanListData
     */
    'pricePlanDetails': PricePlanDetails;
    /**
     * 
     * @type {string}
     * @memberof PricePlanListData
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PricePlanListData
     */
    'updatedAt': string;
}

export const PricePlanListDataStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type PricePlanListDataStatusEnum = typeof PricePlanListDataStatusEnum[keyof typeof PricePlanListDataStatusEnum];

/**
 * 
 * @export
 * @interface PricePlanPaginatedResponse
 */
export interface PricePlanPaginatedResponse {
    /**
     * 
     * @type {Array<PricePlanListData>}
     * @memberof PricePlanPaginatedResponse
     */
    'data': Array<PricePlanListData>;
    /**
     * 
     * @type {string}
     * @memberof PricePlanPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof PricePlanPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PriceType = {
    Flat: 'FLAT',
    PerUnit: 'PER_UNIT',
    Package: 'PACKAGE'
} as const;

export type PriceType = typeof PriceType[keyof typeof PriceType];


/**
 * Represents configurations related to pricing cycle
 * @export
 * @interface PricingCycleConfig
 */
export interface PricingCycleConfig {
    /**
     * Interval field allow you to define the billing interval you would like to set
     * @type {string}
     * @memberof PricingCycleConfig
     */
    'interval': PricingCycleConfigIntervalEnum;
    /**
     * 
     * @type {PricingCycleConfigStartOffset}
     * @memberof PricingCycleConfig
     */
    'startOffset': PricingCycleConfigStartOffset;
    /**
     * Togai allows you to ingest past dated events that will be processed by a pricing cycle till the end grace period.  For example: Pricing cycle is Monthly from 1st to 30th and gracePeriod is 5 days which next month 1 to 5th date, you can ingest past dated events during this grace period. 
     * @type {number}
     * @memberof PricingCycleConfig
     */
    'gracePeriod': number;
}

export const PricingCycleConfigIntervalEnum = {
    Monthly: 'MONTHLY',
    Quarterly: 'QUARTERLY',
    HalfYearly: 'HALF_YEARLY',
    Annually: 'ANNUALLY'
} as const;

export type PricingCycleConfigIntervalEnum = typeof PricingCycleConfigIntervalEnum[keyof typeof PricingCycleConfigIntervalEnum];

/**
 * Represents the start of pricing cycle in terms of  - dayOffset - number of days from beginning of month and  - monthOffset - number of months from beginning of interval (quarter, half-year or year) Note: If a day with offset doesn\'t exist for a month, closest previous day is considered Examples: MONTHLY -   - {dayOffset: 1, monthOffset: NIL} - First day of every month   - {dayOffset: 12, monthOffset: NIL} - 12th of every month   - {dayOffset: 28, monthOffset: NIL} - 28th of every month. i.e, 28th of Jan, 28th of Feb, ...   - {dayOffset: 30, monthOffset: NIL} - 30th of every month. i.e, 28th of Jan, 28th of Feb, ...   - {dayOffset: LAST, monthOffset: NIL} - Last day of every month. i.e, 31st of Jan, 28th of Feb, ... QUARTERLY   - {dayOffset: 15, monthOffset: FIRST} - 15th Jan, 15th Apr, 15th Jul and 15th Oct   - {dayOffset: 15, monthOffset: 2} - 15th Feb, 15th May, 15th Aug and 15th Nov   - {dayOffset: 15, monthOffset: LAST} - 15th Mar, 15th Jun, 15th Sep and 15th Dec   - {dayOffset: LAST, monthOffset: FIRST} - 31st Jan, 30th Apr, 30th Jul and 31th Oct HALF_YEARLY   - {dayOffset: 15, monthOffset: FIRST} - 15th Jan and 15th Jul   - {dayOffset: 15, monthOffset: 4} - 15th Apr and 15th Oct   - {dayOffset: 15, monthOffset: LAST} - 15th Jun and 15th Dec ANNUALLY   - {dayOffset: 15, monthOffset: FIRST} - 15th Jan   - {dayOffset: 15, monthOffset: 1} - 15th Jan   - {dayOffset: LAST, monthOffset: 2} - 29th Feb on Leap year, 28th otherwise    - {dayOffset: 15, monthOffset: 8} - 15th Aug   - {dayOffset: 15, monthOffset: LAST} - 15th Dec 
 * @export
 * @interface PricingCycleConfigStartOffset
 */
export interface PricingCycleConfigStartOffset {
    /**
     * min: \"1\" and max: \"31\" as strings. Spl. string allowed: LAST 
     * @type {string}
     * @memberof PricingCycleConfigStartOffset
     */
    'dayOffset': string;
    /**
     * min: \"1\" and max: \"12\". Spl. string allowed: FIRST / LAST. For QUARTERLY only 1 - 3 is allowed and for HALF_YEARLY 1 - 6. This being an optional field, shouldn\'t be passed for MONTHLY. 
     * @type {string}
     * @memberof PricingCycleConfigStartOffset
     */
    'monthOffset': string;
}
/**
 * Togai supports two type of pricing model Tiered and Volume. Tiered pricing model applies respective slab and its rate to the usage value while volume pricing model applies the latest matching slab of the usage value and applies respective rate.  For more understanding read [Rate Cards](https://docs.togai.com/docs/priceplan#setting-up-multiple-rate-cards) 
 * @export
 * @enum {string}
 */

export const PricingModel = {
    Tiered: 'TIERED',
    Volume: 'VOLUME'
} as const;

export type PricingModel = typeof PricingModel[keyof typeof PricingModel];


/**
 * Represents effectiveness period and config of a price plan. i.e, price plan bound by time.
 * @export
 * @interface PricingSchedule
 */
export interface PricingSchedule {
    /**
     * 
     * @type {PricePlanDetails}
     * @memberof PricingSchedule
     */
    'pricePlanDetails'?: PricePlanDetails;
    /**
     * 
     * @type {string}
     * @memberof PricingSchedule
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof PricingSchedule
     */
    'endDate': string;
}
/**
 * Contains all rate related configurations
 * @export
 * @interface RatePlan
 */
export interface RatePlan {
    /**
     * 
     * @type {PricingModel}
     * @memberof RatePlan
     */
    'pricingModel': PricingModel;
    /**
     * Rate cards can have single or multiple slab up to 100.
     * @type {Array<Slab>}
     * @memberof RatePlan
     */
    'slabs': Array<Slab>;
}
/**
 * Represents a rate
 * @export
 * @interface RateValue
 */
export interface RateValue {
    /**
     * 
     * @type {string}
     * @memberof RateValue
     */
    'currency': string;
    /**
     * 
     * @type {Array<SlabRate>}
     * @memberof RateValue
     */
    'slabRates': Array<SlabRate>;
}
/**
 * Payload to remove aliases from account
 * @export
 * @interface RemoveAccountAliasesRequest
 */
export interface RemoveAccountAliasesRequest {
    /**
     * List of aliases to remove
     * @type {Array<string>}
     * @memberof RemoveAccountAliasesRequest
     */
    'aliases'?: Array<string>;
}
/**
 * Represents user_setting
 * @export
 * @interface Setting
 */
export interface Setting {
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'settingName': string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'settingValue': string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'entityType': string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'entityId': string;
}
/**
 * Payload to signup
 * @export
 * @interface SignupRequest
 */
export interface SignupRequest {
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    'description'?: string;
    /**
     * 
     * @type {UserDetails}
     * @memberof SignupRequest
     */
    'userDetails': UserDetails;
}
/**
 * Signup response
 * @export
 * @interface SignupResponse
 */
export interface SignupResponse {
    /**
     * Organization Identifier
     * @type {string}
     * @memberof SignupResponse
     */
    'organizationId': string;
    /**
     * Token which can be used for authentication
     * @type {string}
     * @memberof SignupResponse
     */
    'jwtToken': string;
}
/**
 * Represents a pricing priceType (rates + slabs) for usage price plan
 * @export
 * @interface Slab
 */
export interface Slab {
    /**
     * 
     * @type {number}
     * @memberof Slab
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof Slab
     */
    'startAfter': number;
    /**
     * 
     * @type {PriceType}
     * @memberof Slab
     */
    'priceType': PriceType;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Slab
     */
    'slabConfig'?: { [key: string]: string; };
}
/**
 * Represents a rate for a slab
 * @export
 * @interface SlabRate
 */
export interface SlabRate {
    /**
     * 
     * @type {number}
     * @memberof SlabRate
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof SlabRate
     */
    'rate': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SlabRate
     */
    'slabRateConfig'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface StatusResponse
 */
export interface StatusResponse {
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'greeting'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'url'?: string;
    /**
     * 
     * @type {StatusResponseHeaders}
     * @memberof StatusResponse
     */
    'headers'?: StatusResponseHeaders;
}
/**
 * 
 * @export
 * @interface StatusResponseHeaders
 */
export interface StatusResponseHeaders {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof StatusResponseHeaders
     */
    'Content-Type'?: string;
}
/**
 * Payload to update account
 * @export
 * @interface UpdateAccountRequest
 */
export interface UpdateAccountRequest {
    /**
     * Name of the customer
     * @type {string}
     * @memberof UpdateAccountRequest
     */
    'name'?: string;
}
/**
 * Payload to update customer
 * @export
 * @interface UpdateCustomerRequest
 */
export interface UpdateCustomerRequest {
    /**
     * Name of the customer
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'name'?: string;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'primaryEmail'?: string;
    /**
     * billing address of the customer
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'billingAddress'?: string;
}
/**
 * Request to update event schema
 * @export
 * @interface UpdateEventSchemaRequest
 */
export interface UpdateEventSchemaRequest {
    /**
     * Description of the event
     * @type {string}
     * @memberof UpdateEventSchemaRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<EventAttributeSchema>}
     * @memberof UpdateEventSchemaRequest
     */
    'attributes': Array<EventAttributeSchema>;
    /**
     * 
     * @type {Array<DimensionsSchema>}
     * @memberof UpdateEventSchemaRequest
     */
    'dimensions': Array<DimensionsSchema>;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationSettingRequest
 */
export interface UpdateOrganizationSettingRequest {
    /**
     * Base currency of the organization
     * @type {string}
     * @memberof UpdateOrganizationSettingRequest
     */
    'baseCurrency': string;
}
/**
 * Request to update a price plan
 * @export
 * @interface UpdatePricePlanRequest
 */
export interface UpdatePricePlanRequest {
    /**
     * Description of price plan
     * @type {string}
     * @memberof UpdatePricePlanRequest
     */
    'description'?: string;
    /**
     * 
     * @type {PricePlanDetailsOverride}
     * @memberof UpdatePricePlanRequest
     */
    'pricePlanDetails'?: PricePlanDetailsOverride;
}
/**
 * Request to update usage meter
 * @export
 * @interface UpdateUsageMeterRequest
 */
export interface UpdateUsageMeterRequest {
    /**
     * Description of the event
     * @type {string}
     * @memberof UpdateUsageMeterRequest
     */
    'description'?: string;
    /**
     * Type of usage meter * COUNTER - Count usage  
     * @type {string}
     * @memberof UpdateUsageMeterRequest
     */
    'type': UpdateUsageMeterRequestTypeEnum;
    /**
     * Aggregation to be applied on usage meter result * COUNT - Counts number of events matching the usage meter * SUM - Sums up results of computation of all events matching usage meter 
     * @type {string}
     * @memberof UpdateUsageMeterRequest
     */
    'aggregation': UpdateUsageMeterRequestAggregationEnum;
    /**
     * 
     * @type {Array<Computation>}
     * @memberof UpdateUsageMeterRequest
     */
    'computations'?: Array<Computation>;
}

export const UpdateUsageMeterRequestTypeEnum = {
    Counter: 'COUNTER'
} as const;

export type UpdateUsageMeterRequestTypeEnum = typeof UpdateUsageMeterRequestTypeEnum[keyof typeof UpdateUsageMeterRequestTypeEnum];
export const UpdateUsageMeterRequestAggregationEnum = {
    Count: 'COUNT',
    Sum: 'SUM'
} as const;

export type UpdateUsageMeterRequestAggregationEnum = typeof UpdateUsageMeterRequestAggregationEnum[keyof typeof UpdateUsageMeterRequestAggregationEnum];

/**
 * Structure of usage meter
 * @export
 * @interface UsageMeter
 */
export interface UsageMeter {
    /**
     * Identifier of the usage meter
     * @type {string}
     * @memberof UsageMeter
     */
    'id': string;
    /**
     * Name of the usage meter
     * @type {string}
     * @memberof UsageMeter
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UsageMeter
     */
    'description'?: string;
    /**
     * Type of usage meter
     * @type {string}
     * @memberof UsageMeter
     */
    'type': UsageMeterTypeEnum;
    /**
     * Status of usage meter
     * @type {string}
     * @memberof UsageMeter
     */
    'status'?: UsageMeterStatusEnum;
    /**
     * Aggregation to be applied on usage meter result
     * @type {string}
     * @memberof UsageMeter
     */
    'aggregation': UsageMeterAggregationEnum;
    /**
     * 
     * @type {Array<Computation>}
     * @memberof UsageMeter
     */
    'computations'?: Array<Computation>;
    /**
     * 
     * @type {string}
     * @memberof UsageMeter
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsageMeter
     */
    'lastActivatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsageMeter
     */
    'updatedAt'?: string;
}

export const UsageMeterTypeEnum = {
    Counter: 'COUNTER'
} as const;

export type UsageMeterTypeEnum = typeof UsageMeterTypeEnum[keyof typeof UsageMeterTypeEnum];
export const UsageMeterStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type UsageMeterStatusEnum = typeof UsageMeterStatusEnum[keyof typeof UsageMeterStatusEnum];
export const UsageMeterAggregationEnum = {
    Count: 'COUNT',
    Sum: 'SUM'
} as const;

export type UsageMeterAggregationEnum = typeof UsageMeterAggregationEnum[keyof typeof UsageMeterAggregationEnum];

/**
 * 
 * @export
 * @interface UsageMeterPaginatedResponse
 */
export interface UsageMeterPaginatedResponse {
    /**
     * 
     * @type {Array<UsageMeter>}
     * @memberof UsageMeterPaginatedResponse
     */
    'data'?: Array<UsageMeter>;
    /**
     * 
     * @type {string}
     * @memberof UsageMeterPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof UsageMeterPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * 
 * @export
 * @interface UsageRate
 */
export interface UsageRate {
    /**
     * The usage meter will be associated with the rate card to transform the usage value to billable value
     * @type {string}
     * @memberof UsageRate
     */
    'usageMeterId': string;
    /**
     * List of slab rates
     * @type {Array<SlabRate>}
     * @memberof UsageRate
     */
    'slabRates': Array<SlabRate>;
}
/**
 * 
 * @export
 * @interface UsageRateCard
 */
export interface UsageRateCard {
    /**
     * Name your rate card, this will be displayed in the Togai App
     * @type {string}
     * @memberof UsageRateCard
     */
    'displayName': string;
    /**
     * The usage meter will be associated with the rate card to transform the usage value to billable value
     * @type {string}
     * @memberof UsageRateCard
     */
    'usageMeterId': string;
    /**
     * 
     * @type {RatePlan}
     * @memberof UsageRateCard
     */
    'ratePlan': RatePlan;
    /**
     * 
     * @type {Array<RateValue>}
     * @memberof UsageRateCard
     */
    'rateValues': Array<RateValue>;
}
/**
 * Root user details for the organization
 * @export
 * @interface UserDetails
 */
export interface UserDetails {
    /**
     * 
     * @type {string}
     * @memberof UserDetails
     */
    'preferredUsername'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDetails
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserDetails
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserDetails
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserDetails
     */
    'phone'?: string;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add aliases to an account using customer_id and account_id.
         * @summary Add Aliases to account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {AddAccountAliasesRequest} addAccountAliasesRequest Payload to add aliases to account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAliases: async (customerId: string, accountId: string, addAccountAliasesRequest: AddAccountAliasesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('addAliases', 'customerId', customerId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('addAliases', 'accountId', accountId)
            // verify required parameter 'addAccountAliasesRequest' is not null or undefined
            assertParamExists('addAliases', 'addAccountAliasesRequest', addAccountAliasesRequest)
            const localVarPath = `/customers/{customer_id}/accounts/{account_id}/add_aliases`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAccountAliasesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to assign a price plan to an existing account
         * @summary Associate a plan to an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {AssociatePricePlanRequest} associatePricePlanRequest Payload to associate a price plan to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        associatePricePlan: async (customerId: string, accountId: string, associatePricePlanRequest: AssociatePricePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('associatePricePlan', 'customerId', customerId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('associatePricePlan', 'accountId', accountId)
            // verify required parameter 'associatePricePlanRequest' is not null or undefined
            assertParamExists('associatePricePlan', 'associatePricePlanRequest', associatePricePlanRequest)
            const localVarPath = `/customers/{customer_id}/accounts/{account_id}/price_plans`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(associatePricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to create an account for a customer using customer_id.
         * @summary Create an account
         * @param {string} customerId 
         * @param {CreateAccountRequest} createAccountRequest Payload to create account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (customerId: string, createAccountRequest: CreateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('createAccount', 'customerId', customerId)
            // verify required parameter 'createAccountRequest' is not null or undefined
            assertParamExists('createAccount', 'createAccountRequest', createAccountRequest)
            const localVarPath = `/customers/{customer_id}/accounts`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to delete a customer using customer_id and account_id.
         * @summary Delete an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (customerId: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('deleteAccount', 'customerId', customerId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAccount', 'accountId', accountId)
            const localVarPath = `/customers/{customer_id}/accounts/{account_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account information using customer_id and account_id.
         * @summary Get an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (customerId: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getAccount', 'customerId', customerId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccount', 'accountId', accountId)
            const localVarPath = `/customers/{customer_id}/accounts/{account_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of accounts of a customer with pagination and sort.
         * @summary List accounts of customer
         * @param {string} customerId 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (customerId: string, nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getAccounts', 'customerId', customerId)
            const localVarPath = `/customers/{customer_id}/accounts`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove existing aliases tagged to an account using this API
         * @summary Remove Aliases to account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {RemoveAccountAliasesRequest} removeAccountAliasesRequest Payload to remove aliases from account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAliases: async (customerId: string, accountId: string, removeAccountAliasesRequest: RemoveAccountAliasesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('removeAliases', 'customerId', customerId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('removeAliases', 'accountId', accountId)
            // verify required parameter 'removeAccountAliasesRequest' is not null or undefined
            assertParamExists('removeAliases', 'removeAccountAliasesRequest', removeAccountAliasesRequest)
            const localVarPath = `/customers/{customer_id}/accounts/{account_id}/remove_aliases`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeAccountAliasesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to update an account’s information using customer_id and account_id.
         * @summary Update an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {UpdateAccountRequest} updateAccountRequest Payload to update account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (customerId: string, accountId: string, updateAccountRequest: UpdateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('updateAccount', 'customerId', customerId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateAccount', 'accountId', accountId)
            // verify required parameter 'updateAccountRequest' is not null or undefined
            assertParamExists('updateAccount', 'updateAccountRequest', updateAccountRequest)
            const localVarPath = `/customers/{customer_id}/accounts/{account_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add aliases to an account using customer_id and account_id.
         * @summary Add Aliases to account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {AddAccountAliasesRequest} addAccountAliasesRequest Payload to add aliases to account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAliases(customerId: string, accountId: string, addAccountAliasesRequest: AddAccountAliasesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAliases(customerId, accountId, addAccountAliasesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to assign a price plan to an existing account
         * @summary Associate a plan to an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {AssociatePricePlanRequest} associatePricePlanRequest Payload to associate a price plan to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async associatePricePlan(customerId: string, accountId: string, associatePricePlanRequest: AssociatePricePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssociatePricePlanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.associatePricePlan(customerId, accountId, associatePricePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to create an account for a customer using customer_id.
         * @summary Create an account
         * @param {string} customerId 
         * @param {CreateAccountRequest} createAccountRequest Payload to create account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(customerId: string, createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(customerId, createAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to delete a customer using customer_id and account_id.
         * @summary Delete an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(customerId: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(customerId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get account information using customer_id and account_id.
         * @summary Get an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(customerId: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(customerId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of accounts of a customer with pagination and sort.
         * @summary List accounts of customer
         * @param {string} customerId 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(customerId: string, nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(customerId, nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove existing aliases tagged to an account using this API
         * @summary Remove Aliases to account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {RemoveAccountAliasesRequest} removeAccountAliasesRequest Payload to remove aliases from account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAliases(customerId: string, accountId: string, removeAccountAliasesRequest: RemoveAccountAliasesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAliases(customerId, accountId, removeAccountAliasesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to update an account’s information using customer_id and account_id.
         * @summary Update an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {UpdateAccountRequest} updateAccountRequest Payload to update account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(customerId: string, accountId: string, updateAccountRequest: UpdateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(customerId, accountId, updateAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Add aliases to an account using customer_id and account_id.
         * @summary Add Aliases to account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {AddAccountAliasesRequest} addAccountAliasesRequest Payload to add aliases to account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAliases(customerId: string, accountId: string, addAccountAliasesRequest: AddAccountAliasesRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.addAliases(customerId, accountId, addAccountAliasesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to assign a price plan to an existing account
         * @summary Associate a plan to an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {AssociatePricePlanRequest} associatePricePlanRequest Payload to associate a price plan to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        associatePricePlan(customerId: string, accountId: string, associatePricePlanRequest: AssociatePricePlanRequest, options?: any): AxiosPromise<AssociatePricePlanResponse> {
            return localVarFp.associatePricePlan(customerId, accountId, associatePricePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to create an account for a customer using customer_id.
         * @summary Create an account
         * @param {string} customerId 
         * @param {CreateAccountRequest} createAccountRequest Payload to create account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(customerId: string, createAccountRequest: CreateAccountRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.createAccount(customerId, createAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to delete a customer using customer_id and account_id.
         * @summary Delete an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(customerId: string, accountId: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteAccount(customerId, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get account information using customer_id and account_id.
         * @summary Get an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(customerId: string, accountId: string, options?: any): AxiosPromise<Account> {
            return localVarFp.getAccount(customerId, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of accounts of a customer with pagination and sort.
         * @summary List accounts of customer
         * @param {string} customerId 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(customerId: string, nextToken?: string, pageSize?: number, options?: any): AxiosPromise<AccountPaginatedResponse> {
            return localVarFp.getAccounts(customerId, nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove existing aliases tagged to an account using this API
         * @summary Remove Aliases to account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {RemoveAccountAliasesRequest} removeAccountAliasesRequest Payload to remove aliases from account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAliases(customerId: string, accountId: string, removeAccountAliasesRequest: RemoveAccountAliasesRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.removeAliases(customerId, accountId, removeAccountAliasesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to update an account’s information using customer_id and account_id.
         * @summary Update an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {UpdateAccountRequest} updateAccountRequest Payload to update account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(customerId: string, accountId: string, updateAccountRequest: UpdateAccountRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.updateAccount(customerId, accountId, updateAccountRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Add aliases to an account using customer_id and account_id.
     * @summary Add Aliases to account
     * @param {string} customerId 
     * @param {string} accountId 
     * @param {AddAccountAliasesRequest} addAccountAliasesRequest Payload to add aliases to account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public addAliases(customerId: string, accountId: string, addAccountAliasesRequest: AddAccountAliasesRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).addAliases(customerId, accountId, addAccountAliasesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to assign a price plan to an existing account
     * @summary Associate a plan to an account
     * @param {string} customerId 
     * @param {string} accountId 
     * @param {AssociatePricePlanRequest} associatePricePlanRequest Payload to associate a price plan to an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public associatePricePlan(customerId: string, accountId: string, associatePricePlanRequest: AssociatePricePlanRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).associatePricePlan(customerId, accountId, associatePricePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to create an account for a customer using customer_id.
     * @summary Create an account
     * @param {string} customerId 
     * @param {CreateAccountRequest} createAccountRequest Payload to create account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccount(customerId: string, createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createAccount(customerId, createAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to delete a customer using customer_id and account_id.
     * @summary Delete an account
     * @param {string} customerId 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteAccount(customerId: string, accountId: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).deleteAccount(customerId, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get account information using customer_id and account_id.
     * @summary Get an account
     * @param {string} customerId 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(customerId: string, accountId: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(customerId, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of accounts of a customer with pagination and sort.
     * @summary List accounts of customer
     * @param {string} customerId 
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccounts(customerId: string, nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccounts(customerId, nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove existing aliases tagged to an account using this API
     * @summary Remove Aliases to account
     * @param {string} customerId 
     * @param {string} accountId 
     * @param {RemoveAccountAliasesRequest} removeAccountAliasesRequest Payload to remove aliases from account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public removeAliases(customerId: string, accountId: string, removeAccountAliasesRequest: RemoveAccountAliasesRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).removeAliases(customerId, accountId, removeAccountAliasesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to update an account’s information using customer_id and account_id.
     * @summary Update an account
     * @param {string} customerId 
     * @param {string} accountId 
     * @param {UpdateAccountRequest} updateAccountRequest Payload to update account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateAccount(customerId: string, accountId: string, updateAccountRequest: UpdateAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updateAccount(customerId, accountId, updateAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomersApi - axios parameter creator
 * @export
 */
export const CustomersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API let’s you to create customers and corresponding accounts.
         * @summary Create a customer
         * @param {CreateCustomerRequest} createCustomerRequest Payload to create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer: async (createCustomerRequest: CreateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCustomerRequest' is not null or undefined
            assertParamExists('createCustomer', 'createCustomerRequest', createCustomerRequest)
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to delete a customer using customer_id.
         * @summary Delete a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer: async (customerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('deleteCustomer', 'customerId', customerId)
            const localVarPath = `/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get customer information using customer_id.
         * @summary Get a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer: async (customerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getCustomer', 'customerId', customerId)
            const localVarPath = `/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of customers with pagination and sort.
         * @summary List customers
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers: async (nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to update a customer’s information using customer_id.
         * @summary Update a customer
         * @param {string} customerId 
         * @param {UpdateCustomerRequest} updateCustomerRequest Payload to update customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer: async (customerId: string, updateCustomerRequest: UpdateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('updateCustomer', 'customerId', customerId)
            // verify required parameter 'updateCustomerRequest' is not null or undefined
            assertParamExists('updateCustomer', 'updateCustomerRequest', updateCustomerRequest)
            const localVarPath = `/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomersApi - functional programming interface
 * @export
 */
export const CustomersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomersApiAxiosParamCreator(configuration)
    return {
        /**
         * This API let’s you to create customers and corresponding accounts.
         * @summary Create a customer
         * @param {CreateCustomerRequest} createCustomerRequest Payload to create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomer(createCustomerRequest: CreateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomer(createCustomerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to delete a customer using customer_id.
         * @summary Delete a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomer(customerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomer(customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get customer information using customer_id.
         * @summary Get a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomer(customerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomer(customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of customers with pagination and sort.
         * @summary List customers
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomers(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomers(nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to update a customer’s information using customer_id.
         * @summary Update a customer
         * @param {string} customerId 
         * @param {UpdateCustomerRequest} updateCustomerRequest Payload to update customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomer(customerId, updateCustomerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomersApi - factory interface
 * @export
 */
export const CustomersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomersApiFp(configuration)
    return {
        /**
         * This API let’s you to create customers and corresponding accounts.
         * @summary Create a customer
         * @param {CreateCustomerRequest} createCustomerRequest Payload to create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(createCustomerRequest: CreateCustomerRequest, options?: any): AxiosPromise<CreateCustomerResponse> {
            return localVarFp.createCustomer(createCustomerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to delete a customer using customer_id.
         * @summary Delete a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(customerId: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteCustomer(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get customer information using customer_id.
         * @summary Get a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(customerId: string, options?: any): AxiosPromise<Customer> {
            return localVarFp.getCustomer(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of customers with pagination and sort.
         * @summary List customers
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers(nextToken?: string, pageSize?: number, options?: any): AxiosPromise<CustomerPaginatedResponse> {
            return localVarFp.getCustomers(nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to update a customer’s information using customer_id.
         * @summary Update a customer
         * @param {string} customerId 
         * @param {UpdateCustomerRequest} updateCustomerRequest Payload to update customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: any): AxiosPromise<Customer> {
            return localVarFp.updateCustomer(customerId, updateCustomerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */
export class CustomersApi extends BaseAPI {
    /**
     * This API let’s you to create customers and corresponding accounts.
     * @summary Create a customer
     * @param {CreateCustomerRequest} createCustomerRequest Payload to create customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public createCustomer(createCustomerRequest: CreateCustomerRequest, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).createCustomer(createCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to delete a customer using customer_id.
     * @summary Delete a customer
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public deleteCustomer(customerId: string, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).deleteCustomer(customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get customer information using customer_id.
     * @summary Get a customer
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomer(customerId: string, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getCustomer(customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of customers with pagination and sort.
     * @summary List customers
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomers(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getCustomers(nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to update a customer’s information using customer_id.
     * @summary Update a customer
     * @param {string} customerId 
     * @param {UpdateCustomerRequest} updateCustomerRequest Payload to update customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).updateCustomer(customerId, updateCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventIngestionApi - axios parameter creator
 * @export
 */
export const EventIngestionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API to ingest your application event to Togai for billing and usage analytics. To know the limits on the ingestion api, check our docs - https://togai.com/docs/limits.
         * @summary Ingest events to Togai
         * @param {IngestEventRequest} ingestEventRequest Request body to ingest events to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingest: async (ingestEventRequest: IngestEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ingestEventRequest' is not null or undefined
            assertParamExists('ingest', 'ingestEventRequest', ingestEventRequest)
            const localVarPath = `/ingest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingestEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API to ingest your application event in batch to Togai for billing and usage analytics. To know the limits on the ingestion api, check our docs - https://togai.com/docs/limits.
         * @summary Ingest events to Togai in batch
         * @param {IngestBatchEventRequest} ingestBatchEventRequest Request body to ingest events in batch to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestBatch: async (ingestBatchEventRequest: IngestBatchEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ingestBatchEventRequest' is not null or undefined
            assertParamExists('ingestBatch', 'ingestBatchEventRequest', ingestBatchEventRequest)
            const localVarPath = `/ingestBatch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingestBatchEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventIngestionApi - functional programming interface
 * @export
 */
export const EventIngestionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventIngestionApiAxiosParamCreator(configuration)
    return {
        /**
         * API to ingest your application event to Togai for billing and usage analytics. To know the limits on the ingestion api, check our docs - https://togai.com/docs/limits.
         * @summary Ingest events to Togai
         * @param {IngestEventRequest} ingestEventRequest Request body to ingest events to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingest(ingestEventRequest: IngestEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingest(ingestEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API to ingest your application event in batch to Togai for billing and usage analytics. To know the limits on the ingestion api, check our docs - https://togai.com/docs/limits.
         * @summary Ingest events to Togai in batch
         * @param {IngestBatchEventRequest} ingestBatchEventRequest Request body to ingest events in batch to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingestBatch(ingestBatchEventRequest: IngestBatchEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngestBatchEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingestBatch(ingestBatchEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventIngestionApi - factory interface
 * @export
 */
export const EventIngestionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventIngestionApiFp(configuration)
    return {
        /**
         * API to ingest your application event to Togai for billing and usage analytics. To know the limits on the ingestion api, check our docs - https://togai.com/docs/limits.
         * @summary Ingest events to Togai
         * @param {IngestEventRequest} ingestEventRequest Request body to ingest events to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingest(ingestEventRequest: IngestEventRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ingest(ingestEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API to ingest your application event in batch to Togai for billing and usage analytics. To know the limits on the ingestion api, check our docs - https://togai.com/docs/limits.
         * @summary Ingest events to Togai in batch
         * @param {IngestBatchEventRequest} ingestBatchEventRequest Request body to ingest events in batch to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestBatch(ingestBatchEventRequest: IngestBatchEventRequest, options?: any): AxiosPromise<IngestBatchEventResponse> {
            return localVarFp.ingestBatch(ingestBatchEventRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventIngestionApi - object-oriented interface
 * @export
 * @class EventIngestionApi
 * @extends {BaseAPI}
 */
export class EventIngestionApi extends BaseAPI {
    /**
     * API to ingest your application event to Togai for billing and usage analytics. To know the limits on the ingestion api, check our docs - https://togai.com/docs/limits.
     * @summary Ingest events to Togai
     * @param {IngestEventRequest} ingestEventRequest Request body to ingest events to Togai usage and billing management service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventIngestionApi
     */
    public ingest(ingestEventRequest: IngestEventRequest, options?: AxiosRequestConfig) {
        return EventIngestionApiFp(this.configuration).ingest(ingestEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API to ingest your application event in batch to Togai for billing and usage analytics. To know the limits on the ingestion api, check our docs - https://togai.com/docs/limits.
     * @summary Ingest events to Togai in batch
     * @param {IngestBatchEventRequest} ingestBatchEventRequest Request body to ingest events in batch to Togai usage and billing management service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventIngestionApi
     */
    public ingestBatch(ingestBatchEventRequest: IngestBatchEventRequest, options?: AxiosRequestConfig) {
        return EventIngestionApiFp(this.configuration).ingestBatch(ingestBatchEventRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventManagementApi - axios parameter creator
 * @export
 */
export const EventManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API let’s you to fetch a list of events with multiple query parameters
         * @summary Get a list of usage events with multiple query options
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter the events by processed/unprocessed status.
         * @param {string} [accountId] Filter option to filter the events based on account id.
         * @param {string} [schemaName] Filter option to filter the events based on schema name.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (nextToken?: string, status?: string, accountId?: string, schemaName?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (schemaName !== undefined) {
                localVarQueryParameter['schema_name'] = schemaName;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch details of a particular event using the event ID.
         * @summary Get an usage event using event id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleEvent: async (eventId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getSingleEvent', 'eventId', eventId)
            const localVarPath = `/events/{event_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventManagementApi - functional programming interface
 * @export
 */
export const EventManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * This API let’s you to fetch a list of events with multiple query parameters
         * @summary Get a list of usage events with multiple query options
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter the events by processed/unprocessed status.
         * @param {string} [accountId] Filter option to filter the events based on account id.
         * @param {string} [schemaName] Filter option to filter the events based on schema name.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(nextToken?: string, status?: string, accountId?: string, schemaName?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(nextToken, status, accountId, schemaName, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch details of a particular event using the event ID.
         * @summary Get an usage event using event id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleEvent(eventId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleEvent(eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventManagementApi - factory interface
 * @export
 */
export const EventManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventManagementApiFp(configuration)
    return {
        /**
         * This API let’s you to fetch a list of events with multiple query parameters
         * @summary Get a list of usage events with multiple query options
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter the events by processed/unprocessed status.
         * @param {string} [accountId] Filter option to filter the events based on account id.
         * @param {string} [schemaName] Filter option to filter the events based on schema name.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(nextToken?: string, status?: string, accountId?: string, schemaName?: string, pageSize?: number, options?: any): AxiosPromise<GetEventsResponse> {
            return localVarFp.getEvents(nextToken, status, accountId, schemaName, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch details of a particular event using the event ID.
         * @summary Get an usage event using event id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleEvent(eventId: string, options?: any): AxiosPromise<GetEventResponse> {
            return localVarFp.getSingleEvent(eventId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventManagementApi - object-oriented interface
 * @export
 * @class EventManagementApi
 * @extends {BaseAPI}
 */
export class EventManagementApi extends BaseAPI {
    /**
     * This API let’s you to fetch a list of events with multiple query parameters
     * @summary Get a list of usage events with multiple query options
     * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
     * @param {string} [status] Filter option to filter the events by processed/unprocessed status.
     * @param {string} [accountId] Filter option to filter the events based on account id.
     * @param {string} [schemaName] Filter option to filter the events based on schema name.
     * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventManagementApi
     */
    public getEvents(nextToken?: string, status?: string, accountId?: string, schemaName?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return EventManagementApiFp(this.configuration).getEvents(nextToken, status, accountId, schemaName, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch details of a particular event using the event ID.
     * @summary Get an usage event using event id
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventManagementApi
     */
    public getSingleEvent(eventId: string, options?: AxiosRequestConfig) {
        return EventManagementApiFp(this.configuration).getSingleEvent(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventSchemasApi - axios parameter creator
 * @export
 */
export const EventSchemasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate an event schema
         * @summary Activate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateEventSchema: async (eventSchemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('activateEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}/activate`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an event schema with attributes and dimensions to process events.
         * @summary Create an event schema
         * @param {CreateEventSchemaRequest} createEventSchemaRequest Payload to create event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSchema: async (createEventSchemaRequest: CreateEventSchemaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEventSchemaRequest' is not null or undefined
            assertParamExists('createEventSchema', 'createEventSchemaRequest', createEventSchemaRequest)
            const localVarPath = `/event_schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventSchemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can deactivate an event schema using this API. In case you have an activate usage meter associated with the event schema, you will need to deactivate it first and then try deactivating the event schema. 
         * @summary Deactivate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateEventSchema: async (eventSchemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('deactivateEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}/deactivate`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To delete(archive) an event schema, you’re required to archive associated active usage meters if any.
         * @summary Delete an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventSchema: async (eventSchemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('deleteEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an event schema and add new attributes and dimensions  Once an event schema is activated, you cannot update or delete existing attributes and dimensions however you can add new attributes and dimensions and update event schema description.     operationId: updateEventSchema 
         * @summary Update an event schema
         * @param {string} eventSchemaName 
         * @param {UpdateEventSchemaRequest} updateEventSchemaRequest Payload to update event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventSchemaEventSchemaNamePatch: async (eventSchemaName: string, updateEventSchemaRequest: UpdateEventSchemaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('eventSchemaEventSchemaNamePatch', 'eventSchemaName', eventSchemaName)
            // verify required parameter 'updateEventSchemaRequest' is not null or undefined
            assertParamExists('eventSchemaEventSchemaNamePatch', 'updateEventSchemaRequest', updateEventSchemaRequest)
            const localVarPath = `/event_schema/{event_schema_name}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventSchemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an event schema
         * @summary Get an event schema
         * @param {string} eventSchemaName 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSchema: async (eventSchemaName: string, version?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('getEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all the versions of an event schema
         * @summary List all event schema versions
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventSchemaVersions: async (eventSchemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('listEventSchemaVersions', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}/versions`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of event schema with pagination and sort.
         * @summary List event schemas
         * @param {string} [statuses] Filter by provided statuses
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {'ASC' | 'DESC'} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventSchemas: async (statuses?: string, nextToken?: string, pageSize?: number, sortOrder?: 'ASC' | 'DESC', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event_schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (statuses !== undefined) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventSchemasApi - functional programming interface
 * @export
 */
export const EventSchemasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventSchemasApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate an event schema
         * @summary Activate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateEventSchema(eventSchemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateEventSchema(eventSchemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an event schema with attributes and dimensions to process events.
         * @summary Create an event schema
         * @param {CreateEventSchemaRequest} createEventSchemaRequest Payload to create event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventSchema(createEventSchemaRequest: CreateEventSchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventSchema(createEventSchemaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can deactivate an event schema using this API. In case you have an activate usage meter associated with the event schema, you will need to deactivate it first and then try deactivating the event schema. 
         * @summary Deactivate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateEventSchema(eventSchemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateEventSchema(eventSchemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To delete(archive) an event schema, you’re required to archive associated active usage meters if any.
         * @summary Delete an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventSchema(eventSchemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventSchema(eventSchemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an event schema and add new attributes and dimensions  Once an event schema is activated, you cannot update or delete existing attributes and dimensions however you can add new attributes and dimensions and update event schema description.     operationId: updateEventSchema 
         * @summary Update an event schema
         * @param {string} eventSchemaName 
         * @param {UpdateEventSchemaRequest} updateEventSchemaRequest Payload to update event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventSchemaEventSchemaNamePatch(eventSchemaName: string, updateEventSchemaRequest: UpdateEventSchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventSchemaEventSchemaNamePatch(eventSchemaName, updateEventSchemaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an event schema
         * @summary Get an event schema
         * @param {string} eventSchemaName 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventSchema(eventSchemaName: string, version?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventSchema(eventSchemaName, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all the versions of an event schema
         * @summary List all event schema versions
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventSchemaVersions(eventSchemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchemaVersionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventSchemaVersions(eventSchemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of event schema with pagination and sort.
         * @summary List event schemas
         * @param {string} [statuses] Filter by provided statuses
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {'ASC' | 'DESC'} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventSchemas(statuses?: string, nextToken?: string, pageSize?: number, sortOrder?: 'ASC' | 'DESC', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchemaListPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventSchemas(statuses, nextToken, pageSize, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventSchemasApi - factory interface
 * @export
 */
export const EventSchemasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventSchemasApiFp(configuration)
    return {
        /**
         * Activate an event schema
         * @summary Activate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateEventSchema(eventSchemaName: string, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.activateEventSchema(eventSchemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an event schema with attributes and dimensions to process events.
         * @summary Create an event schema
         * @param {CreateEventSchemaRequest} createEventSchemaRequest Payload to create event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSchema(createEventSchemaRequest: CreateEventSchemaRequest, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.createEventSchema(createEventSchemaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * You can deactivate an event schema using this API. In case you have an activate usage meter associated with the event schema, you will need to deactivate it first and then try deactivating the event schema. 
         * @summary Deactivate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateEventSchema(eventSchemaName: string, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.deactivateEventSchema(eventSchemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * To delete(archive) an event schema, you’re required to archive associated active usage meters if any.
         * @summary Delete an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventSchema(eventSchemaName: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteEventSchema(eventSchemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an event schema and add new attributes and dimensions  Once an event schema is activated, you cannot update or delete existing attributes and dimensions however you can add new attributes and dimensions and update event schema description.     operationId: updateEventSchema 
         * @summary Update an event schema
         * @param {string} eventSchemaName 
         * @param {UpdateEventSchemaRequest} updateEventSchemaRequest Payload to update event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventSchemaEventSchemaNamePatch(eventSchemaName: string, updateEventSchemaRequest: UpdateEventSchemaRequest, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.eventSchemaEventSchemaNamePatch(eventSchemaName, updateEventSchemaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an event schema
         * @summary Get an event schema
         * @param {string} eventSchemaName 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSchema(eventSchemaName: string, version?: number, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.getEventSchema(eventSchemaName, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all the versions of an event schema
         * @summary List all event schema versions
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventSchemaVersions(eventSchemaName: string, options?: any): AxiosPromise<EventSchemaVersionsResponse> {
            return localVarFp.listEventSchemaVersions(eventSchemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of event schema with pagination and sort.
         * @summary List event schemas
         * @param {string} [statuses] Filter by provided statuses
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {'ASC' | 'DESC'} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventSchemas(statuses?: string, nextToken?: string, pageSize?: number, sortOrder?: 'ASC' | 'DESC', options?: any): AxiosPromise<EventSchemaListPaginatedResponse> {
            return localVarFp.listEventSchemas(statuses, nextToken, pageSize, sortOrder, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventSchemasApi - object-oriented interface
 * @export
 * @class EventSchemasApi
 * @extends {BaseAPI}
 */
export class EventSchemasApi extends BaseAPI {
    /**
     * Activate an event schema
     * @summary Activate an event schema
     * @param {string} eventSchemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public activateEventSchema(eventSchemaName: string, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).activateEventSchema(eventSchemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an event schema with attributes and dimensions to process events.
     * @summary Create an event schema
     * @param {CreateEventSchemaRequest} createEventSchemaRequest Payload to create event schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public createEventSchema(createEventSchemaRequest: CreateEventSchemaRequest, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).createEventSchema(createEventSchemaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can deactivate an event schema using this API. In case you have an activate usage meter associated with the event schema, you will need to deactivate it first and then try deactivating the event schema. 
     * @summary Deactivate an event schema
     * @param {string} eventSchemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public deactivateEventSchema(eventSchemaName: string, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).deactivateEventSchema(eventSchemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To delete(archive) an event schema, you’re required to archive associated active usage meters if any.
     * @summary Delete an event schema
     * @param {string} eventSchemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public deleteEventSchema(eventSchemaName: string, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).deleteEventSchema(eventSchemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an event schema and add new attributes and dimensions  Once an event schema is activated, you cannot update or delete existing attributes and dimensions however you can add new attributes and dimensions and update event schema description.     operationId: updateEventSchema 
     * @summary Update an event schema
     * @param {string} eventSchemaName 
     * @param {UpdateEventSchemaRequest} updateEventSchemaRequest Payload to update event schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public eventSchemaEventSchemaNamePatch(eventSchemaName: string, updateEventSchemaRequest: UpdateEventSchemaRequest, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).eventSchemaEventSchemaNamePatch(eventSchemaName, updateEventSchemaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an event schema
     * @summary Get an event schema
     * @param {string} eventSchemaName 
     * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public getEventSchema(eventSchemaName: string, version?: number, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).getEventSchema(eventSchemaName, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all the versions of an event schema
     * @summary List all event schema versions
     * @param {string} eventSchemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public listEventSchemaVersions(eventSchemaName: string, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).listEventSchemaVersions(eventSchemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of event schema with pagination and sort.
     * @summary List event schemas
     * @param {string} [statuses] Filter by provided statuses
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {'ASC' | 'DESC'} [sortOrder] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public listEventSchemas(statuses?: string, nextToken?: string, pageSize?: number, sortOrder?: 'ASC' | 'DESC', options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).listEventSchemas(statuses, nextToken, pageSize, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Togai Metrics API allows you to fetch different metrics from Events value, Usage value, revenue metrics with multiple queryable options you may require for your business use case.  Make a POST request to the /metrics resource to get the metrics.  A single request can query up to five metrics.  Single response dataset can contain a maximum of 100 data points. 
         * @summary Get Togai Metrics
         * @param {GetMetricsRequest} [getMetricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics: async (getMetricsRequest?: GetMetricsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getMetricsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * Togai Metrics API allows you to fetch different metrics from Events value, Usage value, revenue metrics with multiple queryable options you may require for your business use case.  Make a POST request to the /metrics resource to get the metrics.  A single request can query up to five metrics.  Single response dataset can contain a maximum of 100 data points. 
         * @summary Get Togai Metrics
         * @param {GetMetricsRequest} [getMetricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetrics(getMetricsRequest?: GetMetricsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetrics(getMetricsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * Togai Metrics API allows you to fetch different metrics from Events value, Usage value, revenue metrics with multiple queryable options you may require for your business use case.  Make a POST request to the /metrics resource to get the metrics.  A single request can query up to five metrics.  Single response dataset can contain a maximum of 100 data points. 
         * @summary Get Togai Metrics
         * @param {GetMetricsRequest} [getMetricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(getMetricsRequest?: GetMetricsRequest, options?: any): AxiosPromise<GetMetricsResponse> {
            return localVarFp.getMetrics(getMetricsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * Togai Metrics API allows you to fetch different metrics from Events value, Usage value, revenue metrics with multiple queryable options you may require for your business use case.  Make a POST request to the /metrics resource to get the metrics.  A single request can query up to five metrics.  Single response dataset can contain a maximum of 100 data points. 
     * @summary Get Togai Metrics
     * @param {GetMetricsRequest} [getMetricsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetrics(getMetricsRequest?: GetMetricsRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getMetrics(getMetricsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PricePlansApi - axios parameter creator
 * @export
 */
export const PricePlansApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate a price plan details using price plan id
         * @summary Activate a price plan
         * @param {string} pricePlanId 
         * @param {ActivatePricePlanRequest} activatePricePlanRequest Payload to activate price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePricePlan: async (pricePlanId: string, activatePricePlanRequest: ActivatePricePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('activatePricePlan', 'pricePlanId', pricePlanId)
            // verify required parameter 'activatePricePlanRequest' is not null or undefined
            assertParamExists('activatePricePlan', 'activatePricePlanRequest', activatePricePlanRequest)
            const localVarPath = `/price_plans/{price_plan_id}/activate`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activatePricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add currencies to a price plan
         * @summary Add currencies to a price plan
         * @param {string} pricePlanId 
         * @param {AddCurrencyToPricePlanRequest} addCurrencyToPricePlanRequest Payload to add currency to price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCurrencyToPricePlan: async (pricePlanId: string, addCurrencyToPricePlanRequest: AddCurrencyToPricePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('addCurrencyToPricePlan', 'pricePlanId', pricePlanId)
            // verify required parameter 'addCurrencyToPricePlanRequest' is not null or undefined
            assertParamExists('addCurrencyToPricePlan', 'addCurrencyToPricePlanRequest', addCurrencyToPricePlanRequest)
            const localVarPath = `/price_plans/{price_plan_id}/currencies`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addCurrencyToPricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a price plan and associate with customers to it  A price plan is a collection of pre-set conditions with prices that convert usage metrics into billable value. Price Plans and the roll up of items comprising the pricing plans are used to assign a customer to get the final bill value. Learn more about [Price plans](https://docs.togai.com/docs/priceplan) from our Guides 
         * @summary Create a price plan
         * @param {CreatePricePlanRequest} createPricePlanRequest Payload to create price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPricePlan: async (createPricePlanRequest: CreatePricePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPricePlanRequest' is not null or undefined
            assertParamExists('createPricePlan', 'createPricePlanRequest', createPricePlanRequest)
            const localVarPath = `/price_plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a price plan details using price plan id
         * @summary Get a price plan
         * @param {string} pricePlanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricePlan: async (pricePlanId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('getPricePlan', 'pricePlanId', pricePlanId)
            const localVarPath = `/price_plans/{price_plan_id}`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of price plans
         * @summary List price plans
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricePlans: async (nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/price_plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a draft currency from a price plan
         * @summary Remove a draft currency from a price plan
         * @param {string} pricePlanId 
         * @param {string} currencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCurrencyFromPricePlan: async (pricePlanId: string, currencyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('removeCurrencyFromPricePlan', 'pricePlanId', pricePlanId)
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('removeCurrencyFromPricePlan', 'currencyId', currencyId)
            const localVarPath = `/price_plans/{price_plan_id}/currencies/{currency_id}`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)))
                .replace(`{${"currency_id"}}`, encodeURIComponent(String(currencyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a draft state price plan  Only DRAFT state Price Plans are allowed to Update. Learn more about [Price plans](https://docs.togai.com/docs/priceplan) from our Guides 
         * @summary Update a price plan
         * @param {string} pricePlanId 
         * @param {UpdatePricePlanRequest} updatePricePlanRequest Payload to update price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricePlan: async (pricePlanId: string, updatePricePlanRequest: UpdatePricePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('updatePricePlan', 'pricePlanId', pricePlanId)
            // verify required parameter 'updatePricePlanRequest' is not null or undefined
            assertParamExists('updatePricePlan', 'updatePricePlanRequest', updatePricePlanRequest)
            const localVarPath = `/price_plans/{price_plan_id}`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PricePlansApi - functional programming interface
 * @export
 */
export const PricePlansApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PricePlansApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate a price plan details using price plan id
         * @summary Activate a price plan
         * @param {string} pricePlanId 
         * @param {ActivatePricePlanRequest} activatePricePlanRequest Payload to activate price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activatePricePlan(pricePlanId: string, activatePricePlanRequest: ActivatePricePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activatePricePlan(pricePlanId, activatePricePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add currencies to a price plan
         * @summary Add currencies to a price plan
         * @param {string} pricePlanId 
         * @param {AddCurrencyToPricePlanRequest} addCurrencyToPricePlanRequest Payload to add currency to price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCurrencyToPricePlan(pricePlanId: string, addCurrencyToPricePlanRequest: AddCurrencyToPricePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCurrencyToPricePlan(pricePlanId, addCurrencyToPricePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a price plan and associate with customers to it  A price plan is a collection of pre-set conditions with prices that convert usage metrics into billable value. Price Plans and the roll up of items comprising the pricing plans are used to assign a customer to get the final bill value. Learn more about [Price plans](https://docs.togai.com/docs/priceplan) from our Guides 
         * @summary Create a price plan
         * @param {CreatePricePlanRequest} createPricePlanRequest Payload to create price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPricePlan(createPricePlanRequest: CreatePricePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPricePlan(createPricePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a price plan details using price plan id
         * @summary Get a price plan
         * @param {string} pricePlanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricePlan(pricePlanId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricePlan(pricePlanId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of price plans
         * @summary List price plans
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricePlans(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlanPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricePlans(nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a draft currency from a price plan
         * @summary Remove a draft currency from a price plan
         * @param {string} pricePlanId 
         * @param {string} currencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeCurrencyFromPricePlan(pricePlanId: string, currencyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeCurrencyFromPricePlan(pricePlanId, currencyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a draft state price plan  Only DRAFT state Price Plans are allowed to Update. Learn more about [Price plans](https://docs.togai.com/docs/priceplan) from our Guides 
         * @summary Update a price plan
         * @param {string} pricePlanId 
         * @param {UpdatePricePlanRequest} updatePricePlanRequest Payload to update price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePricePlan(pricePlanId: string, updatePricePlanRequest: UpdatePricePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePricePlan(pricePlanId, updatePricePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PricePlansApi - factory interface
 * @export
 */
export const PricePlansApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PricePlansApiFp(configuration)
    return {
        /**
         * Activate a price plan details using price plan id
         * @summary Activate a price plan
         * @param {string} pricePlanId 
         * @param {ActivatePricePlanRequest} activatePricePlanRequest Payload to activate price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePricePlan(pricePlanId: string, activatePricePlanRequest: ActivatePricePlanRequest, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.activatePricePlan(pricePlanId, activatePricePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add currencies to a price plan
         * @summary Add currencies to a price plan
         * @param {string} pricePlanId 
         * @param {AddCurrencyToPricePlanRequest} addCurrencyToPricePlanRequest Payload to add currency to price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCurrencyToPricePlan(pricePlanId: string, addCurrencyToPricePlanRequest: AddCurrencyToPricePlanRequest, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.addCurrencyToPricePlan(pricePlanId, addCurrencyToPricePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a price plan and associate with customers to it  A price plan is a collection of pre-set conditions with prices that convert usage metrics into billable value. Price Plans and the roll up of items comprising the pricing plans are used to assign a customer to get the final bill value. Learn more about [Price plans](https://docs.togai.com/docs/priceplan) from our Guides 
         * @summary Create a price plan
         * @param {CreatePricePlanRequest} createPricePlanRequest Payload to create price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPricePlan(createPricePlanRequest: CreatePricePlanRequest, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.createPricePlan(createPricePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a price plan details using price plan id
         * @summary Get a price plan
         * @param {string} pricePlanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricePlan(pricePlanId: string, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.getPricePlan(pricePlanId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of price plans
         * @summary List price plans
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricePlans(nextToken?: string, pageSize?: number, options?: any): AxiosPromise<PricePlanPaginatedResponse> {
            return localVarFp.getPricePlans(nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a draft currency from a price plan
         * @summary Remove a draft currency from a price plan
         * @param {string} pricePlanId 
         * @param {string} currencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCurrencyFromPricePlan(pricePlanId: string, currencyId: string, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.removeCurrencyFromPricePlan(pricePlanId, currencyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a draft state price plan  Only DRAFT state Price Plans are allowed to Update. Learn more about [Price plans](https://docs.togai.com/docs/priceplan) from our Guides 
         * @summary Update a price plan
         * @param {string} pricePlanId 
         * @param {UpdatePricePlanRequest} updatePricePlanRequest Payload to update price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricePlan(pricePlanId: string, updatePricePlanRequest: UpdatePricePlanRequest, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.updatePricePlan(pricePlanId, updatePricePlanRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PricePlansApi - object-oriented interface
 * @export
 * @class PricePlansApi
 * @extends {BaseAPI}
 */
export class PricePlansApi extends BaseAPI {
    /**
     * Activate a price plan details using price plan id
     * @summary Activate a price plan
     * @param {string} pricePlanId 
     * @param {ActivatePricePlanRequest} activatePricePlanRequest Payload to activate price plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public activatePricePlan(pricePlanId: string, activatePricePlanRequest: ActivatePricePlanRequest, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).activatePricePlan(pricePlanId, activatePricePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add currencies to a price plan
     * @summary Add currencies to a price plan
     * @param {string} pricePlanId 
     * @param {AddCurrencyToPricePlanRequest} addCurrencyToPricePlanRequest Payload to add currency to price plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public addCurrencyToPricePlan(pricePlanId: string, addCurrencyToPricePlanRequest: AddCurrencyToPricePlanRequest, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).addCurrencyToPricePlan(pricePlanId, addCurrencyToPricePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a price plan and associate with customers to it  A price plan is a collection of pre-set conditions with prices that convert usage metrics into billable value. Price Plans and the roll up of items comprising the pricing plans are used to assign a customer to get the final bill value. Learn more about [Price plans](https://docs.togai.com/docs/priceplan) from our Guides 
     * @summary Create a price plan
     * @param {CreatePricePlanRequest} createPricePlanRequest Payload to create price plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public createPricePlan(createPricePlanRequest: CreatePricePlanRequest, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).createPricePlan(createPricePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a price plan details using price plan id
     * @summary Get a price plan
     * @param {string} pricePlanId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public getPricePlan(pricePlanId: string, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).getPricePlan(pricePlanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of price plans
     * @summary List price plans
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public getPricePlans(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).getPricePlans(nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a draft currency from a price plan
     * @summary Remove a draft currency from a price plan
     * @param {string} pricePlanId 
     * @param {string} currencyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public removeCurrencyFromPricePlan(pricePlanId: string, currencyId: string, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).removeCurrencyFromPricePlan(pricePlanId, currencyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a draft state price plan  Only DRAFT state Price Plans are allowed to Update. Learn more about [Price plans](https://docs.togai.com/docs/priceplan) from our Guides 
     * @summary Update a price plan
     * @param {string} pricePlanId 
     * @param {UpdatePricePlanRequest} updatePricePlanRequest Payload to update price plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public updatePricePlan(pricePlanId: string, updatePricePlanRequest: UpdatePricePlanRequest, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).updatePricePlan(pricePlanId, updatePricePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get an organization setting
         * @summary Get an organization setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSetting: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization_settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a setting
         * @summary Get a setting
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {string} settingName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetting: async (entityType: string, entityId: string, settingName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityType' is not null or undefined
            assertParamExists('getSetting', 'entityType', entityType)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('getSetting', 'entityId', entityId)
            // verify required parameter 'settingName' is not null or undefined
            assertParamExists('getSetting', 'settingName', settingName)
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (entityType !== undefined) {
                localVarQueryParameter['entity_type'] = entityType;
            }

            if (entityId !== undefined) {
                localVarQueryParameter['entity_id'] = entityId;
            }

            if (settingName !== undefined) {
                localVarQueryParameter['setting_name'] = settingName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an organization setting
         * @summary Update an organization setting
         * @param {UpdateOrganizationSettingRequest} updateOrganizationSettingRequest Payload to update organization setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationSetting: async (updateOrganizationSettingRequest: UpdateOrganizationSettingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateOrganizationSettingRequest' is not null or undefined
            assertParamExists('updateOrganizationSetting', 'updateOrganizationSettingRequest', updateOrganizationSettingRequest)
            const localVarPath = `/organization_settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrganizationSettingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or Update a setting
         * @summary Create or Update a setting
         * @param {Setting} setting Payload to insert or update setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertSetting: async (setting: Setting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setting' is not null or undefined
            assertParamExists('upsertSetting', 'setting', setting)
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get an organization setting
         * @summary Get an organization setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationSetting(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationSetting(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a setting
         * @summary Get a setting
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {string} settingName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSetting(entityType: string, entityId: string, settingName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSetting(entityType, entityId, settingName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an organization setting
         * @summary Update an organization setting
         * @param {UpdateOrganizationSettingRequest} updateOrganizationSettingRequest Payload to update organization setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationSetting(updateOrganizationSettingRequest: UpdateOrganizationSettingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationSetting(updateOrganizationSettingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create or Update a setting
         * @summary Create or Update a setting
         * @param {Setting} setting Payload to insert or update setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertSetting(setting: Setting, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upsertSetting(setting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         * Get an organization setting
         * @summary Get an organization setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSetting(options?: any): AxiosPromise<OrganizationSetting> {
            return localVarFp.getOrganizationSetting(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a setting
         * @summary Get a setting
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {string} settingName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetting(entityType: string, entityId: string, settingName: string, options?: any): AxiosPromise<Setting> {
            return localVarFp.getSetting(entityType, entityId, settingName, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an organization setting
         * @summary Update an organization setting
         * @param {UpdateOrganizationSettingRequest} updateOrganizationSettingRequest Payload to update organization setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationSetting(updateOrganizationSettingRequest: UpdateOrganizationSettingRequest, options?: any): AxiosPromise<OrganizationSetting> {
            return localVarFp.updateOrganizationSetting(updateOrganizationSettingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or Update a setting
         * @summary Create or Update a setting
         * @param {Setting} setting Payload to insert or update setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertSetting(setting: Setting, options?: any): AxiosPromise<Setting> {
            return localVarFp.upsertSetting(setting, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * Get an organization setting
     * @summary Get an organization setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getOrganizationSetting(options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).getOrganizationSetting(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a setting
     * @summary Get a setting
     * @param {string} entityType 
     * @param {string} entityId 
     * @param {string} settingName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getSetting(entityType: string, entityId: string, settingName: string, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).getSetting(entityType, entityId, settingName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an organization setting
     * @summary Update an organization setting
     * @param {UpdateOrganizationSettingRequest} updateOrganizationSettingRequest Payload to update organization setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public updateOrganizationSetting(updateOrganizationSettingRequest: UpdateOrganizationSettingRequest, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).updateOrganizationSetting(updateOrganizationSettingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or Update a setting
     * @summary Create or Update a setting
     * @param {Setting} setting Payload to insert or update setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public upsertSetting(setting: Setting, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).upsertSetting(setting, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsageMetersApi - axios parameter creator
 * @export
 */
export const UsageMetersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate usage meter
         * @summary Activate usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUsageMeter: async (eventSchemaName: string, usageMeterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('activateUsageMeter', 'eventSchemaName', eventSchemaName)
            // verify required parameter 'usageMeterId' is not null or undefined
            assertParamExists('activateUsageMeter', 'usageMeterId', usageMeterId)
            const localVarPath = `/event_schema/{event_schema_name}/usage_meters/{usage_meter_id}/activate`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)))
                .replace(`{${"usage_meter_id"}}`, encodeURIComponent(String(usageMeterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an usage meter and associate with an event schema
         * @summary Create an usage meter
         * @param {string} eventSchemaName 
         * @param {CreateUsageMeterRequest} createUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsageMeter: async (eventSchemaName: string, createUsageMeterRequest: CreateUsageMeterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('createUsageMeter', 'eventSchemaName', eventSchemaName)
            // verify required parameter 'createUsageMeterRequest' is not null or undefined
            assertParamExists('createUsageMeter', 'createUsageMeterRequest', createUsageMeterRequest)
            const localVarPath = `/event_schema/{event_schema_name}/usage_meters`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUsageMeterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make an existing active usage meter to be inactive  Only active Usage Meters are allowed to deactivate. Active Usage Meters with active Pricing Plan attached can also be deactivated. 
         * @summary Deactivate usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUsageMeter: async (eventSchemaName: string, usageMeterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('deactivateUsageMeter', 'eventSchemaName', eventSchemaName)
            // verify required parameter 'usageMeterId' is not null or undefined
            assertParamExists('deactivateUsageMeter', 'usageMeterId', usageMeterId)
            const localVarPath = `/event_schema/{event_schema_name}/usage_meters/{usage_meter_id}/deactivate`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)))
                .replace(`{${"usage_meter_id"}}`, encodeURIComponent(String(usageMeterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an usage meter using event schema name and usage meter id.
         * @summary Get usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMeter: async (eventSchemaName: string, usageMeterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('getUsageMeter', 'eventSchemaName', eventSchemaName)
            // verify required parameter 'usageMeterId' is not null or undefined
            assertParamExists('getUsageMeter', 'usageMeterId', usageMeterId)
            const localVarPath = `/event_schema/{event_schema_name}/usage_meters/{usage_meter_id}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)))
                .replace(`{${"usage_meter_id"}}`, encodeURIComponent(String(usageMeterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of usage meters associated with an event schema
         * @summary List usage meters for event schema
         * @param {string} eventSchemaName 
         * @param {'ACTIVE' | 'INACTIVE'} [statuses] Filter usage meter by it’s current active/inactive state to aggregate across state level usage meters. Aggregation param is mandatory if you’re passing value in this. 
         * @param {'SUM' | 'COUNT'} [aggregations] This parameter will aggregate across usage meter level using the processed usage meter value. Read more about [usage meter](https://docs.togai.com/docs/usagemeter). Statuses param is mandatory if you’re passing value in this. 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMetersForEventSchema: async (eventSchemaName: string, statuses?: 'ACTIVE' | 'INACTIVE', aggregations?: 'SUM' | 'COUNT', nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('getUsageMetersForEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}/usage_meters`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (statuses !== undefined) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (aggregations !== undefined) {
                localVarQueryParameter['aggregations'] = aggregations;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updating an usage meter is supported only for usage meters in the DRAFT state currently. In case you like to update an usage meter, we suggest you create a new usage meter and associate it with accounts. 
         * @summary Update an usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {UpdateUsageMeterRequest} updateUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsageMeter: async (eventSchemaName: string, usageMeterId: string, updateUsageMeterRequest: UpdateUsageMeterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('updateUsageMeter', 'eventSchemaName', eventSchemaName)
            // verify required parameter 'usageMeterId' is not null or undefined
            assertParamExists('updateUsageMeter', 'usageMeterId', usageMeterId)
            // verify required parameter 'updateUsageMeterRequest' is not null or undefined
            assertParamExists('updateUsageMeter', 'updateUsageMeterRequest', updateUsageMeterRequest)
            const localVarPath = `/event_schema/{event_schema_name}/usage_meters/{usage_meter_id}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)))
                .replace(`{${"usage_meter_id"}}`, encodeURIComponent(String(usageMeterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUsageMeterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsageMetersApi - functional programming interface
 * @export
 */
export const UsageMetersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsageMetersApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate usage meter
         * @summary Activate usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateUsageMeter(eventSchemaName: string, usageMeterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateUsageMeter(eventSchemaName, usageMeterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an usage meter and associate with an event schema
         * @summary Create an usage meter
         * @param {string} eventSchemaName 
         * @param {CreateUsageMeterRequest} createUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUsageMeter(eventSchemaName: string, createUsageMeterRequest: CreateUsageMeterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUsageMeter(eventSchemaName, createUsageMeterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Make an existing active usage meter to be inactive  Only active Usage Meters are allowed to deactivate. Active Usage Meters with active Pricing Plan attached can also be deactivated. 
         * @summary Deactivate usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateUsageMeter(eventSchemaName: string, usageMeterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateUsageMeter(eventSchemaName, usageMeterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an usage meter using event schema name and usage meter id.
         * @summary Get usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsageMeter(eventSchemaName: string, usageMeterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageMeter(eventSchemaName, usageMeterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of usage meters associated with an event schema
         * @summary List usage meters for event schema
         * @param {string} eventSchemaName 
         * @param {'ACTIVE' | 'INACTIVE'} [statuses] Filter usage meter by it’s current active/inactive state to aggregate across state level usage meters. Aggregation param is mandatory if you’re passing value in this. 
         * @param {'SUM' | 'COUNT'} [aggregations] This parameter will aggregate across usage meter level using the processed usage meter value. Read more about [usage meter](https://docs.togai.com/docs/usagemeter). Statuses param is mandatory if you’re passing value in this. 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsageMetersForEventSchema(eventSchemaName: string, statuses?: 'ACTIVE' | 'INACTIVE', aggregations?: 'SUM' | 'COUNT', nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeterPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageMetersForEventSchema(eventSchemaName, statuses, aggregations, nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updating an usage meter is supported only for usage meters in the DRAFT state currently. In case you like to update an usage meter, we suggest you create a new usage meter and associate it with accounts. 
         * @summary Update an usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {UpdateUsageMeterRequest} updateUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUsageMeter(eventSchemaName: string, usageMeterId: string, updateUsageMeterRequest: UpdateUsageMeterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUsageMeter(eventSchemaName, usageMeterId, updateUsageMeterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsageMetersApi - factory interface
 * @export
 */
export const UsageMetersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsageMetersApiFp(configuration)
    return {
        /**
         * Activate usage meter
         * @summary Activate usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUsageMeter(eventSchemaName: string, usageMeterId: string, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.activateUsageMeter(eventSchemaName, usageMeterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an usage meter and associate with an event schema
         * @summary Create an usage meter
         * @param {string} eventSchemaName 
         * @param {CreateUsageMeterRequest} createUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsageMeter(eventSchemaName: string, createUsageMeterRequest: CreateUsageMeterRequest, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.createUsageMeter(eventSchemaName, createUsageMeterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Make an existing active usage meter to be inactive  Only active Usage Meters are allowed to deactivate. Active Usage Meters with active Pricing Plan attached can also be deactivated. 
         * @summary Deactivate usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUsageMeter(eventSchemaName: string, usageMeterId: string, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.deactivateUsageMeter(eventSchemaName, usageMeterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an usage meter using event schema name and usage meter id.
         * @summary Get usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMeter(eventSchemaName: string, usageMeterId: string, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.getUsageMeter(eventSchemaName, usageMeterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of usage meters associated with an event schema
         * @summary List usage meters for event schema
         * @param {string} eventSchemaName 
         * @param {'ACTIVE' | 'INACTIVE'} [statuses] Filter usage meter by it’s current active/inactive state to aggregate across state level usage meters. Aggregation param is mandatory if you’re passing value in this. 
         * @param {'SUM' | 'COUNT'} [aggregations] This parameter will aggregate across usage meter level using the processed usage meter value. Read more about [usage meter](https://docs.togai.com/docs/usagemeter). Statuses param is mandatory if you’re passing value in this. 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMetersForEventSchema(eventSchemaName: string, statuses?: 'ACTIVE' | 'INACTIVE', aggregations?: 'SUM' | 'COUNT', nextToken?: string, pageSize?: number, options?: any): AxiosPromise<UsageMeterPaginatedResponse> {
            return localVarFp.getUsageMetersForEventSchema(eventSchemaName, statuses, aggregations, nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Updating an usage meter is supported only for usage meters in the DRAFT state currently. In case you like to update an usage meter, we suggest you create a new usage meter and associate it with accounts. 
         * @summary Update an usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {UpdateUsageMeterRequest} updateUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsageMeter(eventSchemaName: string, usageMeterId: string, updateUsageMeterRequest: UpdateUsageMeterRequest, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.updateUsageMeter(eventSchemaName, usageMeterId, updateUsageMeterRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsageMetersApi - object-oriented interface
 * @export
 * @class UsageMetersApi
 * @extends {BaseAPI}
 */
export class UsageMetersApi extends BaseAPI {
    /**
     * Activate usage meter
     * @summary Activate usage meter
     * @param {string} eventSchemaName 
     * @param {string} usageMeterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public activateUsageMeter(eventSchemaName: string, usageMeterId: string, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).activateUsageMeter(eventSchemaName, usageMeterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an usage meter and associate with an event schema
     * @summary Create an usage meter
     * @param {string} eventSchemaName 
     * @param {CreateUsageMeterRequest} createUsageMeterRequest Payload to create usage meter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public createUsageMeter(eventSchemaName: string, createUsageMeterRequest: CreateUsageMeterRequest, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).createUsageMeter(eventSchemaName, createUsageMeterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Make an existing active usage meter to be inactive  Only active Usage Meters are allowed to deactivate. Active Usage Meters with active Pricing Plan attached can also be deactivated. 
     * @summary Deactivate usage meter
     * @param {string} eventSchemaName 
     * @param {string} usageMeterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public deactivateUsageMeter(eventSchemaName: string, usageMeterId: string, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).deactivateUsageMeter(eventSchemaName, usageMeterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an usage meter using event schema name and usage meter id.
     * @summary Get usage meter
     * @param {string} eventSchemaName 
     * @param {string} usageMeterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public getUsageMeter(eventSchemaName: string, usageMeterId: string, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).getUsageMeter(eventSchemaName, usageMeterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of usage meters associated with an event schema
     * @summary List usage meters for event schema
     * @param {string} eventSchemaName 
     * @param {'ACTIVE' | 'INACTIVE'} [statuses] Filter usage meter by it’s current active/inactive state to aggregate across state level usage meters. Aggregation param is mandatory if you’re passing value in this. 
     * @param {'SUM' | 'COUNT'} [aggregations] This parameter will aggregate across usage meter level using the processed usage meter value. Read more about [usage meter](https://docs.togai.com/docs/usagemeter). Statuses param is mandatory if you’re passing value in this. 
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public getUsageMetersForEventSchema(eventSchemaName: string, statuses?: 'ACTIVE' | 'INACTIVE', aggregations?: 'SUM' | 'COUNT', nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).getUsageMetersForEventSchema(eventSchemaName, statuses, aggregations, nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updating an usage meter is supported only for usage meters in the DRAFT state currently. In case you like to update an usage meter, we suggest you create a new usage meter and associate it with accounts. 
     * @summary Update an usage meter
     * @param {string} eventSchemaName 
     * @param {string} usageMeterId 
     * @param {UpdateUsageMeterRequest} updateUsageMeterRequest Payload to create usage meter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public updateUsageMeter(eventSchemaName: string, usageMeterId: string, updateUsageMeterRequest: UpdateUsageMeterRequest, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).updateUsageMeter(eventSchemaName, usageMeterId, updateUsageMeterRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


