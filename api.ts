/* tslint:disable */
/* eslint-disable */
/**
 * Togai Apis
 * APIs for Togai App
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: engg@togai.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Structure of an account
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * Identifier of the account
     * @type {string}
     * @memberof Account
     */
    'id': string;
    /**
     * Name of the customer
     * @type {string}
     * @memberof Account
     */
    'name': string;
    /**
     * list of aliases of the account
     * @type {Array<AccountAliases>}
     * @memberof Account
     */
    'aliases'?: Array<AccountAliases>;
    /**
     * Status of the account
     * @type {string}
     * @memberof Account
     */
    'status': AccountStatusEnum;
}

export const AccountStatusEnum = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type AccountStatusEnum = typeof AccountStatusEnum[keyof typeof AccountStatusEnum];

/**
 * 
 * @export
 * @interface AccountAliases
 */
export interface AccountAliases {
    /**
     * 
     * @type {string}
     * @memberof AccountAliases
     */
    'alias'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountAliases
     */
    'status'?: AccountAliasesStatusEnum;
}

export const AccountAliasesStatusEnum = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type AccountAliasesStatusEnum = typeof AccountAliasesStatusEnum[keyof typeof AccountAliasesStatusEnum];

/**
 * 
 * @export
 * @interface AccountPaginatedResponse
 */
export interface AccountPaginatedResponse {
    /**
     * 
     * @type {Array<Account>}
     * @memberof AccountPaginatedResponse
     */
    'data'?: Array<Account>;
    /**
     * 
     * @type {string}
     * @memberof AccountPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof AccountPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * Payload to add aliases from account
 * @export
 * @interface AddAccountAliasesRequest
 */
export interface AddAccountAliasesRequest {
    /**
     * List of aliases to add
     * @type {Array<string>}
     * @memberof AddAccountAliasesRequest
     */
    'aliases'?: Array<string>;
}
/**
 * Request to associate a price plan to an account
 * @export
 * @interface AssociatePricePlanRequest
 */
export interface AssociatePricePlanRequest {
    /**
     * Name of the price plan
     * @type {string}
     * @memberof AssociatePricePlanRequest
     */
    'pricePlanName': string;
    /**
     * Date of effectiveness of the association. - Expected only if the account already has a price plan associated with it. - Date can only be startDate of any billing cycle of the currently associated price plan. 
     * @type {string}
     * @memberof AssociatePricePlanRequest
     */
    'effectiveFrom'?: string;
    /**
     * 
     * @type {RateCard}
     * @memberof AssociatePricePlanRequest
     */
    'rateCardOverride'?: RateCard;
}
/**
 * 
 * @export
 * @interface AssociatePricePlanResponse
 */
export interface AssociatePricePlanResponse {
    /**
     * Identifier of the account
     * @type {string}
     * @memberof AssociatePricePlanResponse
     */
    'accountId': string;
    /**
     * Name of the customer
     * @type {string}
     * @memberof AssociatePricePlanResponse
     */
    'accountName': string;
    /**
     * 
     * @type {Array<PlanOverride>}
     * @memberof AssociatePricePlanResponse
     */
    'pricingSchedules': Array<PlanOverride>;
}
/**
 * 
 * @export
 * @interface BaseSuccessResponse
 */
export interface BaseSuccessResponse {
    /**
     * 
     * @type {boolean}
     * @memberof BaseSuccessResponse
     */
    'success': boolean;
}
/**
 * Represents a pricing strategy (rates + slabs) for bundle price plan
 * @export
 * @interface BundleStrategy
 */
export interface BundleStrategy {
    /**
     * 
     * @type {string}
     * @memberof BundleStrategy
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof BundleStrategy
     */
    'rate': number;
    /**
     * 
     * @type {number}
     * @memberof BundleStrategy
     */
    'order': number;
    /**
     * 
     * @type {{ [key: string]: BundleStrategyUsageMetersValue; }}
     * @memberof BundleStrategy
     */
    'usageMeters': { [key: string]: BundleStrategyUsageMetersValue; };
}
/**
 * 
 * @export
 * @interface BundleStrategyUsageMetersValue
 */
export interface BundleStrategyUsageMetersValue {
    /**
     * 
     * @type {number}
     * @memberof BundleStrategyUsageMetersValue
     */
    'startAfter': number;
}
/**
 * Payload to create account
 * @export
 * @interface CreateAccountRequest
 */
export interface CreateAccountRequest {
    /**
     * Identifier of the account
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'id': string;
    /**
     * Name of the customer
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'name': string;
    /**
     * list of aliases for the account. Can be used interchangeably with \'id\' for event ingestion.
     * @type {Array<string>}
     * @memberof CreateAccountRequest
     */
    'aliases'?: Array<string>;
}
/**
 * Payload to create customer
 * @export
 * @interface CreateCustomerRequest
 */
export interface CreateCustomerRequest {
    /**
     * Customer identifier
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'id': string;
    /**
     * Name of the customer
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'name': string;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'primaryEmail': string;
    /**
     * billing address of the customer
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'billingAddress': string;
    /**
     * 
     * @type {CreateAccountRequest}
     * @memberof CreateCustomerRequest
     */
    'account'?: CreateAccountRequest;
}
/**
 * 
 * @export
 * @interface CreateCustomerResponse
 */
export interface CreateCustomerResponse {
    /**
     * Identifier of customer
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'id': string;
    /**
     * Name of the customer
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'name': string;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'primaryEmail': string;
    /**
     * billing address of the customer
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'billingAddress': string;
    /**
     * 
     * @type {Account}
     * @memberof CreateCustomerResponse
     */
    'account'?: Account;
}
/**
 * Request to create event schema
 * @export
 * @interface CreateEventSchemaRequest
 */
export interface CreateEventSchemaRequest {
    /**
     * Name of the event. Must be unique for an organization.
     * @type {string}
     * @memberof CreateEventSchemaRequest
     */
    'name': string;
    /**
     * Description of the event
     * @type {string}
     * @memberof CreateEventSchemaRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<EventAttributeSchema>}
     * @memberof CreateEventSchemaRequest
     */
    'attributes': Array<EventAttributeSchema>;
    /**
     * 
     * @type {Array<DimensionsSchema>}
     * @memberof CreateEventSchemaRequest
     */
    'dimensions': Array<DimensionsSchema>;
}
/**
 * Request to create a price plan
 * @export
 * @interface CreatePricePlanRequest
 */
export interface CreatePricePlanRequest {
    /**
     * Name of the price plan
     * @type {string}
     * @memberof CreatePricePlanRequest
     */
    'name': string;
    /**
     * Description of price plan
     * @type {string}
     * @memberof CreatePricePlanRequest
     */
    'description'?: string;
    /**
     * 
     * @type {PricingCycle}
     * @memberof CreatePricePlanRequest
     */
    'pricingCycle': PricingCycle;
    /**
     * 
     * @type {RateCard}
     * @memberof CreatePricePlanRequest
     */
    'rateCard': RateCard;
}
/**
 * Request to create usage meter
 * @export
 * @interface CreateUsageMeterRequest
 */
export interface CreateUsageMeterRequest {
    /**
     * Name of the event. Must be unique for an organization.
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'name': string;
    /**
     * Description of the event
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'description'?: string;
    /**
     * Type of usage meter
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'type': CreateUsageMeterRequestTypeEnum;
    /**
     * Aggregation to be applied on usage meter result
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'aggregation': CreateUsageMeterRequestAggregationEnum;
    /**
     * Filters to be applied on event before matching to usage meter in JSONLogic format (https://jsonlogic.com/) 
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'filters'?: string;
    /**
     * Computation. Has no effect if aggregation is \'count\'
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'computation'?: string;
}

export const CreateUsageMeterRequestTypeEnum = {
    Counter: 'COUNTER',
    Gauge: 'GAUGE',
    Timer: 'TIMER'
} as const;

export type CreateUsageMeterRequestTypeEnum = typeof CreateUsageMeterRequestTypeEnum[keyof typeof CreateUsageMeterRequestTypeEnum];
export const CreateUsageMeterRequestAggregationEnum = {
    Count: 'COUNT',
    Sum: 'SUM'
} as const;

export type CreateUsageMeterRequestAggregationEnum = typeof CreateUsageMeterRequestAggregationEnum[keyof typeof CreateUsageMeterRequestAggregationEnum];

/**
 * Structure of customer
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * Identifier of customer
     * @type {string}
     * @memberof Customer
     */
    'id': string;
    /**
     * Name of the customer
     * @type {string}
     * @memberof Customer
     */
    'name': string;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof Customer
     */
    'primaryEmail': string;
    /**
     * billing address of the customer
     * @type {string}
     * @memberof Customer
     */
    'billingAddress': string;
    /**
     * Status of the customer
     * @type {string}
     * @memberof Customer
     */
    'status': CustomerStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'updatedAt': string;
}

export const CustomerStatusEnum = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type CustomerStatusEnum = typeof CustomerStatusEnum[keyof typeof CustomerStatusEnum];

/**
 * 
 * @export
 * @interface CustomerPaginatedResponse
 */
export interface CustomerPaginatedResponse {
    /**
     * 
     * @type {Array<Customer>}
     * @memberof CustomerPaginatedResponse
     */
    'data'?: Array<Customer>;
    /**
     * 
     * @type {string}
     * @memberof CustomerPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof CustomerPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * Structure of dimensions
 * @export
 * @interface DimensionsSchema
 */
export interface DimensionsSchema {
    /**
     * Name of the event dimension
     * @type {string}
     * @memberof DimensionsSchema
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * error description
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
}
/**
 * Contents of the event
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * Name of the event to be recorded.
     * @type {string}
     * @memberof Event
     */
    'eventName': string;
    /**
     * A unique value to identify the event instance. This unique value should be generated by the client and it acts as the **idempotency key**. Togai server will use this key to recognize subsequent retries of the same request and avoid metering multiple times for that same request. This id can be created in any format but we recommend using UUIDv4 to reduce collision occurance.    NOTE1: Expiry time for idempotency validation will be until the end of the billing cycle. Any request which comes after the billing cycle with the same id will be treated as new request and ingested for metering.   NOTE2: If the billing cycle is not configured for the idempotency validation will be until **10 days** of the event ingestion.
     * @type {string}
     * @memberof Event
     */
    'id': string;
    /**
     * Source time stamp of the event. This timestamp must be in ISO 8601 format.
     * @type {string}
     * @memberof Event
     */
    'eventTimestamp': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'accountId': string;
    /**
     * 
     * @type {Array<EventAttribute>}
     * @memberof Event
     */
    'eventAttributes': Array<EventAttribute>;
    /**
     * Dimensions are tags/labels associated with the events. This dimensions can be used to configure billing, for queries, analytics and reports.
     * @type {{ [key: string]: string; }}
     * @memberof Event
     */
    'dimensions': { [key: string]: string; };
}
/**
 * Metric to be recorded
 * @export
 * @interface EventAttribute
 */
export interface EventAttribute {
    /**
     * Name of the event attribute
     * @type {string}
     * @memberof EventAttribute
     */
    'attributeName': string;
    /**
     * Value of the event attribute
     * @type {string}
     * @memberof EventAttribute
     */
    'attributeValue': string;
    /**
     * Unit with which the attribute value was measured. Natively supported units - \"Meters, Miles, Kilometers, Grams, Kilograms, ounces, Pounds, Minutes, Hours, Seconds, Milliseconds, Microseconds, None\". Clients are free to add any other custom units.
     * @type {string}
     * @memberof EventAttribute
     */
    'attributeValueUnit'?: string;
}
/**
 * Structure of an event attribute
 * @export
 * @interface EventAttributeSchema
 */
export interface EventAttributeSchema {
    /**
     * Name of the event attribute.
     * @type {string}
     * @memberof EventAttributeSchema
     */
    'name': string;
    /**
     * Unit for the attribute
     * @type {string}
     * @memberof EventAttributeSchema
     */
    'default_unit'?: string;
}
/**
 * Information related to ingestion of an event
 * @export
 * @interface EventPipelineInfo
 */
export interface EventPipelineInfo {
    /**
     * 
     * @type {EventPipelineInfoEventSchema}
     * @memberof EventPipelineInfo
     */
    'eventSchema'?: EventPipelineInfoEventSchema;
    /**
     * 
     * @type {Array<EventPipelineInfoUsageMetersInner>}
     * @memberof EventPipelineInfo
     */
    'usageMeters'?: Array<EventPipelineInfoUsageMetersInner>;
    /**
     * 
     * @type {Array<EventPipelineInfoPricePlansInner>}
     * @memberof EventPipelineInfo
     */
    'pricePlans'?: Array<EventPipelineInfoPricePlansInner>;
    /**
     * 
     * @type {EventPipelineInfoAccount}
     * @memberof EventPipelineInfo
     */
    'account'?: EventPipelineInfoAccount;
    /**
     * 
     * @type {EventPipelineInfoCustomer}
     * @memberof EventPipelineInfo
     */
    'customer'?: EventPipelineInfoCustomer;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoAccount
 */
export interface EventPipelineInfoAccount {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoAccount
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoAccount
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoCustomer
 */
export interface EventPipelineInfoCustomer {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoCustomer
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoCustomer
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoEventSchema
 */
export interface EventPipelineInfoEventSchema {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoEventSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof EventPipelineInfoEventSchema
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoPricePlansInner
 */
export interface EventPipelineInfoPricePlansInner {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlansInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlansInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlansInner
     */
    'cycleStart': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlansInner
     */
    'cycleEnd': string;
    /**
     * 
     * @type {Set<string>}
     * @memberof EventPipelineInfoPricePlansInner
     */
    'usageMeters'?: Set<string>;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoUsageMetersInner
 */
export interface EventPipelineInfoUsageMetersInner {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoUsageMetersInner
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof EventPipelineInfoUsageMetersInner
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoUsageMetersInner
     */
    'status': EventPipelineInfoUsageMetersInnerStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof EventPipelineInfoUsageMetersInner
     */
    'units'?: number;
}

export const EventPipelineInfoUsageMetersInnerStatusEnum = {
    FilteredOut: 'PROCESSED_FILTERED_OUT',
    UnitsComputed: 'PROCESSED_UNITS_COMPUTED'
} as const;

export type EventPipelineInfoUsageMetersInnerStatusEnum = typeof EventPipelineInfoUsageMetersInnerStatusEnum[keyof typeof EventPipelineInfoUsageMetersInnerStatusEnum];

/**
 * Structure of an event schema
 * @export
 * @interface EventSchema
 */
export interface EventSchema {
    /**
     * Name of the event. Must be unique for an organization.
     * @type {string}
     * @memberof EventSchema
     */
    'name': string;
    /**
     * Description of the event
     * @type {string}
     * @memberof EventSchema
     */
    'description'?: string;
    /**
     * Version of event schema
     * @type {number}
     * @memberof EventSchema
     */
    'version': number;
    /**
     * Status of event schema * DRAFT - Schema is in draft state  * ACTIVE - Schema is currently active  * INACTIVE - Schema is currently inactive * ARCHIVED - Older version of event schema 
     * @type {string}
     * @memberof EventSchema
     */
    'status'?: EventSchemaStatusEnum;
    /**
     * 
     * @type {Set<EventAttributeSchema>}
     * @memberof EventSchema
     */
    'attributes': Set<EventAttributeSchema>;
    /**
     * 
     * @type {Set<DimensionsSchema>}
     * @memberof EventSchema
     */
    'dimensions'?: Set<DimensionsSchema>;
    /**
     * 
     * @type {string}
     * @memberof EventSchema
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSchema
     */
    'updatedAt'?: string;
}

export const EventSchemaStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type EventSchemaStatusEnum = typeof EventSchemaStatusEnum[keyof typeof EventSchemaStatusEnum];

/**
 * 
 * @export
 * @interface EventSchemaListData
 */
export interface EventSchemaListData {
    /**
     * Name of the event. Must be unique for an organization.
     * @type {string}
     * @memberof EventSchemaListData
     */
    'name': string;
    /**
     * Description of the event
     * @type {string}
     * @memberof EventSchemaListData
     */
    'description'?: string;
    /**
     * Version of event schema
     * @type {number}
     * @memberof EventSchemaListData
     */
    'version': number;
    /**
     * Status of event schema * DRAFT - Schema is in draft state  * ACTIVE - Schema is currently active  * INACTIVE - Schema is currently inactive * ARCHIVED - Older version of event schema 
     * @type {string}
     * @memberof EventSchemaListData
     */
    'status'?: EventSchemaListDataStatusEnum;
    /**
     * 
     * @type {Set<EventAttributeSchema>}
     * @memberof EventSchemaListData
     */
    'attributes': Set<EventAttributeSchema>;
    /**
     * 
     * @type {Set<DimensionsSchema>}
     * @memberof EventSchemaListData
     */
    'dimensions'?: Set<DimensionsSchema>;
    /**
     * 
     * @type {string}
     * @memberof EventSchemaListData
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSchemaListData
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventSchemaListData
     */
    'associatedUsageMeters'?: Array<string>;
}

export const EventSchemaListDataStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type EventSchemaListDataStatusEnum = typeof EventSchemaListDataStatusEnum[keyof typeof EventSchemaListDataStatusEnum];

/**
 * 
 * @export
 * @interface EventSchemaListDataAllOf
 */
export interface EventSchemaListDataAllOf {
    /**
     * 
     * @type {Array<string>}
     * @memberof EventSchemaListDataAllOf
     */
    'associatedUsageMeters'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EventSchemaListPaginatedResponse
 */
export interface EventSchemaListPaginatedResponse {
    /**
     * 
     * @type {Array<EventSchemaListData>}
     * @memberof EventSchemaListPaginatedResponse
     */
    'data'?: Array<EventSchemaListData>;
    /**
     * 
     * @type {string}
     * @memberof EventSchemaListPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof EventSchemaListPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * Response for event schema versions
 * @export
 * @interface EventSchemaVersionsResponse
 */
export interface EventSchemaVersionsResponse {
    /**
     * 
     * @type {Array<EventSchema>}
     * @memberof EventSchemaVersionsResponse
     */
    'data': Array<EventSchema>;
}
/**
 * Raw usage event ingested by the business team and the status of the event ingestion.
 * @export
 * @interface EventWithStatus
 */
export interface EventWithStatus {
    /**
     * 
     * @type {Event}
     * @memberof EventWithStatus
     */
    'eventPayload': Event;
    /**
     * 
     * @type {IngestionStatus}
     * @memberof EventWithStatus
     */
    'ingestionStatus': IngestionStatus;
}
/**
 * 
 * @export
 * @interface EventWithStatusAndEventPipelineInfo
 */
export interface EventWithStatusAndEventPipelineInfo {
    /**
     * 
     * @type {Event}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'eventPayload': Event;
    /**
     * 
     * @type {IngestionStatus}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'ingestionStatus': IngestionStatus;
    /**
     * 
     * @type {EventPipelineInfo}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'EventPipelineInfo'?: EventPipelineInfo;
}
/**
 * 
 * @export
 * @interface EventWithStatusAndEventPipelineInfoAllOf
 */
export interface EventWithStatusAndEventPipelineInfoAllOf {
    /**
     * 
     * @type {EventPipelineInfo}
     * @memberof EventWithStatusAndEventPipelineInfoAllOf
     */
    'EventPipelineInfo'?: EventPipelineInfo;
}
/**
 * Get single event response
 * @export
 * @interface GetEventResponse
 */
export interface GetEventResponse {
    /**
     * 
     * @type {Array<EventWithStatusAndEventPipelineInfo>}
     * @memberof GetEventResponse
     */
    'events'?: Array<EventWithStatusAndEventPipelineInfo>;
}
/**
 * Get batch events response
 * @export
 * @interface GetEventsResponse
 */
export interface GetEventsResponse {
    /**
     * 
     * @type {Array<EventWithStatus>}
     * @memberof GetEventsResponse
     */
    'events': Array<EventWithStatus>;
    /**
     * 
     * @type {string}
     * @memberof GetEventsResponse
     */
    'nextToken'?: string;
}
/**
 * Request to get metrics from togai
 * @export
 * @interface GetMetricsRequest
 */
export interface GetMetricsRequest {
    /**
     * 
     * @type {string}
     * @memberof GetMetricsRequest
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof GetMetricsRequest
     */
    'endTime': string;
    /**
     * 
     * @type {Set<MetricQuery>}
     * @memberof GetMetricsRequest
     */
    'metricQueries': Set<MetricQuery>;
}
/**
 * Response to GetMetrics Request
 * @export
 * @interface GetMetricsResponse
 */
export interface GetMetricsResponse {
    /**
     * 
     * @type {Array<MetricQueryResponse>}
     * @memberof GetMetricsResponse
     */
    'results': Array<MetricQueryResponse>;
}
/**
 * Payload for ingesting batch events
 * @export
 * @interface IngestBatchEventRequest
 */
export interface IngestBatchEventRequest {
    /**
     * 
     * @type {Array<Event>}
     * @memberof IngestBatchEventRequest
     */
    'events': Array<Event>;
}
/**
 * 
 * @export
 * @interface IngestBatchEventResponse
 */
export interface IngestBatchEventResponse {
    /**
     * 
     * @type {Array<IngestError>}
     * @memberof IngestBatchEventResponse
     */
    'errors': Array<IngestError>;
}
/**
 * 
 * @export
 * @interface IngestError
 */
export interface IngestError {
    /**
     * 
     * @type {string}
     * @memberof IngestError
     */
    'message'?: string;
    /**
     * 
     * @type {Event}
     * @memberof IngestError
     */
    'eventPayload'?: Event;
}
/**
 * Payload for ingesting events
 * @export
 * @interface IngestEventRequest
 */
export interface IngestEventRequest {
    /**
     * 
     * @type {Event}
     * @memberof IngestEventRequest
     */
    'event'?: Event;
}
/**
 * 
 * @export
 * @interface IngestEventResponse
 */
export interface IngestEventResponse {
    /**
     * On successful ingestion acceptance request, ingestion request id will be returned. This ingestion id can be used by clients to query the status of ingestion (IN_PROGRESS, COMPLETED).
     * @type {string}
     * @memberof IngestEventResponse
     */
    'ingestionRequestId': string;
}
/**
 * Status about the event ingestion.
 * @export
 * @interface IngestionStatus
 */
export interface IngestionStatus {
    /**
     * Ingestion status
     * @type {string}
     * @memberof IngestionStatus
     */
    'status': IngestionStatusStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof IngestionStatus
     */
    'statusDescription'?: string;
}

export const IngestionStatusStatusEnum = {
    IngestionInProgress: 'INGESTION_IN_PROGRESS',
    IngestionFailed: 'INGESTION_FAILED',
    IngestionFailedSchemaNotDefined: 'INGESTION_FAILED_SCHEMA_NOT_DEFINED',
    IngestionFailedUnitsInvalid: 'INGESTION_FAILED_UNITS_INVALID',
    IngestionCompletedNoMatchingMeters: 'INGESTION_COMPLETED_NO_MATCHING_METERS',
    IngestionCompletedEventMetered: 'INGESTION_COMPLETED_EVENT_METERED',
    IngestionCompletedEventNotMetered: 'INGESTION_COMPLETED_EVENT_NOT_METERED',
    Unknown: 'UNKNOWN'
} as const;

export type IngestionStatusStatusEnum = typeof IngestionStatusStatusEnum[keyof typeof IngestionStatusStatusEnum];

/**
 * 
 * @export
 * @interface MetricDataPoints
 */
export interface MetricDataPoints {
    /**
     * 
     * @type {MetricDataPointsGroupedBy}
     * @memberof MetricDataPoints
     */
    'groupedBy'?: MetricDataPointsGroupedBy;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetricDataPoints
     */
    'timestamps': Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof MetricDataPoints
     */
    'metricValues': Array<number>;
}
/**
 * 
 * @export
 * @interface MetricDataPointsGroupedBy
 */
export interface MetricDataPointsGroupedBy {
    /**
     * 
     * @type {string}
     * @memberof MetricDataPointsGroupedBy
     */
    'fieldName': string;
    /**
     * 
     * @type {string}
     * @memberof MetricDataPointsGroupedBy
     */
    'fieldValue': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MetricName = {
    Events: 'EVENTS',
    Usage: 'USAGE',
    Revenue: 'REVENUE'
} as const;

export type MetricName = typeof MetricName[keyof typeof MetricName];


/**
 * Object representing a single metrics query
 * @export
 * @interface MetricQuery
 */
export interface MetricQuery {
    /**
     * 
     * @type {string}
     * @memberof MetricQuery
     */
    'id': string;
    /**
     * 
     * @type {MetricName}
     * @memberof MetricQuery
     */
    'name': MetricName;
    /**
     * 
     * @type {string}
     * @memberof MetricQuery
     */
    'aggregationPeriod': MetricQueryAggregationPeriodEnum;
    /**
     * 
     * @type {string}
     * @memberof MetricQuery
     */
    'groupBy'?: string;
    /**
     * 
     * @type {Array<MetricQueryFilterEntry>}
     * @memberof MetricQuery
     */
    'filters'?: Array<MetricQueryFilterEntry>;
}

export const MetricQueryAggregationPeriodEnum = {
    Day: 'DAY',
    Week: 'WEEK',
    Month: 'MONTH'
} as const;

export type MetricQueryAggregationPeriodEnum = typeof MetricQueryAggregationPeriodEnum[keyof typeof MetricQueryAggregationPeriodEnum];

/**
 *  | Metric Name | FilterEntry Name |    Allowed groupBy fields    |      Default Values      |                 Allowed Values                  | |-------------|------------------|------------------------------|--------------------------|-------------------------------------------------| | EVENTS      | ACCOUNT_ID       | ACCOUNT_ID, EVENT_STATUS     | None                     | *\\<one or more valid accounts IDs>              | | EVENTS      | CUSTOMER_ID      | ACCOUNT_ID, EVENT_STATUS     | None                     | *\\<at most one valid customer ID>               | | EVENTS      | EVENT_STATUS     | ACCOUNT_ID, EVENT_STATUS     | [PROCESSED, UNPROCESSED] | oneOrMoreOf PROCESSED, UNPROCESSED, IN_PROGRESS | | USAGE       | ACCOUNT_ID       | ACCOUNT_ID, USAGE_METER_NAME | None                     | *\\<one or more valid accounts ID>               | | USAGE       | CUSTOMER_ID      | ACCOUNT_ID, USAGE_METER_NAME | None                     | *\\<at most one valid customer ID>               | | USAGE       | USAGE_METER_NAME | ACCOUNT_ID, USAGE_METER_NAME | None                     | *\\<one or more valid usage meter name>          | | REVENUE     | ACCOUNT_ID       | ACCOUNT_ID, USAGE_METER_NAME | None                     | *\\<one or more valid accounts ID>               | | REVENUE     | CUSTOMER_ID      | ACCOUNT_ID, USAGE_METER_NAME | None                     | *\\<at most one valid customer ID>               | | REVENUE     | USAGE_METER_NAME | ACCOUNT_ID, USAGE_METER_NAME | None                     | *\\<one or more valid usage meter name>          | 
 * @export
 * @interface MetricQueryFilterEntry
 */
export interface MetricQueryFilterEntry {
    /**
     * 
     * @type {string}
     * @memberof MetricQueryFilterEntry
     */
    'fieldName': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetricQueryFilterEntry
     */
    'fieldValues': Array<string>;
}
/**
 * Response to GetMetrics Request
 * @export
 * @interface MetricQueryResponse
 */
export interface MetricQueryResponse {
    /**
     * 
     * @type {string}
     * @memberof MetricQueryResponse
     */
    'id': string;
    /**
     * 
     * @type {MetricName}
     * @memberof MetricQueryResponse
     */
    'name': MetricName;
    /**
     * 
     * @type {Array<MetricDataPoints>}
     * @memberof MetricQueryResponse
     */
    'data': Array<MetricDataPoints>;
}
/**
 * 
 * @export
 * @interface PaginationOptions
 */
export interface PaginationOptions {
    /**
     * 
     * @type {number}
     * @memberof PaginationOptions
     */
    'pageSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginationOptions
     */
    'sortOrder'?: PaginationOptionsSortOrderEnum;
}

export const PaginationOptionsSortOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type PaginationOptionsSortOrderEnum = typeof PaginationOptionsSortOrderEnum[keyof typeof PaginationOptionsSortOrderEnum];

/**
 * Represents effectiveness period and config of a price plan. i.e, price plan bound by time.
 * @export
 * @interface PlanOverride
 */
export interface PlanOverride {
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'pricePlanName': string;
    /**
     * 
     * @type {RateCard}
     * @memberof PlanOverride
     */
    'override'?: RateCard;
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'endDate': string;
}
/**
 * Price plan entity
 * @export
 * @interface PricePlan
 */
export interface PricePlan {
    /**
     * Name of the price plan
     * @type {string}
     * @memberof PricePlan
     */
    'name': string;
    /**
     * Description of price plan
     * @type {string}
     * @memberof PricePlan
     */
    'description'?: string;
    /**
     * Status of Price plan
     * @type {string}
     * @memberof PricePlan
     */
    'status': PricePlanStatusEnum;
    /**
     * 
     * @type {PricingCycle}
     * @memberof PricePlan
     */
    'pricingCycle': PricingCycle;
    /**
     * 
     * @type {Array<PricingSchedule>}
     * @memberof PricePlan
     */
    'pricingSchedule': Array<PricingSchedule>;
}

export const PricePlanStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type PricePlanStatusEnum = typeof PricePlanStatusEnum[keyof typeof PricePlanStatusEnum];

/**
 * Data of price plan list
 * @export
 * @interface PricePlanListData
 */
export interface PricePlanListData {
    /**
     * Name of the price plan
     * @type {string}
     * @memberof PricePlanListData
     */
    'name': string;
    /**
     * Description of price plan
     * @type {string}
     * @memberof PricePlanListData
     */
    'description'?: string;
    /**
     * Status of Price plan
     * @type {string}
     * @memberof PricePlanListData
     */
    'status': PricePlanListDataStatusEnum;
    /**
     * 
     * @type {PricingCycle}
     * @memberof PricePlanListData
     */
    'pricingCycle': PricingCycle;
    /**
     * Usage meters name linked to the price plan
     * @type {Array<string>}
     * @memberof PricePlanListData
     */
    'usageMeters': Array<string>;
    /**
     * Pricing type of the price plan
     * @type {string}
     * @memberof PricePlanListData
     */
    'pricingType': string;
    /**
     * 
     * @type {string}
     * @memberof PricePlanListData
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PricePlanListData
     */
    'updatedAt': string;
}

export const PricePlanListDataStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type PricePlanListDataStatusEnum = typeof PricePlanListDataStatusEnum[keyof typeof PricePlanListDataStatusEnum];

/**
 * 
 * @export
 * @interface PricePlanPaginatedResponse
 */
export interface PricePlanPaginatedResponse {
    /**
     * 
     * @type {Array<PricePlanListData>}
     * @memberof PricePlanPaginatedResponse
     */
    'data'?: Array<PricePlanListData>;
    /**
     * 
     * @type {string}
     * @memberof PricePlanPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof PricePlanPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * Represents configurations related to pricing cycle
 * @export
 * @interface PricingCycle
 */
export interface PricingCycle {
    /**
     * 
     * @type {string}
     * @memberof PricingCycle
     */
    'interval': PricingCycleIntervalEnum;
    /**
     * 
     * @type {string}
     * @memberof PricingCycle
     */
    'startType': PricingCycleStartTypeEnum;
    /**
     * 
     * @type {PricingCycleStartOffset}
     * @memberof PricingCycle
     */
    'startOffset': PricingCycleStartOffset;
    /**
     * 
     * @type {number}
     * @memberof PricingCycle
     */
    'gracePeriod': number;
}

export const PricingCycleIntervalEnum = {
    Monthly: 'MONTHLY',
    Quarterly: 'QUARTERLY',
    HalfYearly: 'HALF_YEARLY',
    Annually: 'ANNUALLY'
} as const;

export type PricingCycleIntervalEnum = typeof PricingCycleIntervalEnum[keyof typeof PricingCycleIntervalEnum];
export const PricingCycleStartTypeEnum = {
    Static: 'STATIC'
} as const;

export type PricingCycleStartTypeEnum = typeof PricingCycleStartTypeEnum[keyof typeof PricingCycleStartTypeEnum];

/**
 * Represents the start of pricing cycle in terms of  - dayOffset - number of days from beginning of month and  - monthOffset - number of months from beginning of interval (quarter, half-year or year) Note: If a day with offset doesn\'t exist for a month, closest previous day is considered Examples: MONTHLY -   - {dayOffset: 1} - First day of every month   - {dayOffset: 12} - 12th of every month   - {dayOffset: 28} - 28th of every month. i.e, 28th of Jan, 28th of Feb, ...   - {dayOffset: 30} - 30th of every month. i.e, 28th of Jan, 28th of Feb, ...   - {dayOffset: LAST} - Last day of every month. i.e, 31st of Jan, 28th of Feb, ... QUARTERLY   - {dayOffset: 15, monthOffset: FIRST} - 15th Jan, 15th Apr, 15th Jul and 15th Oct   - {dayOffset: 15, monthOffset: 2} - 15th Feb, 15th May, 15th Aug and 15th Nov   - {dayOffset: 15, monthOffset: LAST} - 15th Mar, 15th Jun, 15th Sep and 15th Dec   - {dayOffset: LAST, monthOffset: FIRST} - 31st Jan, 30th Apr, 30th Jul and 31th Oct HALF_YEARLY   - {dayOffset: 15, monthOffset: FIRST} - 15th Jan and 15th Jul   - {dayOffset: 15, monthOffset: 4} - 15th Apr and 15th Oct   - {dayOffset: 15, monthOffset: LAST} - 15th Jun and 15th Dec ANNUALLY   - {dayOffset: 15, monthOffset: FIRST} - 15th Jan   - {dayOffset: 15, monthOffset: 1} - 15th Jan   - {dayOffset: LAST, monthOffset: 2} - 29th Feb on Leap year, 28th otherwise    - {dayOffset: 15, monthOffset: 8} - 15th Aug   - {dayOffset: 15, monthOffset: LAST} - 15th Dec 
 * @export
 * @interface PricingCycleStartOffset
 */
export interface PricingCycleStartOffset {
    /**
     * min: \"1\" and max: \"31\" as strings. Spl. string allowed: LAST 
     * @type {string}
     * @memberof PricingCycleStartOffset
     */
    'dayOffset': string;
    /**
     * min: \"1\" and max: \"12\". Spl. string allowed: FIRST / LAST. For QUARTERLY only 1 - 3 is allowed and for HALF_YEARLY 1 - 6. This being an optional field, shouldn\'t be passed for MONTHLY. 
     * @type {string}
     * @memberof PricingCycleStartOffset
     */
    'monthOffset'?: string;
}
/**
 * Represents effectiveness period and config of a price plan. i.e, price plan bound by time.
 * @export
 * @interface PricingSchedule
 */
export interface PricingSchedule {
    /**
     * 
     * @type {RateCard}
     * @memberof PricingSchedule
     */
    'ratePayload'?: RateCard;
    /**
     * 
     * @type {string}
     * @memberof PricingSchedule
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof PricingSchedule
     */
    'endDate': string;
}
/**
 * Represents a rate card
 * @export
 * @interface RateCard
 */
export interface RateCard {
    /**
     * 
     * @type {string}
     * @memberof RateCard
     */
    'type': RateCardTypeEnum;
    /**
     * 
     * @type {{ [key: string]: RateCardUsageValue; }}
     * @memberof RateCard
     */
    'usageConfig'?: { [key: string]: RateCardUsageValue; };
    /**
     * 
     * @type {RateCardBundle}
     * @memberof RateCard
     */
    'bundleConfig'?: RateCardBundle;
}

export const RateCardTypeEnum = {
    Usage: 'USAGE',
    Bundle: 'BUNDLE'
} as const;

export type RateCardTypeEnum = typeof RateCardTypeEnum[keyof typeof RateCardTypeEnum];

/**
 * 
 * @export
 * @interface RateCardBundle
 */
export interface RateCardBundle {
    /**
     * 
     * @type {string}
     * @memberof RateCardBundle
     */
    'rateStrategy': RateCardBundleRateStrategyEnum;
    /**
     * 
     * @type {string}
     * @memberof RateCardBundle
     */
    'slabStrategy': RateCardBundleSlabStrategyEnum;
    /**
     * 
     * @type {Array<BundleStrategy>}
     * @memberof RateCardBundle
     */
    'bundles': Array<BundleStrategy>;
}

export const RateCardBundleRateStrategyEnum = {
    Flat: 'FLAT'
} as const;

export type RateCardBundleRateStrategyEnum = typeof RateCardBundleRateStrategyEnum[keyof typeof RateCardBundleRateStrategyEnum];
export const RateCardBundleSlabStrategyEnum = {
    Tier: 'TIER'
} as const;

export type RateCardBundleSlabStrategyEnum = typeof RateCardBundleSlabStrategyEnum[keyof typeof RateCardBundleSlabStrategyEnum];

/**
 * Represents rate card of a price plan of usage type
 * @export
 * @interface RateCardUsageValue
 */
export interface RateCardUsageValue {
    /**
     * 
     * @type {string}
     * @memberof RateCardUsageValue
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RateCardUsageValue
     */
    'rateStrategy': RateCardUsageValueRateStrategyEnum;
    /**
     * 
     * @type {string}
     * @memberof RateCardUsageValue
     */
    'slabStrategy': RateCardUsageValueSlabStrategyEnum;
    /**
     * 
     * @type {Array<UsageStrategy>}
     * @memberof RateCardUsageValue
     */
    'slabs': Array<UsageStrategy>;
}

export const RateCardUsageValueRateStrategyEnum = {
    Flat: 'FLAT',
    PerUnit: 'PER_UNIT'
} as const;

export type RateCardUsageValueRateStrategyEnum = typeof RateCardUsageValueRateStrategyEnum[keyof typeof RateCardUsageValueRateStrategyEnum];
export const RateCardUsageValueSlabStrategyEnum = {
    Tier: 'TIER'
} as const;

export type RateCardUsageValueSlabStrategyEnum = typeof RateCardUsageValueSlabStrategyEnum[keyof typeof RateCardUsageValueSlabStrategyEnum];

/**
 * Payload to remove aliases from account
 * @export
 * @interface RemoveAccountAliasesRequest
 */
export interface RemoveAccountAliasesRequest {
    /**
     * List of aliases to remove
     * @type {Array<string>}
     * @memberof RemoveAccountAliasesRequest
     */
    'aliases'?: Array<string>;
}
/**
 * Payload to signup
 * @export
 * @interface SignupRequest
 */
export interface SignupRequest {
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    'description'?: string;
    /**
     * 
     * @type {UserDetails}
     * @memberof SignupRequest
     */
    'userDetails': UserDetails;
}
/**
 * Signup response
 * @export
 * @interface SignupResponse
 */
export interface SignupResponse {
    /**
     * Organization Identifier
     * @type {string}
     * @memberof SignupResponse
     */
    'organizationId': string;
    /**
     * Token which can be used for authentication
     * @type {string}
     * @memberof SignupResponse
     */
    'jwtToken': string;
}
/**
 * 
 * @export
 * @interface StatusResponse
 */
export interface StatusResponse {
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'greeting'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'url'?: string;
    /**
     * 
     * @type {StatusResponseHeaders}
     * @memberof StatusResponse
     */
    'headers'?: StatusResponseHeaders;
}
/**
 * 
 * @export
 * @interface StatusResponseHeaders
 */
export interface StatusResponseHeaders {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof StatusResponseHeaders
     */
    'Content-Type'?: string;
}
/**
 * Payload to update account
 * @export
 * @interface UpdateAccountRequest
 */
export interface UpdateAccountRequest {
    /**
     * Name of the customer
     * @type {string}
     * @memberof UpdateAccountRequest
     */
    'name'?: string;
}
/**
 * Payload to update customer
 * @export
 * @interface UpdateCustomerRequest
 */
export interface UpdateCustomerRequest {
    /**
     * Name of the customer
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'name'?: string;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'primaryEmail'?: string;
    /**
     * billing address of the customer
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'billingAddress'?: string;
}
/**
 * Request to update event schema
 * @export
 * @interface UpdateEventSchemaRequest
 */
export interface UpdateEventSchemaRequest {
    /**
     * Description of the event
     * @type {string}
     * @memberof UpdateEventSchemaRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<EventAttributeSchema>}
     * @memberof UpdateEventSchemaRequest
     */
    'attributes': Array<EventAttributeSchema>;
    /**
     * 
     * @type {Array<DimensionsSchema>}
     * @memberof UpdateEventSchemaRequest
     */
    'dimensions': Array<DimensionsSchema>;
}
/**
 * Request to update a price plan
 * @export
 * @interface UpdatePricePlanRequest
 */
export interface UpdatePricePlanRequest {
    /**
     * Description of price plan
     * @type {string}
     * @memberof UpdatePricePlanRequest
     */
    'description'?: string;
    /**
     * 
     * @type {PricingCycle}
     * @memberof UpdatePricePlanRequest
     */
    'pricingCycle'?: PricingCycle;
    /**
     * 
     * @type {RateCard}
     * @memberof UpdatePricePlanRequest
     */
    'rateCard'?: RateCard;
}
/**
 * Request to update usage meter
 * @export
 * @interface UpdateUsageMeterRequest
 */
export interface UpdateUsageMeterRequest {
    /**
     * Description of the event
     * @type {string}
     * @memberof UpdateUsageMeterRequest
     */
    'description'?: string;
    /**
     * Type of usage meter * COUNTER - Count usage  * GAUGE - Not supported at the moment * TIMER - Not supported at the moment 
     * @type {string}
     * @memberof UpdateUsageMeterRequest
     */
    'type': UpdateUsageMeterRequestTypeEnum;
    /**
     * Aggregation to be applied on usage meter result * COUNT - Counts number of events matching the usage meter * SUM - Sums up results of computation of all events matching usage meter 
     * @type {string}
     * @memberof UpdateUsageMeterRequest
     */
    'aggregation': UpdateUsageMeterRequestAggregationEnum;
    /**
     * Filters to be applied on event before matching to usage meter in JSONLogic format (https://jsonlogic.com/) 
     * @type {string}
     * @memberof UpdateUsageMeterRequest
     */
    'filters'?: string;
    /**
     * Computation. Has no effect if aggregation is \'count\'
     * @type {string}
     * @memberof UpdateUsageMeterRequest
     */
    'computation'?: string;
}

export const UpdateUsageMeterRequestTypeEnum = {
    Counter: 'COUNTER',
    Gauge: 'GAUGE',
    Timer: 'TIMER'
} as const;

export type UpdateUsageMeterRequestTypeEnum = typeof UpdateUsageMeterRequestTypeEnum[keyof typeof UpdateUsageMeterRequestTypeEnum];
export const UpdateUsageMeterRequestAggregationEnum = {
    Count: 'COUNT',
    Sum: 'SUM'
} as const;

export type UpdateUsageMeterRequestAggregationEnum = typeof UpdateUsageMeterRequestAggregationEnum[keyof typeof UpdateUsageMeterRequestAggregationEnum];

/**
 * Structure of usage meter
 * @export
 * @interface UsageMeter
 */
export interface UsageMeter {
    /**
     * Name of the usage meter
     * @type {string}
     * @memberof UsageMeter
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UsageMeter
     */
    'description'?: string;
    /**
     * Type of usage meter
     * @type {string}
     * @memberof UsageMeter
     */
    'type': UsageMeterTypeEnum;
    /**
     * Status of usage meter
     * @type {string}
     * @memberof UsageMeter
     */
    'status'?: UsageMeterStatusEnum;
    /**
     * Aggregation to be applied on usage meter result
     * @type {string}
     * @memberof UsageMeter
     */
    'aggregation': UsageMeterAggregationEnum;
    /**
     * Filters to be applied on event before matching to usage meter in JSONLogic format (https://jsonlogic.com/) 
     * @type {string}
     * @memberof UsageMeter
     */
    'filters'?: string;
    /**
     * Computation. Has no effect if aggregation is \'count\'
     * @type {string}
     * @memberof UsageMeter
     */
    'computation'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsageMeter
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsageMeter
     */
    'lastActivatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsageMeter
     */
    'updatedAt'?: string;
}

export const UsageMeterTypeEnum = {
    Counter: 'COUNTER',
    Gauge: 'GAUGE',
    Timer: 'TIMER'
} as const;

export type UsageMeterTypeEnum = typeof UsageMeterTypeEnum[keyof typeof UsageMeterTypeEnum];
export const UsageMeterStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type UsageMeterStatusEnum = typeof UsageMeterStatusEnum[keyof typeof UsageMeterStatusEnum];
export const UsageMeterAggregationEnum = {
    Count: 'COUNT',
    Sum: 'SUM'
} as const;

export type UsageMeterAggregationEnum = typeof UsageMeterAggregationEnum[keyof typeof UsageMeterAggregationEnum];

/**
 * 
 * @export
 * @interface UsageMeterPaginatedResponse
 */
export interface UsageMeterPaginatedResponse {
    /**
     * 
     * @type {Array<UsageMeter>}
     * @memberof UsageMeterPaginatedResponse
     */
    'data'?: Array<UsageMeter>;
    /**
     * 
     * @type {string}
     * @memberof UsageMeterPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof UsageMeterPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * Represents a pricing strategy (rates + slabs) for usage price plan
 * @export
 * @interface UsageStrategy
 */
export interface UsageStrategy {
    /**
     * 
     * @type {number}
     * @memberof UsageStrategy
     */
    'rate': number;
    /**
     * 
     * @type {number}
     * @memberof UsageStrategy
     */
    'startAfter': number;
    /**
     * 
     * @type {number}
     * @memberof UsageStrategy
     */
    'order': number;
}
/**
 * Root user details for the organization
 * @export
 * @interface UserDetails
 */
export interface UserDetails {
    /**
     * 
     * @type {string}
     * @memberof UserDetails
     */
    'preferredUsername'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDetails
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserDetails
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserDetails
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserDetails
     */
    'phone'?: string;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add Aliases to an account by id
         * @summary Add Aliases to account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {AddAccountAliasesRequest} addAccountAliasesRequest Payload to add aliases to account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAliases: async (customerId: string, accountId: string, addAccountAliasesRequest: AddAccountAliasesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('addAliases', 'customerId', customerId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('addAliases', 'accountId', accountId)
            // verify required parameter 'addAccountAliasesRequest' is not null or undefined
            assertParamExists('addAliases', 'addAccountAliasesRequest', addAccountAliasesRequest)
            const localVarPath = `/customers/{customer_id}/accounts/{account_id}/add_aliases`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAccountAliasesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Associate a plan to an account
         * @summary Associate a plan to an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {AssociatePricePlanRequest} associatePricePlanRequest Payload to associate a price plan to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        associatePricePlan: async (customerId: string, accountId: string, associatePricePlanRequest: AssociatePricePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('associatePricePlan', 'customerId', customerId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('associatePricePlan', 'accountId', accountId)
            // verify required parameter 'associatePricePlanRequest' is not null or undefined
            assertParamExists('associatePricePlan', 'associatePricePlanRequest', associatePricePlanRequest)
            const localVarPath = `/customers/{customer_id}/accounts/{account_id}/price_plans`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(associatePricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an account
         * @summary Create an account
         * @param {string} customerId 
         * @param {CreateAccountRequest} createAccountRequest Payload to create account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (customerId: string, createAccountRequest: CreateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('createAccount', 'customerId', customerId)
            // verify required parameter 'createAccountRequest' is not null or undefined
            assertParamExists('createAccount', 'createAccountRequest', createAccountRequest)
            const localVarPath = `/customers/{customer_id}/accounts`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an account by id
         * @summary Delete an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (customerId: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('deleteAccount', 'customerId', customerId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAccount', 'accountId', accountId)
            const localVarPath = `/customers/{customer_id}/accounts/{account_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an account
         * @summary Get an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (customerId: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getAccount', 'customerId', customerId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccount', 'accountId', accountId)
            const localVarPath = `/customers/{customer_id}/accounts/{account_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List accounts with pagination and sort
         * @summary List accounts of customer
         * @param {string} customerId 
         * @param {string} [nextToken] 
         * @param {string} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (customerId: string, nextToken?: string, pageSize?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getAccounts', 'customerId', customerId)
            const localVarPath = `/customers/{customer_id}/accounts`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove Aliases to an account by id
         * @summary Remove Aliases to account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {RemoveAccountAliasesRequest} removeAccountAliasesRequest Payload to remove aliases from account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAliases: async (customerId: string, accountId: string, removeAccountAliasesRequest: RemoveAccountAliasesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('removeAliases', 'customerId', customerId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('removeAliases', 'accountId', accountId)
            // verify required parameter 'removeAccountAliasesRequest' is not null or undefined
            assertParamExists('removeAliases', 'removeAccountAliasesRequest', removeAccountAliasesRequest)
            const localVarPath = `/customers/{customer_id}/accounts/{account_id}/remove_aliases`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeAccountAliasesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an account by id
         * @summary Update an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {UpdateAccountRequest} updateAccountRequest Payload to update account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (customerId: string, accountId: string, updateAccountRequest: UpdateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('updateAccount', 'customerId', customerId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateAccount', 'accountId', accountId)
            // verify required parameter 'updateAccountRequest' is not null or undefined
            assertParamExists('updateAccount', 'updateAccountRequest', updateAccountRequest)
            const localVarPath = `/customers/{customer_id}/accounts/{account_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add Aliases to an account by id
         * @summary Add Aliases to account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {AddAccountAliasesRequest} addAccountAliasesRequest Payload to add aliases to account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAliases(customerId: string, accountId: string, addAccountAliasesRequest: AddAccountAliasesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAliases(customerId, accountId, addAccountAliasesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Associate a plan to an account
         * @summary Associate a plan to an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {AssociatePricePlanRequest} associatePricePlanRequest Payload to associate a price plan to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async associatePricePlan(customerId: string, accountId: string, associatePricePlanRequest: AssociatePricePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssociatePricePlanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.associatePricePlan(customerId, accountId, associatePricePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an account
         * @summary Create an account
         * @param {string} customerId 
         * @param {CreateAccountRequest} createAccountRequest Payload to create account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(customerId: string, createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(customerId, createAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an account by id
         * @summary Delete an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(customerId: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(customerId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an account
         * @summary Get an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(customerId: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(customerId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List accounts with pagination and sort
         * @summary List accounts of customer
         * @param {string} customerId 
         * @param {string} [nextToken] 
         * @param {string} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(customerId: string, nextToken?: string, pageSize?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(customerId, nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove Aliases to an account by id
         * @summary Remove Aliases to account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {RemoveAccountAliasesRequest} removeAccountAliasesRequest Payload to remove aliases from account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAliases(customerId: string, accountId: string, removeAccountAliasesRequest: RemoveAccountAliasesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAliases(customerId, accountId, removeAccountAliasesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an account by id
         * @summary Update an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {UpdateAccountRequest} updateAccountRequest Payload to update account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(customerId: string, accountId: string, updateAccountRequest: UpdateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(customerId, accountId, updateAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Add Aliases to an account by id
         * @summary Add Aliases to account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {AddAccountAliasesRequest} addAccountAliasesRequest Payload to add aliases to account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAliases(customerId: string, accountId: string, addAccountAliasesRequest: AddAccountAliasesRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.addAliases(customerId, accountId, addAccountAliasesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Associate a plan to an account
         * @summary Associate a plan to an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {AssociatePricePlanRequest} associatePricePlanRequest Payload to associate a price plan to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        associatePricePlan(customerId: string, accountId: string, associatePricePlanRequest: AssociatePricePlanRequest, options?: any): AxiosPromise<AssociatePricePlanResponse> {
            return localVarFp.associatePricePlan(customerId, accountId, associatePricePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an account
         * @summary Create an account
         * @param {string} customerId 
         * @param {CreateAccountRequest} createAccountRequest Payload to create account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(customerId: string, createAccountRequest: CreateAccountRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.createAccount(customerId, createAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an account by id
         * @summary Delete an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(customerId: string, accountId: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteAccount(customerId, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an account
         * @summary Get an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(customerId: string, accountId: string, options?: any): AxiosPromise<Account> {
            return localVarFp.getAccount(customerId, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * List accounts with pagination and sort
         * @summary List accounts of customer
         * @param {string} customerId 
         * @param {string} [nextToken] 
         * @param {string} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(customerId: string, nextToken?: string, pageSize?: string, options?: any): AxiosPromise<AccountPaginatedResponse> {
            return localVarFp.getAccounts(customerId, nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove Aliases to an account by id
         * @summary Remove Aliases to account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {RemoveAccountAliasesRequest} removeAccountAliasesRequest Payload to remove aliases from account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAliases(customerId: string, accountId: string, removeAccountAliasesRequest: RemoveAccountAliasesRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.removeAliases(customerId, accountId, removeAccountAliasesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an account by id
         * @summary Update an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {UpdateAccountRequest} updateAccountRequest Payload to update account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(customerId: string, accountId: string, updateAccountRequest: UpdateAccountRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.updateAccount(customerId, accountId, updateAccountRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Add Aliases to an account by id
     * @summary Add Aliases to account
     * @param {string} customerId 
     * @param {string} accountId 
     * @param {AddAccountAliasesRequest} addAccountAliasesRequest Payload to add aliases to account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public addAliases(customerId: string, accountId: string, addAccountAliasesRequest: AddAccountAliasesRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).addAliases(customerId, accountId, addAccountAliasesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Associate a plan to an account
     * @summary Associate a plan to an account
     * @param {string} customerId 
     * @param {string} accountId 
     * @param {AssociatePricePlanRequest} associatePricePlanRequest Payload to associate a price plan to an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public associatePricePlan(customerId: string, accountId: string, associatePricePlanRequest: AssociatePricePlanRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).associatePricePlan(customerId, accountId, associatePricePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an account
     * @summary Create an account
     * @param {string} customerId 
     * @param {CreateAccountRequest} createAccountRequest Payload to create account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccount(customerId: string, createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createAccount(customerId, createAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an account by id
     * @summary Delete an account
     * @param {string} customerId 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteAccount(customerId: string, accountId: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).deleteAccount(customerId, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an account
     * @summary Get an account
     * @param {string} customerId 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(customerId: string, accountId: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(customerId, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List accounts with pagination and sort
     * @summary List accounts of customer
     * @param {string} customerId 
     * @param {string} [nextToken] 
     * @param {string} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccounts(customerId: string, nextToken?: string, pageSize?: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccounts(customerId, nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove Aliases to an account by id
     * @summary Remove Aliases to account
     * @param {string} customerId 
     * @param {string} accountId 
     * @param {RemoveAccountAliasesRequest} removeAccountAliasesRequest Payload to remove aliases from account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public removeAliases(customerId: string, accountId: string, removeAccountAliasesRequest: RemoveAccountAliasesRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).removeAliases(customerId, accountId, removeAccountAliasesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an account by id
     * @summary Update an account
     * @param {string} customerId 
     * @param {string} accountId 
     * @param {UpdateAccountRequest} updateAccountRequest Payload to update account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateAccount(customerId: string, accountId: string, updateAccountRequest: UpdateAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updateAccount(customerId, accountId, updateAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomersApi - axios parameter creator
 * @export
 */
export const CustomersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a customer and a default account corresponding to it
         * @summary Create a customer
         * @param {CreateCustomerRequest} createCustomerRequest Payload to create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer: async (createCustomerRequest: CreateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCustomerRequest' is not null or undefined
            assertParamExists('createCustomer', 'createCustomerRequest', createCustomerRequest)
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a customer by id
         * @summary Delete a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer: async (customerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('deleteCustomer', 'customerId', customerId)
            const localVarPath = `/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a customer by id
         * @summary Get a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer: async (customerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getCustomer', 'customerId', customerId)
            const localVarPath = `/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List customers with pagination and sort
         * @summary List customers
         * @param {string} [nextToken] 
         * @param {string} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers: async (nextToken?: string, pageSize?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a customer by id
         * @summary Update a customer
         * @param {string} customerId 
         * @param {UpdateCustomerRequest} updateCustomerRequest Payload to update customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer: async (customerId: string, updateCustomerRequest: UpdateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('updateCustomer', 'customerId', customerId)
            // verify required parameter 'updateCustomerRequest' is not null or undefined
            assertParamExists('updateCustomer', 'updateCustomerRequest', updateCustomerRequest)
            const localVarPath = `/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomersApi - functional programming interface
 * @export
 */
export const CustomersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a customer and a default account corresponding to it
         * @summary Create a customer
         * @param {CreateCustomerRequest} createCustomerRequest Payload to create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomer(createCustomerRequest: CreateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomer(createCustomerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a customer by id
         * @summary Delete a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomer(customerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomer(customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a customer by id
         * @summary Get a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomer(customerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomer(customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List customers with pagination and sort
         * @summary List customers
         * @param {string} [nextToken] 
         * @param {string} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomers(nextToken?: string, pageSize?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomers(nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a customer by id
         * @summary Update a customer
         * @param {string} customerId 
         * @param {UpdateCustomerRequest} updateCustomerRequest Payload to update customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomer(customerId, updateCustomerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomersApi - factory interface
 * @export
 */
export const CustomersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomersApiFp(configuration)
    return {
        /**
         * Create a customer and a default account corresponding to it
         * @summary Create a customer
         * @param {CreateCustomerRequest} createCustomerRequest Payload to create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(createCustomerRequest: CreateCustomerRequest, options?: any): AxiosPromise<CreateCustomerResponse> {
            return localVarFp.createCustomer(createCustomerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a customer by id
         * @summary Delete a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(customerId: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteCustomer(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a customer by id
         * @summary Get a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(customerId: string, options?: any): AxiosPromise<Customer> {
            return localVarFp.getCustomer(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * List customers with pagination and sort
         * @summary List customers
         * @param {string} [nextToken] 
         * @param {string} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers(nextToken?: string, pageSize?: string, options?: any): AxiosPromise<CustomerPaginatedResponse> {
            return localVarFp.getCustomers(nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a customer by id
         * @summary Update a customer
         * @param {string} customerId 
         * @param {UpdateCustomerRequest} updateCustomerRequest Payload to update customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: any): AxiosPromise<Customer> {
            return localVarFp.updateCustomer(customerId, updateCustomerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */
export class CustomersApi extends BaseAPI {
    /**
     * Create a customer and a default account corresponding to it
     * @summary Create a customer
     * @param {CreateCustomerRequest} createCustomerRequest Payload to create customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public createCustomer(createCustomerRequest: CreateCustomerRequest, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).createCustomer(createCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a customer by id
     * @summary Delete a customer
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public deleteCustomer(customerId: string, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).deleteCustomer(customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a customer by id
     * @summary Get a customer
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomer(customerId: string, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getCustomer(customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List customers with pagination and sort
     * @summary List customers
     * @param {string} [nextToken] 
     * @param {string} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomers(nextToken?: string, pageSize?: string, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getCustomers(nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a customer by id
     * @summary Update a customer
     * @param {string} customerId 
     * @param {UpdateCustomerRequest} updateCustomerRequest Payload to update customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).updateCustomer(customerId, updateCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventIngestionApi - axios parameter creator
 * @export
 */
export const EventIngestionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API to ingest your application event to Togai for billing and usage analytics. To know the limits on the ingestion api, check our docs - https://togai.com/docs/limits.
         * @summary Ingest events to Togai
         * @param {IngestEventRequest} ingestEventRequest Request body to ingest events to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingest: async (ingestEventRequest: IngestEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ingestEventRequest' is not null or undefined
            assertParamExists('ingest', 'ingestEventRequest', ingestEventRequest)
            const localVarPath = `/ingest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingestEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API to ingest your application event in batch to Togai for billing and usage analytics. To know the limits on the ingestion api, check our docs - https://togai.com/docs/limits.
         * @summary Ingest events to Togai in batch
         * @param {IngestBatchEventRequest} ingestBatchEventRequest Request body to ingest events in batch to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestBatch: async (ingestBatchEventRequest: IngestBatchEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ingestBatchEventRequest' is not null or undefined
            assertParamExists('ingestBatch', 'ingestBatchEventRequest', ingestBatchEventRequest)
            const localVarPath = `/ingestBatch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingestBatchEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventIngestionApi - functional programming interface
 * @export
 */
export const EventIngestionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventIngestionApiAxiosParamCreator(configuration)
    return {
        /**
         * API to ingest your application event to Togai for billing and usage analytics. To know the limits on the ingestion api, check our docs - https://togai.com/docs/limits.
         * @summary Ingest events to Togai
         * @param {IngestEventRequest} ingestEventRequest Request body to ingest events to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingest(ingestEventRequest: IngestEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingest(ingestEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API to ingest your application event in batch to Togai for billing and usage analytics. To know the limits on the ingestion api, check our docs - https://togai.com/docs/limits.
         * @summary Ingest events to Togai in batch
         * @param {IngestBatchEventRequest} ingestBatchEventRequest Request body to ingest events in batch to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingestBatch(ingestBatchEventRequest: IngestBatchEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngestBatchEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingestBatch(ingestBatchEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventIngestionApi - factory interface
 * @export
 */
export const EventIngestionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventIngestionApiFp(configuration)
    return {
        /**
         * API to ingest your application event to Togai for billing and usage analytics. To know the limits on the ingestion api, check our docs - https://togai.com/docs/limits.
         * @summary Ingest events to Togai
         * @param {IngestEventRequest} ingestEventRequest Request body to ingest events to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingest(ingestEventRequest: IngestEventRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ingest(ingestEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API to ingest your application event in batch to Togai for billing and usage analytics. To know the limits on the ingestion api, check our docs - https://togai.com/docs/limits.
         * @summary Ingest events to Togai in batch
         * @param {IngestBatchEventRequest} ingestBatchEventRequest Request body to ingest events in batch to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestBatch(ingestBatchEventRequest: IngestBatchEventRequest, options?: any): AxiosPromise<IngestBatchEventResponse> {
            return localVarFp.ingestBatch(ingestBatchEventRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventIngestionApi - object-oriented interface
 * @export
 * @class EventIngestionApi
 * @extends {BaseAPI}
 */
export class EventIngestionApi extends BaseAPI {
    /**
     * API to ingest your application event to Togai for billing and usage analytics. To know the limits on the ingestion api, check our docs - https://togai.com/docs/limits.
     * @summary Ingest events to Togai
     * @param {IngestEventRequest} ingestEventRequest Request body to ingest events to Togai usage and billing management service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventIngestionApi
     */
    public ingest(ingestEventRequest: IngestEventRequest, options?: AxiosRequestConfig) {
        return EventIngestionApiFp(this.configuration).ingest(ingestEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API to ingest your application event in batch to Togai for billing and usage analytics. To know the limits on the ingestion api, check our docs - https://togai.com/docs/limits.
     * @summary Ingest events to Togai in batch
     * @param {IngestBatchEventRequest} ingestBatchEventRequest Request body to ingest events in batch to Togai usage and billing management service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventIngestionApi
     */
    public ingestBatch(ingestBatchEventRequest: IngestBatchEventRequest, options?: AxiosRequestConfig) {
        return EventIngestionApiFp(this.configuration).ingestBatch(ingestBatchEventRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventManagementApi - axios parameter creator
 * @export
 */
export const EventManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API to get usage events ingested to Togai.
         * @summary Get usage events from Togai
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter the events by processed/unprocessed status.
         * @param {string} [accountId] Filter option to filter the events based on account id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {number} [startTime] Start time filter in epoch milli seconds
         * @param {number} [endTime] End time filter in epoch milli seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (nextToken?: string, status?: string, accountId?: string, pageSize?: number, startTime?: number, endTime?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API to get the event given the event id.
         * @summary Get the usage event given event id.
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleEvent: async (eventId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getSingleEvent', 'eventId', eventId)
            const localVarPath = `/events/{event_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventManagementApi - functional programming interface
 * @export
 */
export const EventManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * API to get usage events ingested to Togai.
         * @summary Get usage events from Togai
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter the events by processed/unprocessed status.
         * @param {string} [accountId] Filter option to filter the events based on account id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {number} [startTime] Start time filter in epoch milli seconds
         * @param {number} [endTime] End time filter in epoch milli seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(nextToken?: string, status?: string, accountId?: string, pageSize?: number, startTime?: number, endTime?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(nextToken, status, accountId, pageSize, startTime, endTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API to get the event given the event id.
         * @summary Get the usage event given event id.
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleEvent(eventId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleEvent(eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventManagementApi - factory interface
 * @export
 */
export const EventManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventManagementApiFp(configuration)
    return {
        /**
         * API to get usage events ingested to Togai.
         * @summary Get usage events from Togai
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter the events by processed/unprocessed status.
         * @param {string} [accountId] Filter option to filter the events based on account id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {number} [startTime] Start time filter in epoch milli seconds
         * @param {number} [endTime] End time filter in epoch milli seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(nextToken?: string, status?: string, accountId?: string, pageSize?: number, startTime?: number, endTime?: number, options?: any): AxiosPromise<GetEventsResponse> {
            return localVarFp.getEvents(nextToken, status, accountId, pageSize, startTime, endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * API to get the event given the event id.
         * @summary Get the usage event given event id.
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleEvent(eventId: string, options?: any): AxiosPromise<GetEventResponse> {
            return localVarFp.getSingleEvent(eventId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventManagementApi - object-oriented interface
 * @export
 * @class EventManagementApi
 * @extends {BaseAPI}
 */
export class EventManagementApi extends BaseAPI {
    /**
     * API to get usage events ingested to Togai.
     * @summary Get usage events from Togai
     * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
     * @param {string} [status] Filter option to filter the events by processed/unprocessed status.
     * @param {string} [accountId] Filter option to filter the events based on account id.
     * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
     * @param {number} [startTime] Start time filter in epoch milli seconds
     * @param {number} [endTime] End time filter in epoch milli seconds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventManagementApi
     */
    public getEvents(nextToken?: string, status?: string, accountId?: string, pageSize?: number, startTime?: number, endTime?: number, options?: AxiosRequestConfig) {
        return EventManagementApiFp(this.configuration).getEvents(nextToken, status, accountId, pageSize, startTime, endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API to get the event given the event id.
     * @summary Get the usage event given event id.
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventManagementApi
     */
    public getSingleEvent(eventId: string, options?: AxiosRequestConfig) {
        return EventManagementApiFp(this.configuration).getSingleEvent(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate an event schema
         * @summary Activate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateEventSchema: async (eventSchemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('activateEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}/activate`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an event schema
         * @summary Create an event schema
         * @param {CreateEventSchemaRequest} createEventSchemaRequest Payload to create event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSchema: async (createEventSchemaRequest: CreateEventSchemaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEventSchemaRequest' is not null or undefined
            assertParamExists('createEventSchema', 'createEventSchemaRequest', createEventSchemaRequest)
            const localVarPath = `/event_schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventSchemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivate an event schema
         * @summary Deactivate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateEventSchema: async (eventSchemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('deactivateEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}/deactivate`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an event schema
         * @summary Delete an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventSchema: async (eventSchemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('deleteEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an event schema
         * @summary Get an event schema
         * @param {string} eventSchemaName 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSchema: async (eventSchemaName: string, version?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('getEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all event schema versions
         * @summary List all event schema versions
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventSchemaVersions: async (eventSchemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('listEventSchemaVersions', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}/versions`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List event schemas with pagination and sort
         * @summary List event schemas
         * @param {string} [statuses] Filter by provided statuses
         * @param {string} [nextToken] 
         * @param {string} [pageSize] 
         * @param {'ASC' | 'DESC'} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventSchemas: async (statuses?: string, nextToken?: string, pageSize?: string, sortOrder?: 'ASC' | 'DESC', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event_schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (statuses !== undefined) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an event schema
         * @summary Update an event schema
         * @param {string} eventSchemaName 
         * @param {UpdateEventSchemaRequest} updateEventSchemaRequest Payload to update event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventSchema: async (eventSchemaName: string, updateEventSchemaRequest: UpdateEventSchemaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('updateEventSchema', 'eventSchemaName', eventSchemaName)
            // verify required parameter 'updateEventSchemaRequest' is not null or undefined
            assertParamExists('updateEventSchema', 'updateEventSchemaRequest', updateEventSchemaRequest)
            const localVarPath = `/event_schema/{event_schema_name}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventSchemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate an event schema
         * @summary Activate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateEventSchema(eventSchemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateEventSchema(eventSchemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an event schema
         * @summary Create an event schema
         * @param {CreateEventSchemaRequest} createEventSchemaRequest Payload to create event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventSchema(createEventSchemaRequest: CreateEventSchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventSchema(createEventSchemaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deactivate an event schema
         * @summary Deactivate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateEventSchema(eventSchemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateEventSchema(eventSchemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an event schema
         * @summary Delete an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventSchema(eventSchemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventSchema(eventSchemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an event schema
         * @summary Get an event schema
         * @param {string} eventSchemaName 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventSchema(eventSchemaName: string, version?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventSchema(eventSchemaName, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all event schema versions
         * @summary List all event schema versions
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventSchemaVersions(eventSchemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchemaVersionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventSchemaVersions(eventSchemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List event schemas with pagination and sort
         * @summary List event schemas
         * @param {string} [statuses] Filter by provided statuses
         * @param {string} [nextToken] 
         * @param {string} [pageSize] 
         * @param {'ASC' | 'DESC'} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventSchemas(statuses?: string, nextToken?: string, pageSize?: string, sortOrder?: 'ASC' | 'DESC', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchemaListPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventSchemas(statuses, nextToken, pageSize, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an event schema
         * @summary Update an event schema
         * @param {string} eventSchemaName 
         * @param {UpdateEventSchemaRequest} updateEventSchemaRequest Payload to update event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventSchema(eventSchemaName: string, updateEventSchemaRequest: UpdateEventSchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventSchema(eventSchemaName, updateEventSchemaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * Activate an event schema
         * @summary Activate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateEventSchema(eventSchemaName: string, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.activateEventSchema(eventSchemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an event schema
         * @summary Create an event schema
         * @param {CreateEventSchemaRequest} createEventSchemaRequest Payload to create event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSchema(createEventSchemaRequest: CreateEventSchemaRequest, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.createEventSchema(createEventSchemaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivate an event schema
         * @summary Deactivate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateEventSchema(eventSchemaName: string, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.deactivateEventSchema(eventSchemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an event schema
         * @summary Delete an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventSchema(eventSchemaName: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteEventSchema(eventSchemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an event schema
         * @summary Get an event schema
         * @param {string} eventSchemaName 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSchema(eventSchemaName: string, version?: number, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.getEventSchema(eventSchemaName, version, options).then((request) => request(axios, basePath));
        },
        /**
         * List all event schema versions
         * @summary List all event schema versions
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventSchemaVersions(eventSchemaName: string, options?: any): AxiosPromise<EventSchemaVersionsResponse> {
            return localVarFp.listEventSchemaVersions(eventSchemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * List event schemas with pagination and sort
         * @summary List event schemas
         * @param {string} [statuses] Filter by provided statuses
         * @param {string} [nextToken] 
         * @param {string} [pageSize] 
         * @param {'ASC' | 'DESC'} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventSchemas(statuses?: string, nextToken?: string, pageSize?: string, sortOrder?: 'ASC' | 'DESC', options?: any): AxiosPromise<EventSchemaListPaginatedResponse> {
            return localVarFp.listEventSchemas(statuses, nextToken, pageSize, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an event schema
         * @summary Update an event schema
         * @param {string} eventSchemaName 
         * @param {UpdateEventSchemaRequest} updateEventSchemaRequest Payload to update event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventSchema(eventSchemaName: string, updateEventSchemaRequest: UpdateEventSchemaRequest, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.updateEventSchema(eventSchemaName, updateEventSchemaRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * Activate an event schema
     * @summary Activate an event schema
     * @param {string} eventSchemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public activateEventSchema(eventSchemaName: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).activateEventSchema(eventSchemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an event schema
     * @summary Create an event schema
     * @param {CreateEventSchemaRequest} createEventSchemaRequest Payload to create event schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createEventSchema(createEventSchemaRequest: CreateEventSchemaRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).createEventSchema(createEventSchemaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivate an event schema
     * @summary Deactivate an event schema
     * @param {string} eventSchemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deactivateEventSchema(eventSchemaName: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).deactivateEventSchema(eventSchemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an event schema
     * @summary Delete an event schema
     * @param {string} eventSchemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deleteEventSchema(eventSchemaName: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).deleteEventSchema(eventSchemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an event schema
     * @summary Get an event schema
     * @param {string} eventSchemaName 
     * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventSchema(eventSchemaName: string, version?: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEventSchema(eventSchemaName, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all event schema versions
     * @summary List all event schema versions
     * @param {string} eventSchemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public listEventSchemaVersions(eventSchemaName: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).listEventSchemaVersions(eventSchemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List event schemas with pagination and sort
     * @summary List event schemas
     * @param {string} [statuses] Filter by provided statuses
     * @param {string} [nextToken] 
     * @param {string} [pageSize] 
     * @param {'ASC' | 'DESC'} [sortOrder] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public listEventSchemas(statuses?: string, nextToken?: string, pageSize?: string, sortOrder?: 'ASC' | 'DESC', options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).listEventSchemas(statuses, nextToken, pageSize, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an event schema
     * @summary Update an event schema
     * @param {string} eventSchemaName 
     * @param {UpdateEventSchemaRequest} updateEventSchemaRequest Payload to update event schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEventSchema(eventSchemaName: string, updateEventSchemaRequest: UpdateEventSchemaRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateEventSchema(eventSchemaName, updateEventSchemaRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To get the metrics, you make a POST request to the /metrics resource. You can query up to five metrics in a single request. Single response dataset can contain a maximum of 100 data points.
         * @summary Get togai metrics.
         * @param {GetMetricsRequest} [getMetricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics: async (getMetricsRequest?: GetMetricsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getMetricsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * To get the metrics, you make a POST request to the /metrics resource. You can query up to five metrics in a single request. Single response dataset can contain a maximum of 100 data points.
         * @summary Get togai metrics.
         * @param {GetMetricsRequest} [getMetricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetrics(getMetricsRequest?: GetMetricsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetrics(getMetricsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * To get the metrics, you make a POST request to the /metrics resource. You can query up to five metrics in a single request. Single response dataset can contain a maximum of 100 data points.
         * @summary Get togai metrics.
         * @param {GetMetricsRequest} [getMetricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(getMetricsRequest?: GetMetricsRequest, options?: any): AxiosPromise<GetMetricsResponse> {
            return localVarFp.getMetrics(getMetricsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * To get the metrics, you make a POST request to the /metrics resource. You can query up to five metrics in a single request. Single response dataset can contain a maximum of 100 data points.
     * @summary Get togai metrics.
     * @param {GetMetricsRequest} [getMetricsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetrics(getMetricsRequest?: GetMetricsRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getMetrics(getMetricsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PricePlansApi - axios parameter creator
 * @export
 */
export const PricePlansApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate a price plan
         * @summary Activate a price plan
         * @param {string} pricePlanName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePricePlan: async (pricePlanName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanName' is not null or undefined
            assertParamExists('activatePricePlan', 'pricePlanName', pricePlanName)
            const localVarPath = `/price_plans/{price_plan_name}/activate`
                .replace(`{${"price_plan_name"}}`, encodeURIComponent(String(pricePlanName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a price plan
         * @summary Create a price plan
         * @param {CreatePricePlanRequest} createPricePlanRequest Payload to create price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPricePlan: async (createPricePlanRequest: CreatePricePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPricePlanRequest' is not null or undefined
            assertParamExists('createPricePlan', 'createPricePlanRequest', createPricePlanRequest)
            const localVarPath = `/price_plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a price plan
         * @summary Get a price plan
         * @param {string} pricePlanName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricePlan: async (pricePlanName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanName' is not null or undefined
            assertParamExists('getPricePlan', 'pricePlanName', pricePlanName)
            const localVarPath = `/price_plans/{price_plan_name}`
                .replace(`{${"price_plan_name"}}`, encodeURIComponent(String(pricePlanName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List price plans with pagination and sort
         * @summary List price plans
         * @param {string} [nextToken] 
         * @param {string} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricePlans: async (nextToken?: string, pageSize?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/price_plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a price plan
         * @summary Update a price plan
         * @param {string} pricePlanName 
         * @param {UpdatePricePlanRequest} updatePricePlanRequest Payload to update price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricePlan: async (pricePlanName: string, updatePricePlanRequest: UpdatePricePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanName' is not null or undefined
            assertParamExists('updatePricePlan', 'pricePlanName', pricePlanName)
            // verify required parameter 'updatePricePlanRequest' is not null or undefined
            assertParamExists('updatePricePlan', 'updatePricePlanRequest', updatePricePlanRequest)
            const localVarPath = `/price_plans/{price_plan_name}`
                .replace(`{${"price_plan_name"}}`, encodeURIComponent(String(pricePlanName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PricePlansApi - functional programming interface
 * @export
 */
export const PricePlansApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PricePlansApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate a price plan
         * @summary Activate a price plan
         * @param {string} pricePlanName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activatePricePlan(pricePlanName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activatePricePlan(pricePlanName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a price plan
         * @summary Create a price plan
         * @param {CreatePricePlanRequest} createPricePlanRequest Payload to create price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPricePlan(createPricePlanRequest: CreatePricePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPricePlan(createPricePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a price plan
         * @summary Get a price plan
         * @param {string} pricePlanName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricePlan(pricePlanName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricePlan(pricePlanName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List price plans with pagination and sort
         * @summary List price plans
         * @param {string} [nextToken] 
         * @param {string} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricePlans(nextToken?: string, pageSize?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlanPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricePlans(nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a price plan
         * @summary Update a price plan
         * @param {string} pricePlanName 
         * @param {UpdatePricePlanRequest} updatePricePlanRequest Payload to update price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePricePlan(pricePlanName: string, updatePricePlanRequest: UpdatePricePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePricePlan(pricePlanName, updatePricePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PricePlansApi - factory interface
 * @export
 */
export const PricePlansApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PricePlansApiFp(configuration)
    return {
        /**
         * Activate a price plan
         * @summary Activate a price plan
         * @param {string} pricePlanName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePricePlan(pricePlanName: string, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.activatePricePlan(pricePlanName, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a price plan
         * @summary Create a price plan
         * @param {CreatePricePlanRequest} createPricePlanRequest Payload to create price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPricePlan(createPricePlanRequest: CreatePricePlanRequest, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.createPricePlan(createPricePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a price plan
         * @summary Get a price plan
         * @param {string} pricePlanName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricePlan(pricePlanName: string, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.getPricePlan(pricePlanName, options).then((request) => request(axios, basePath));
        },
        /**
         * List price plans with pagination and sort
         * @summary List price plans
         * @param {string} [nextToken] 
         * @param {string} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricePlans(nextToken?: string, pageSize?: string, options?: any): AxiosPromise<PricePlanPaginatedResponse> {
            return localVarFp.getPricePlans(nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a price plan
         * @summary Update a price plan
         * @param {string} pricePlanName 
         * @param {UpdatePricePlanRequest} updatePricePlanRequest Payload to update price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricePlan(pricePlanName: string, updatePricePlanRequest: UpdatePricePlanRequest, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.updatePricePlan(pricePlanName, updatePricePlanRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PricePlansApi - object-oriented interface
 * @export
 * @class PricePlansApi
 * @extends {BaseAPI}
 */
export class PricePlansApi extends BaseAPI {
    /**
     * Activate a price plan
     * @summary Activate a price plan
     * @param {string} pricePlanName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public activatePricePlan(pricePlanName: string, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).activatePricePlan(pricePlanName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a price plan
     * @summary Create a price plan
     * @param {CreatePricePlanRequest} createPricePlanRequest Payload to create price plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public createPricePlan(createPricePlanRequest: CreatePricePlanRequest, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).createPricePlan(createPricePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a price plan
     * @summary Get a price plan
     * @param {string} pricePlanName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public getPricePlan(pricePlanName: string, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).getPricePlan(pricePlanName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List price plans with pagination and sort
     * @summary List price plans
     * @param {string} [nextToken] 
     * @param {string} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public getPricePlans(nextToken?: string, pageSize?: string, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).getPricePlans(nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a price plan
     * @summary Update a price plan
     * @param {string} pricePlanName 
     * @param {UpdatePricePlanRequest} updatePricePlanRequest Payload to update price plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public updatePricePlan(pricePlanName: string, updatePricePlanRequest: UpdatePricePlanRequest, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).updatePricePlan(pricePlanName, updatePricePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsageMetersApi - axios parameter creator
 * @export
 */
export const UsageMetersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate usage meter
         * @summary Activate usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUsageMeter: async (eventSchemaName: string, usageMeterName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('activateUsageMeter', 'eventSchemaName', eventSchemaName)
            // verify required parameter 'usageMeterName' is not null or undefined
            assertParamExists('activateUsageMeter', 'usageMeterName', usageMeterName)
            const localVarPath = `/event_schema/{event_schema_name}/usage_meters/{usage_meter_name}/activate`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)))
                .replace(`{${"usage_meter_name"}}`, encodeURIComponent(String(usageMeterName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an usage meter
         * @summary Create an usage meter
         * @param {string} eventSchemaName 
         * @param {CreateUsageMeterRequest} createUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsageMeter: async (eventSchemaName: string, createUsageMeterRequest: CreateUsageMeterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('createUsageMeter', 'eventSchemaName', eventSchemaName)
            // verify required parameter 'createUsageMeterRequest' is not null or undefined
            assertParamExists('createUsageMeter', 'createUsageMeterRequest', createUsageMeterRequest)
            const localVarPath = `/event_schema/{event_schema_name}/usage_meters`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUsageMeterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivate usage meter
         * @summary Deactivate usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUsageMeter: async (eventSchemaName: string, usageMeterName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('deactivateUsageMeter', 'eventSchemaName', eventSchemaName)
            // verify required parameter 'usageMeterName' is not null or undefined
            assertParamExists('deactivateUsageMeter', 'usageMeterName', usageMeterName)
            const localVarPath = `/event_schema/{event_schema_name}/usage_meters/{usage_meter_name}/deactivate`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)))
                .replace(`{${"usage_meter_name"}}`, encodeURIComponent(String(usageMeterName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an Usage Meter
         * @summary Delete an Usage Meter
         * @param {string} usageMeterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsageMeter: async (usageMeterName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usageMeterName' is not null or undefined
            assertParamExists('deleteUsageMeter', 'usageMeterName', usageMeterName)
            const localVarPath = `/usage_meter/{usage_meter_name}`
                .replace(`{${"usage_meter_name"}}`, encodeURIComponent(String(usageMeterName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get usage meter
         * @summary Get usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMeter: async (eventSchemaName: string, usageMeterName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('getUsageMeter', 'eventSchemaName', eventSchemaName)
            // verify required parameter 'usageMeterName' is not null or undefined
            assertParamExists('getUsageMeter', 'usageMeterName', usageMeterName)
            const localVarPath = `/event_schema/{event_schema_name}/usage_meters/{usage_meter_name}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)))
                .replace(`{${"usage_meter_name"}}`, encodeURIComponent(String(usageMeterName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List usage meters for event schema with pagination and sort
         * @summary List usage meters for event schema
         * @param {string} eventSchemaName 
         * @param {string} [statuses] Filter by provided statuses
         * @param {string} [aggregations] Filter by provided aggregations
         * @param {string} [nextToken] 
         * @param {string} [pageSize] 
         * @param {'ASC' | 'DESC'} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMetersForEventSchema: async (eventSchemaName: string, statuses?: string, aggregations?: string, nextToken?: string, pageSize?: string, sortOrder?: 'ASC' | 'DESC', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('getUsageMetersForEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}/usage_meters`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (statuses !== undefined) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (aggregations !== undefined) {
                localVarQueryParameter['aggregations'] = aggregations;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an usage meter
         * @summary Update an usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterName 
         * @param {UpdateUsageMeterRequest} updateUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsageMeter: async (eventSchemaName: string, usageMeterName: string, updateUsageMeterRequest: UpdateUsageMeterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('updateUsageMeter', 'eventSchemaName', eventSchemaName)
            // verify required parameter 'usageMeterName' is not null or undefined
            assertParamExists('updateUsageMeter', 'usageMeterName', usageMeterName)
            // verify required parameter 'updateUsageMeterRequest' is not null or undefined
            assertParamExists('updateUsageMeter', 'updateUsageMeterRequest', updateUsageMeterRequest)
            const localVarPath = `/event_schema/{event_schema_name}/usage_meters/{usage_meter_name}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)))
                .replace(`{${"usage_meter_name"}}`, encodeURIComponent(String(usageMeterName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUsageMeterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsageMetersApi - functional programming interface
 * @export
 */
export const UsageMetersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsageMetersApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate usage meter
         * @summary Activate usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateUsageMeter(eventSchemaName: string, usageMeterName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateUsageMeter(eventSchemaName, usageMeterName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an usage meter
         * @summary Create an usage meter
         * @param {string} eventSchemaName 
         * @param {CreateUsageMeterRequest} createUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUsageMeter(eventSchemaName: string, createUsageMeterRequest: CreateUsageMeterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUsageMeter(eventSchemaName, createUsageMeterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deactivate usage meter
         * @summary Deactivate usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateUsageMeter(eventSchemaName: string, usageMeterName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateUsageMeter(eventSchemaName, usageMeterName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an Usage Meter
         * @summary Delete an Usage Meter
         * @param {string} usageMeterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsageMeter(usageMeterName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUsageMeter(usageMeterName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get usage meter
         * @summary Get usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsageMeter(eventSchemaName: string, usageMeterName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageMeter(eventSchemaName, usageMeterName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List usage meters for event schema with pagination and sort
         * @summary List usage meters for event schema
         * @param {string} eventSchemaName 
         * @param {string} [statuses] Filter by provided statuses
         * @param {string} [aggregations] Filter by provided aggregations
         * @param {string} [nextToken] 
         * @param {string} [pageSize] 
         * @param {'ASC' | 'DESC'} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsageMetersForEventSchema(eventSchemaName: string, statuses?: string, aggregations?: string, nextToken?: string, pageSize?: string, sortOrder?: 'ASC' | 'DESC', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeterPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageMetersForEventSchema(eventSchemaName, statuses, aggregations, nextToken, pageSize, sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an usage meter
         * @summary Update an usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterName 
         * @param {UpdateUsageMeterRequest} updateUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUsageMeter(eventSchemaName: string, usageMeterName: string, updateUsageMeterRequest: UpdateUsageMeterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUsageMeter(eventSchemaName, usageMeterName, updateUsageMeterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsageMetersApi - factory interface
 * @export
 */
export const UsageMetersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsageMetersApiFp(configuration)
    return {
        /**
         * Activate usage meter
         * @summary Activate usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUsageMeter(eventSchemaName: string, usageMeterName: string, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.activateUsageMeter(eventSchemaName, usageMeterName, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an usage meter
         * @summary Create an usage meter
         * @param {string} eventSchemaName 
         * @param {CreateUsageMeterRequest} createUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsageMeter(eventSchemaName: string, createUsageMeterRequest: CreateUsageMeterRequest, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.createUsageMeter(eventSchemaName, createUsageMeterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivate usage meter
         * @summary Deactivate usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUsageMeter(eventSchemaName: string, usageMeterName: string, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.deactivateUsageMeter(eventSchemaName, usageMeterName, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an Usage Meter
         * @summary Delete an Usage Meter
         * @param {string} usageMeterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsageMeter(usageMeterName: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteUsageMeter(usageMeterName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get usage meter
         * @summary Get usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMeter(eventSchemaName: string, usageMeterName: string, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.getUsageMeter(eventSchemaName, usageMeterName, options).then((request) => request(axios, basePath));
        },
        /**
         * List usage meters for event schema with pagination and sort
         * @summary List usage meters for event schema
         * @param {string} eventSchemaName 
         * @param {string} [statuses] Filter by provided statuses
         * @param {string} [aggregations] Filter by provided aggregations
         * @param {string} [nextToken] 
         * @param {string} [pageSize] 
         * @param {'ASC' | 'DESC'} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMetersForEventSchema(eventSchemaName: string, statuses?: string, aggregations?: string, nextToken?: string, pageSize?: string, sortOrder?: 'ASC' | 'DESC', options?: any): AxiosPromise<UsageMeterPaginatedResponse> {
            return localVarFp.getUsageMetersForEventSchema(eventSchemaName, statuses, aggregations, nextToken, pageSize, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an usage meter
         * @summary Update an usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterName 
         * @param {UpdateUsageMeterRequest} updateUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsageMeter(eventSchemaName: string, usageMeterName: string, updateUsageMeterRequest: UpdateUsageMeterRequest, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.updateUsageMeter(eventSchemaName, usageMeterName, updateUsageMeterRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsageMetersApi - object-oriented interface
 * @export
 * @class UsageMetersApi
 * @extends {BaseAPI}
 */
export class UsageMetersApi extends BaseAPI {
    /**
     * Activate usage meter
     * @summary Activate usage meter
     * @param {string} eventSchemaName 
     * @param {string} usageMeterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public activateUsageMeter(eventSchemaName: string, usageMeterName: string, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).activateUsageMeter(eventSchemaName, usageMeterName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an usage meter
     * @summary Create an usage meter
     * @param {string} eventSchemaName 
     * @param {CreateUsageMeterRequest} createUsageMeterRequest Payload to create usage meter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public createUsageMeter(eventSchemaName: string, createUsageMeterRequest: CreateUsageMeterRequest, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).createUsageMeter(eventSchemaName, createUsageMeterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivate usage meter
     * @summary Deactivate usage meter
     * @param {string} eventSchemaName 
     * @param {string} usageMeterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public deactivateUsageMeter(eventSchemaName: string, usageMeterName: string, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).deactivateUsageMeter(eventSchemaName, usageMeterName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an Usage Meter
     * @summary Delete an Usage Meter
     * @param {string} usageMeterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public deleteUsageMeter(usageMeterName: string, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).deleteUsageMeter(usageMeterName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get usage meter
     * @summary Get usage meter
     * @param {string} eventSchemaName 
     * @param {string} usageMeterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public getUsageMeter(eventSchemaName: string, usageMeterName: string, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).getUsageMeter(eventSchemaName, usageMeterName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List usage meters for event schema with pagination and sort
     * @summary List usage meters for event schema
     * @param {string} eventSchemaName 
     * @param {string} [statuses] Filter by provided statuses
     * @param {string} [aggregations] Filter by provided aggregations
     * @param {string} [nextToken] 
     * @param {string} [pageSize] 
     * @param {'ASC' | 'DESC'} [sortOrder] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public getUsageMetersForEventSchema(eventSchemaName: string, statuses?: string, aggregations?: string, nextToken?: string, pageSize?: string, sortOrder?: 'ASC' | 'DESC', options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).getUsageMetersForEventSchema(eventSchemaName, statuses, aggregations, nextToken, pageSize, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an usage meter
     * @summary Update an usage meter
     * @param {string} eventSchemaName 
     * @param {string} usageMeterName 
     * @param {UpdateUsageMeterRequest} updateUsageMeterRequest Payload to create usage meter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public updateUsageMeter(eventSchemaName: string, usageMeterName: string, updateUsageMeterRequest: UpdateUsageMeterRequest, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).updateUsageMeter(eventSchemaName, usageMeterName, updateUsageMeterRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


