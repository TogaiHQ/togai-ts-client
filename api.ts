/* tslint:disable */
/* eslint-disable */
/**
 * Togai Apis
 * APIs for Togai App
 *
 * The version of the OpenAPI document: 1.0
 * Contact: engg@togai.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * Structure of an account
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * Identifier of the account
     * @type {string}
     * @memberof Account
     */
    'id': string;
    /**
     * Unique identifier of the account
     * @type {string}
     * @memberof Account
     */
    'togaiAccountId': string;
    /**
     * Unique identifier of the customer
     * @type {string}
     * @memberof Account
     */
    'togaiCustomerId': string;
    /**
     * Name of the Account
     * @type {string}
     * @memberof Account
     */
    'name': string;
    /**
     * Identifier of the customer
     * @type {string}
     * @memberof Account
     */
    'customerId': string;
    /**
     * [ISO_4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency in which the account must be invoiced Defaults to Base currency. 
     * @type {string}
     * @memberof Account
     */
    'invoiceCurrency'?: string;
    /**
     * list of aliases of the account
     * @type {Array<AccountAliases>}
     * @memberof Account
     */
    'aliases'?: Array<AccountAliases>;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'netTermDays'?: number;
    /**
     * 
     * @type {Address}
     * @memberof Account
     */
    'address'?: Address;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof Account
     */
    'primaryEmail'?: string;
    /**
     * Status of the account
     * @type {string}
     * @memberof Account
     */
    'status': AccountStatusEnum;
    /**
     * 
     * @type {Array<CreateEntitySetting>}
     * @memberof Account
     */
    'settings'?: Array<CreateEntitySetting>;
    /**
     * 
     * @type {InvoiceGroupDetails}
     * @memberof Account
     */
    'invoiceGroupDetails'?: InvoiceGroupDetails;
    /**
     * Additional information associated with the account. Example: GSTN, VATN 
     * @type {{ [key: string]: string; }}
     * @memberof Account
     */
    'metadata'?: { [key: string]: string; };
    /**
     * Tag for accounts are stored in lowercase
     * @type {Array<string>}
     * @memberof Account
     */
    'tags'?: Array<string>;
}

export const AccountStatusEnum = {
    Active: 'ACTIVE',
    Draft: 'DRAFT',
    Archived: 'ARCHIVED'
} as const;

export type AccountStatusEnum = typeof AccountStatusEnum[keyof typeof AccountStatusEnum];

/**
 * Account Alias
 * @export
 * @interface AccountAlias
 */
export interface AccountAlias {
    /**
     * Alias identifier (UUID)
     * @type {string}
     * @memberof AccountAlias
     */
    'id': string;
    /**
     * Alias value
     * @type {string}
     * @memberof AccountAlias
     */
    'value': string;
    /**
     * Effective from date
     * @type {string}
     * @memberof AccountAlias
     */
    'effectiveFrom': string;
    /**
     * Effective until date
     * @type {string}
     * @memberof AccountAlias
     */
    'effectiveUntil': string;
    /**
     * Alias creation date
     * @type {string}
     * @memberof AccountAlias
     */
    'createdAt': string;
    /**
     * Alias update date
     * @type {string}
     * @memberof AccountAlias
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface AccountAliases
 */
export interface AccountAliases {
    /**
     * 
     * @type {string}
     * @memberof AccountAliases
     */
    'alias'?: string;
}
/**
 * Paginated response for account aliases
 * @export
 * @interface AccountAliasesPaginatedResponse
 */
export interface AccountAliasesPaginatedResponse {
    /**
     * 
     * @type {Array<AccountAlias>}
     * @memberof AccountAliasesPaginatedResponse
     */
    'data': Array<AccountAlias>;
    /**
     * 
     * @type {string}
     * @memberof AccountAliasesPaginatedResponse
     */
    'nextToken'?: string;
}
/**
 * 
 * @export
 * @interface AccountPaginatedResponse
 */
export interface AccountPaginatedResponse {
    /**
     * 
     * @type {Array<Account>}
     * @memberof AccountPaginatedResponse
     */
    'data'?: Array<Account>;
    /**
     * 
     * @type {string}
     * @memberof AccountPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof AccountPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * Request to activate currencies of a price plan
 * @export
 * @interface ActivatePricePlanRequest
 */
export interface ActivatePricePlanRequest {
    /**
     * List of currencies to activate
     * @type {Array<string>}
     * @memberof ActivatePricePlanRequest
     */
    'currencies': Array<string>;
}
/**
 * Payload to add aliases from account
 * @export
 * @interface AddAccountAliasesRequest
 */
export interface AddAccountAliasesRequest {
    /**
     * List of aliases to add
     * @type {Array<string>}
     * @memberof AddAccountAliasesRequest
     */
    'aliases'?: Array<string>;
    /**
     * List of account aliases to add
     * @type {Array<CreateAccountAliasRequest>}
     * @memberof AddAccountAliasesRequest
     */
    'accountAliases'?: Array<CreateAccountAliasRequest>;
}
/**
 * Request to adding currency to a price plan
 * @export
 * @interface AddCurrencyToPricePlanRequest
 */
export interface AddCurrencyToPricePlanRequest {
    /**
     * Currency to be added
     * @type {string}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'currency': string;
    /**
     * List of usage rates
     * @type {Array<UsageRate>}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'usageRates'?: Array<UsageRate>;
    /**
     * Rates for fixed fee rate cards
     * @type {Array<FixedFeeRate>}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'fixedFeeRates'?: Array<FixedFeeRate>;
    /**
     * Rates for license rate cards
     * @type {Array<LicenseRate>}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'licenseRates'?: Array<LicenseRate>;
    /**
     * Rates for billing entitlement rate cards
     * @type {Array<BillingEntitlementRate>}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'billingEntitlementRates'?: Array<BillingEntitlementRate>;
    /**
     * Rates for minimum commitment.
     * @type {number}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'minimumCommitmentRate'?: number;
    /**
     * Rates for credit grant rate card
     * @type {Array<CreditGrantRates>}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'creditGrantRates'?: Array<CreditGrantRates>;
    /**
     * Rates for entitlement overage rate cards
     * @type {Array<EntitlementOverageRates>}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'entitlementOverageRates'?: Array<EntitlementOverageRates>;
}
/**
 * 
 * @export
 * @interface AddOn
 */
export interface AddOn {
    /**
     * Name of addon
     * @type {string}
     * @memberof AddOn
     */
    'name': string;
    /**
     * 
     * @type {AddOnType}
     * @memberof AddOn
     */
    'type': AddOnType;
    /**
     * Billable name of addon. Billable name takes precedence over name to display in invoice.
     * @type {string}
     * @memberof AddOn
     */
    'billableName'?: string;
    /**
     * Id of addon
     * @type {string}
     * @memberof AddOn
     */
    'id': string;
    /**
     * Created Time of addon
     * @type {string}
     * @memberof AddOn
     */
    'createdAt': string;
    /**
     * status of addon
     * @type {string}
     * @memberof AddOn
     */
    'status': AddOnStatusEnum;
    /**
     * Display name of addon. This is an auto-generated field which contains billableName of addon. If billableName is not provided, name will be used as display name. 
     * @type {string}
     * @memberof AddOn
     */
    'displayName': string;
}

export const AddOnStatusEnum = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type AddOnStatusEnum = typeof AddOnStatusEnum[keyof typeof AddOnStatusEnum];

/**
 * 
 * @export
 * @interface AddOnAllOf
 */
export interface AddOnAllOf {
    /**
     * Id of addon
     * @type {string}
     * @memberof AddOnAllOf
     */
    'id': string;
    /**
     * Created Time of addon
     * @type {string}
     * @memberof AddOnAllOf
     */
    'createdAt': string;
    /**
     * status of addon
     * @type {string}
     * @memberof AddOnAllOf
     */
    'status': AddOnAllOfStatusEnum;
    /**
     * Display name of addon. This is an auto-generated field which contains billableName of addon. If billableName is not provided, name will be used as display name. 
     * @type {string}
     * @memberof AddOnAllOf
     */
    'displayName': string;
}

export const AddOnAllOfStatusEnum = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type AddOnAllOfStatusEnum = typeof AddOnAllOfStatusEnum[keyof typeof AddOnAllOfStatusEnum];

/**
 * 
 * @export
 * @interface AddOnPaginatedResponse
 */
export interface AddOnPaginatedResponse {
    /**
     * 
     * @type {Array<AddOn>}
     * @memberof AddOnPaginatedResponse
     */
    'data': Array<AddOn>;
    /**
     * 
     * @type {string}
     * @memberof AddOnPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof AddOnPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * LICENSE: Addon can be used in license rate cards FIXED_FEE: Addon can be used in fixed fee rate cards CREDIT_GRANT: Addon can be used in credit grant rate cards NAMED_LICENSE: Addon can be used in license rate cards 
 * @export
 * @enum {string}
 */

export const AddOnType = {
    License: 'LICENSE',
    FixedFee: 'FIXED_FEE',
    CreditGrant: 'CREDIT_GRANT',
    NamedLicense: 'NAMED_LICENSE'
} as const;

export type AddOnType = typeof AddOnType[keyof typeof AddOnType];


/**
 * billing address of the customer
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * Contact number
     * @type {string}
     * @memberof Address
     */
    'phoneNumber'?: string;
    /**
     * Address line 1 (eg. Street, PO Box, Company Name)
     * @type {string}
     * @memberof Address
     */
    'line1'?: string;
    /**
     * Address line 2 (eg. apartment, suite, unit or building)
     * @type {string}
     * @memberof Address
     */
    'line2'?: string;
    /**
     * ZIP or postal code
     * @type {string}
     * @memberof Address
     */
    'postalCode'?: string;
    /**
     * City, district, suburb, town or village
     * @type {string}
     * @memberof Address
     */
    'city'?: string;
    /**
     * State, county, province or region
     * @type {string}
     * @memberof Address
     */
    'state'?: string;
    /**
     * Two letter country code [ISO-3166-1 Alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
     * @type {string}
     * @memberof Address
     */
    'country'?: string;
}
/**
 * Represents an Alias
 * @export
 * @interface Alias
 */
export interface Alias {
    /**
     * 
     * @type {string}
     * @memberof Alias
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof Alias
     */
    'createdAt': string;
}
/**
 * Represents for list response of alias
 * @export
 * @interface AliasPaginatedResponse
 */
export interface AliasPaginatedResponse {
    /**
     * 
     * @type {Array<Alias>}
     * @memberof AliasPaginatedResponse
     */
    'data'?: Array<Alias>;
    /**
     * 
     * @type {string}
     * @memberof AliasPaginatedResponse
     */
    'nextToken'?: string;
}
/**
 * Metric to be recorded
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * Name of the event attribute
     * @type {string}
     * @memberof Attribute
     */
    'name': string;
    /**
     * Value of the event attribute
     * @type {string}
     * @memberof Attribute
     */
    'value': string;
    /**
     * Unit with which the attribute value was measured. Natively supported units - \"Meters, Miles, Kilometers, Grams, Kilograms, ounces, Pounds, Minutes, Hours, Seconds, Milliseconds, Microseconds, None\". Clients are free to add any other custom units.
     * @type {string}
     * @memberof Attribute
     */
    'unit'?: string;
}
/**
 * 
 * @export
 * @interface BaseSuccessResponse
 */
export interface BaseSuccessResponse {
    /**
     * 
     * @type {boolean}
     * @memberof BaseSuccessResponse
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface BillingConfig
 */
export interface BillingConfig {
    /**
     * Represents the number of pricing cycles after which the rate card will be billed
     * @type {number}
     * @memberof BillingConfig
     */
    'interval'?: number;
    /**
     * Represents the offset for pricing cycles after which the rate card will be billed
     * @type {number}
     * @memberof BillingConfig
     */
    'startOffset'?: number;
}
/**
 * 
 * @export
 * @interface BillingEntitlementRate
 */
export interface BillingEntitlementRate {
    /**
     * 
     * @type {string}
     * @memberof BillingEntitlementRate
     */
    'id': string;
    /**
     * List of slab rates
     * @type {Array<SlabRate>}
     * @memberof BillingEntitlementRate
     */
    'slabRates': Array<SlabRate>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BillingEntitlementRate
     */
    'rateConfig'?: { [key: string]: string; };
}
/**
 * Billing Entitlement rate card
 * @export
 * @interface BillingEntitlementRateCard
 */
export interface BillingEntitlementRateCard {
    /**
     * 
     * @type {string}
     * @memberof BillingEntitlementRateCard
     */
    'featureId': string;
    /**
     * 
     * @type {Array<FeatureConfig>}
     * @memberof BillingEntitlementRateCard
     */
    'featureConfigs': Array<FeatureConfig>;
    /**
     * A tag string to group rate cards
     * @type {string}
     * @memberof BillingEntitlementRateCard
     */
    'tag'?: string;
    /**
     * 
     * @type {InvoiceTiming}
     * @memberof BillingEntitlementRateCard
     */
    'invoiceTiming': InvoiceTiming;
    /**
     * Name your rate card, this will be used in invoice
     * @type {string}
     * @memberof BillingEntitlementRateCard
     */
    'displayName'?: string;
    /**
     * 
     * @type {RatePlan}
     * @memberof BillingEntitlementRateCard
     */
    'ratePlan': RatePlan;
    /**
     * 
     * @type {Array<RateValue>}
     * @memberof BillingEntitlementRateCard
     */
    'rateValues': Array<RateValue>;
    /**
     * 
     * @type {RecurrenceConfig}
     * @memberof BillingEntitlementRateCard
     */
    'recurrenceConfig'?: RecurrenceConfig;
}


/**
 * 
 * @export
 * @interface BillingEntitlementRevenueSummary
 */
export interface BillingEntitlementRevenueSummary {
    /**
     * 
     * @type {number}
     * @memberof BillingEntitlementRevenueSummary
     */
    'revenue': number;
}
/**
 * Request to get revenue details
 * @export
 * @interface CalculateRevenueRequest
 */
export interface CalculateRevenueRequest {
    /**
     * 
     * @type {CurrencyConfig}
     * @memberof CalculateRevenueRequest
     */
    'currencyConfig': CurrencyConfig;
    /**
     * 
     * @type {PricePlanDetailsConfig}
     * @memberof CalculateRevenueRequest
     */
    'pricePlanDetailsConfig': PricePlanDetailsConfig;
    /**
     * 
     * @type {UsageConfig}
     * @memberof CalculateRevenueRequest
     */
    'usageConfig': UsageConfig;
    /**
     * 
     * @type {LicenseEntriesConfig}
     * @memberof CalculateRevenueRequest
     */
    'licenseEntriesConfig': LicenseEntriesConfig;
    /**
     * 
     * @type {NamedLicenseEntriesConfig}
     * @memberof CalculateRevenueRequest
     */
    'namedLicenseEntriesConfig'?: NamedLicenseEntriesConfig;
    /**
     * 
     * @type {ProrationConfig}
     * @memberof CalculateRevenueRequest
     */
    'prorationConfig'?: ProrationConfig;
    /**
     * 
     * @type {EntitlementOverageConfig}
     * @memberof CalculateRevenueRequest
     */
    'entitlementOverageConfig'?: EntitlementOverageConfig;
}
/**
 * 
 * @export
 * @interface CalculateRevenueResponse
 */
export interface CalculateRevenueResponse {
    /**
     * 
     * @type {string}
     * @memberof CalculateRevenueResponse
     */
    'currency': string;
    /**
     * 
     * @type {UsageLookupRange}
     * @memberof CalculateRevenueResponse
     */
    'usageLookupRange'?: UsageLookupRange;
    /**
     * 
     * @type {PricePlanDetails}
     * @memberof CalculateRevenueResponse
     */
    'pricePlanDetails': PricePlanDetails;
    /**
     * 
     * @type {Array<RevenueInfo>}
     * @memberof CalculateRevenueResponse
     */
    'revenueInfo': Array<RevenueInfo>;
}
/**
 * 
 * @export
 * @interface Computation
 */
export interface Computation {
    /**
     * Optional identifier describing the matcher and computation pair
     * @type {string}
     * @memberof Computation
     */
    'id'?: string;
    /**
     * Condition to be applied on event. Upon matching it the corresponding computation will be considered for usage_meter unit calculation. The result of the matcher needs to be [truthy](https://jsonlogic.com/truthy.html) in order to be considered as a match. 
     * @type {string}
     * @memberof Computation
     */
    'matcher'?: string;
    /**
     * Computation to be applied on an event if it matches the matcher. In case of a COUNT aggregation type, computation should be passed as \'1\' 
     * @type {string}
     * @memberof Computation
     */
    'computation': string;
    /**
     * The order in which multiple matched computations will get evaluated
     * @type {number}
     * @memberof Computation
     */
    'order': number;
}
/**
 * An alternative account identifier for event ingestion with a defined effective duration.
 * @export
 * @interface CreateAccountAliasRequest
 */
export interface CreateAccountAliasRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAccountAliasRequest
     */
    'value': string;
    /**
     * Effective from date, if not provided, it will be set to -infinity
     * @type {string}
     * @memberof CreateAccountAliasRequest
     */
    'effectiveFrom'?: string;
    /**
     * Effective until date, if not provided, it will be set to +infinity
     * @type {string}
     * @memberof CreateAccountAliasRequest
     */
    'effectiveUntil'?: string;
}
/**
 * Payload to create account
 * @export
 * @interface CreateAccountRequest
 */
export interface CreateAccountRequest {
    /**
     * Identifier of the account
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'id': string;
    /**
     * Name of the Account
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'name': string;
    /**
     * Use [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code in which the account must be invoiced.   For example: AED is the currency code for United Arab Emirates dirham. 
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'invoiceCurrency'?: string;
    /**
     * Aliases are tags that are associated with an account. Multiple aliases are allowed for a single account.
     * @type {Array<string>}
     * @memberof CreateAccountRequest
     */
    'aliases'?: Array<string>;
    /**
     * Aliases which effective range
     * @type {Array<CreateAccountAliasRequest>}
     * @memberof CreateAccountRequest
     */
    'accountAliases'?: Array<CreateAccountAliasRequest>;
    /**
     * 
     * @type {Address}
     * @memberof CreateAccountRequest
     */
    'address'?: Address;
    /**
     * Primary email of the account
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'primaryEmail'?: string;
    /**
     * 
     * @type {Array<CreateEntitySetting>}
     * @memberof CreateAccountRequest
     */
    'settings'?: Array<CreateEntitySetting>;
    /**
     * Net term for the invoices of the account
     * @type {number}
     * @memberof CreateAccountRequest
     */
    'netTermDays'?: number;
    /**
     * Additional information associated with the account. Example: GSTN, VATN 
     * @type {{ [key: string]: string; }}
     * @memberof CreateAccountRequest
     */
    'metadata'?: { [key: string]: string; };
    /**
     * Tag for accounts are stored in lowercase
     * @type {Array<string>}
     * @memberof CreateAccountRequest
     */
    'tags'?: Array<string>;
    /**
     * Status of the created account defaults to ACTIVE
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'status'?: CreateAccountRequestStatusEnum;
    /**
     * Customer Identifier for whom the account is being created
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'customerId': string;
}

export const CreateAccountRequestStatusEnum = {
    Active: 'ACTIVE',
    Draft: 'DRAFT'
} as const;

export type CreateAccountRequestStatusEnum = typeof CreateAccountRequestStatusEnum[keyof typeof CreateAccountRequestStatusEnum];

/**
 * 
 * @export
 * @interface CreateAccountRequestAllOf
 */
export interface CreateAccountRequestAllOf {
    /**
     * Customer Identifier for whom the account is being created
     * @type {string}
     * @memberof CreateAccountRequestAllOf
     */
    'customerId': string;
}
/**
 * Payload to create account
 * @export
 * @interface CreateAccountRequestWithoutCustomerId
 */
export interface CreateAccountRequestWithoutCustomerId {
    /**
     * Identifier of the account
     * @type {string}
     * @memberof CreateAccountRequestWithoutCustomerId
     */
    'id': string;
    /**
     * Name of the Account
     * @type {string}
     * @memberof CreateAccountRequestWithoutCustomerId
     */
    'name': string;
    /**
     * Use [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code in which the account must be invoiced.   For example: AED is the currency code for United Arab Emirates dirham. 
     * @type {string}
     * @memberof CreateAccountRequestWithoutCustomerId
     */
    'invoiceCurrency'?: string;
    /**
     * Aliases are tags that are associated with an account. Multiple aliases are allowed for a single account.
     * @type {Array<string>}
     * @memberof CreateAccountRequestWithoutCustomerId
     */
    'aliases'?: Array<string>;
    /**
     * Aliases which effective range
     * @type {Array<CreateAccountAliasRequest>}
     * @memberof CreateAccountRequestWithoutCustomerId
     */
    'accountAliases'?: Array<CreateAccountAliasRequest>;
    /**
     * 
     * @type {Address}
     * @memberof CreateAccountRequestWithoutCustomerId
     */
    'address'?: Address;
    /**
     * Primary email of the account
     * @type {string}
     * @memberof CreateAccountRequestWithoutCustomerId
     */
    'primaryEmail'?: string;
    /**
     * 
     * @type {Array<CreateEntitySetting>}
     * @memberof CreateAccountRequestWithoutCustomerId
     */
    'settings'?: Array<CreateEntitySetting>;
    /**
     * Net term for the invoices of the account
     * @type {number}
     * @memberof CreateAccountRequestWithoutCustomerId
     */
    'netTermDays'?: number;
    /**
     * Additional information associated with the account. Example: GSTN, VATN 
     * @type {{ [key: string]: string; }}
     * @memberof CreateAccountRequestWithoutCustomerId
     */
    'metadata'?: { [key: string]: string; };
    /**
     * Tag for accounts are stored in lowercase
     * @type {Array<string>}
     * @memberof CreateAccountRequestWithoutCustomerId
     */
    'tags'?: Array<string>;
    /**
     * Status of the created account defaults to ACTIVE
     * @type {string}
     * @memberof CreateAccountRequestWithoutCustomerId
     */
    'status'?: CreateAccountRequestWithoutCustomerIdStatusEnum;
}

export const CreateAccountRequestWithoutCustomerIdStatusEnum = {
    Active: 'ACTIVE',
    Draft: 'DRAFT'
} as const;

export type CreateAccountRequestWithoutCustomerIdStatusEnum = typeof CreateAccountRequestWithoutCustomerIdStatusEnum[keyof typeof CreateAccountRequestWithoutCustomerIdStatusEnum];

/**
 * Request to create an addon
 * @export
 * @interface CreateAddOnRequest
 */
export interface CreateAddOnRequest {
    /**
     * Name of addon
     * @type {string}
     * @memberof CreateAddOnRequest
     */
    'name': string;
    /**
     * 
     * @type {AddOnType}
     * @memberof CreateAddOnRequest
     */
    'type': AddOnType;
    /**
     * Billable name of addon. Billable name takes precedence over name to display in invoice.
     * @type {string}
     * @memberof CreateAddOnRequest
     */
    'billableName'?: string;
}


/**
 * Create an alias
 * @export
 * @interface CreateAliasRequest
 */
export interface CreateAliasRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAliasRequest
     */
    'value': string;
}
/**
 * Create bulk alias
 * @export
 * @interface CreateBulkAliasRequest
 */
export interface CreateBulkAliasRequest {
    /**
     * 
     * @type {Array<CreateAliasRequest>}
     * @memberof CreateBulkAliasRequest
     */
    'aliases': Array<CreateAliasRequest>;
}
/**
 * payload to create credits
 * @export
 * @interface CreateCreditRequest
 */
export interface CreateCreditRequest {
    /**
     * 
     * @type {Array<CreditRequest>}
     * @memberof CreateCreditRequest
     */
    'creditRequests': Array<CreditRequest>;
}
/**
 * 
 * @export
 * @interface CreateCreditResponse
 */
export interface CreateCreditResponse {
    /**
     * 
     * @type {Array<Credit>}
     * @memberof CreateCreditResponse
     */
    'credits': Array<Credit>;
}
/**
 * Payload to create invoice
 * @export
 * @interface CreateCustomInvoiceRequest
 */
export interface CreateCustomInvoiceRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCustomInvoiceRequest
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomInvoiceRequest
     */
    'ownerType'?: CreateCustomInvoiceRequestOwnerTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomInvoiceRequest
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomInvoiceRequest
     */
    'endDate': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomInvoiceRequest
     */
    'idempotencyKey'?: string;
    /**
     * Status to create an invoice in.
     * @type {string}
     * @memberof CreateCustomInvoiceRequest
     */
    'status': CreateCustomInvoiceRequestStatusEnum;
    /**
     * 
     * @type {Array<CustomInvoiceLineItem>}
     * @memberof CreateCustomInvoiceRequest
     */
    'lineItems': Array<CustomInvoiceLineItem>;
    /**
     * This property defines the behaviour of status transition of the invoice. If true, invoice auto transitions from `DRAFT` to `DUE` or `PAID` at the end of pricing cycle. If false, the invoice’s state doesn’t automatically advance without an explicit action. Default: false 
     * @type {boolean}
     * @memberof CreateCustomInvoiceRequest
     */
    'autoAdvance'?: boolean;
    /**
     * This property defines the behaviour of whether or not to use credits to net off with the invoice amount. Default: true 
     * @type {boolean}
     * @memberof CreateCustomInvoiceRequest
     */
    'applyCredits'?: boolean;
    /**
     * This property defines the behaviour of whether or not to use wallet amount to net off with the invoice amount. Default: true 
     * @type {boolean}
     * @memberof CreateCustomInvoiceRequest
     */
    'applyWalletBalance'?: boolean;
}

export const CreateCustomInvoiceRequestOwnerTypeEnum = {
    Account: 'ACCOUNT',
    InvoiceGroup: 'INVOICE_GROUP'
} as const;

export type CreateCustomInvoiceRequestOwnerTypeEnum = typeof CreateCustomInvoiceRequestOwnerTypeEnum[keyof typeof CreateCustomInvoiceRequestOwnerTypeEnum];
export const CreateCustomInvoiceRequestStatusEnum = {
    Draft: 'DRAFT',
    Due: 'DUE',
    Paid: 'PAID'
} as const;

export type CreateCustomInvoiceRequestStatusEnum = typeof CreateCustomInvoiceRequestStatusEnum[keyof typeof CreateCustomInvoiceRequestStatusEnum];

/**
 * Payload to create a contact for a customer
 * @export
 * @interface CreateCustomerContactRequest
 */
export interface CreateCustomerContactRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerContactRequest
     */
    'preferredUsername'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerContactRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerContactRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerContactRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerContactRequest
     */
    'phone'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCustomerContactRequest
     */
    'verified'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCustomerContactRequest
     */
    'loginAccess'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateCustomerContactResponse
 */
export interface CreateCustomerContactResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerContactResponse
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerContactResponse
     */
    'preferredUsername'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerContactResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerContactResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerContactResponse
     */
    'phone'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCustomerContactResponse
     */
    'loginAccess': boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerContactResponse
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerContactResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCustomerContactResponse
     */
    'verified': boolean;
}
/**
 * Payload to create customer
 * @export
 * @interface CreateCustomerRequest
 */
export interface CreateCustomerRequest {
    /**
     * Customer identifier
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'id': string;
    /**
     * Name of the Customer
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'name': string;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'primaryEmail': string;
    /**
     * 
     * @type {Address}
     * @memberof CreateCustomerRequest
     */
    'address': Address;
    /**
     * 
     * @type {Array<CreateEntitySetting>}
     * @memberof CreateCustomerRequest
     */
    'settings'?: Array<CreateEntitySetting>;
    /**
     * 
     * @type {CreateAccountRequestWithoutCustomerId}
     * @memberof CreateCustomerRequest
     */
    'account'?: CreateAccountRequestWithoutCustomerId;
}
/**
 * 
 * @export
 * @interface CreateCustomerResponse
 */
export interface CreateCustomerResponse {
    /**
     * Identifier of customer
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'id': string;
    /**
     * Unique identifier of customer
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'togaiCustomerId': string;
    /**
     * Name of the Customer
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'name': string;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'primaryEmail': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'billingAddress'?: string;
    /**
     * 
     * @type {Address}
     * @memberof CreateCustomerResponse
     */
    'address'?: Address;
    /**
     * 
     * @type {Array<CreateEntitySetting>}
     * @memberof CreateCustomerResponse
     */
    'settings'?: Array<CreateEntitySetting>;
    /**
     * 
     * @type {Account}
     * @memberof CreateCustomerResponse
     */
    'account'?: Account;
}
/**
 * Represents a setting
 * @export
 * @interface CreateEntitySetting
 */
export interface CreateEntitySetting {
    /**
     * 
     * @type {string}
     * @memberof CreateEntitySetting
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEntitySetting
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEntitySetting
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEntitySetting
     */
    'name': string;
    /**
     * 
     * @type {SettingDataType}
     * @memberof CreateEntitySetting
     */
    'dataType': SettingDataType;
}


/**
 * Request to create event schema
 * @export
 * @interface CreateEventSchemaRequest
 */
export interface CreateEventSchemaRequest {
    /**
     * Name of the event. Must be unique for an organization.
     * @type {string}
     * @memberof CreateEventSchemaRequest
     */
    'name': string;
    /**
     * Description of the event
     * @type {string}
     * @memberof CreateEventSchemaRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<EventAttributeSchema>}
     * @memberof CreateEventSchemaRequest
     */
    'attributes': Array<EventAttributeSchema>;
    /**
     * 
     * @type {Array<DimensionsSchema>}
     * @memberof CreateEventSchemaRequest
     */
    'dimensions': Array<DimensionsSchema>;
    /**
     * 
     * @type {Enrichments}
     * @memberof CreateEventSchemaRequest
     */
    'enrichments'?: Enrichments;
    /**
     * List of fields that can be used for filtering in usage meter
     * @type {Array<string>}
     * @memberof CreateEventSchemaRequest
     */
    'filterFields'?: Array<string>;
    /**
     * Template used to generate event id based on event payload
     * @type {string}
     * @memberof CreateEventSchemaRequest
     */
    'eventIdTemplate'?: string;
}
/**
 * Create a Feature stand-alone or associate it with schemas
 * @export
 * @interface CreateFeatureRequest
 */
export interface CreateFeatureRequest {
    /**
     * Name of the feature
     * @type {string}
     * @memberof CreateFeatureRequest
     */
    'name': string;
    /**
     * Billable name of feature. Billable name takes precedence over name to display in invoice.
     * @type {string}
     * @memberof CreateFeatureRequest
     */
    'billableName'?: string;
    /**
     * Association of a feature with event_schemas
     * @type {Array<EventSchemasForFeature>}
     * @memberof CreateFeatureRequest
     */
    'schemaAssociations': Array<EventSchemasForFeature>;
}
/**
 * Create an invoice group
 * @export
 * @interface CreateInvoiceGroupRequest
 */
export interface CreateInvoiceGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateInvoiceGroupRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateInvoiceGroupRequest
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateInvoiceGroupRequest
     */
    'dailyInvoiceConsolidation': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateInvoiceGroupRequest
     */
    'accountIds': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CreateInvoiceGroupRequest
     */
    'netTermDays'?: number;
    /**
     * 
     * @type {Address}
     * @memberof CreateInvoiceGroupRequest
     */
    'address': Address;
}
/**
 * payload to create payment
 * @export
 * @interface CreatePaymentRequest
 */
export interface CreatePaymentRequest {
    /**
     * A brief description of the payment
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'description'?: string;
    /**
     * A detailed note about the payment
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'notes'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'accountId': string;
    /**
     * 
     * @type {ExternalPaymentReference}
     * @memberof CreatePaymentRequest
     */
    'externalPaymentReference': ExternalPaymentReference;
    /**
     * 
     * @type {Array<PaymentLineItemRecord>}
     * @memberof CreatePaymentRequest
     */
    'lineItemRecords': Array<PaymentLineItemRecord>;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'currency': string;
    /**
     * 
     * @type {number}
     * @memberof CreatePaymentRequest
     */
    'totalAmount': number;
}
/**
 * 
 * @export
 * @interface CreatePricePlanDetails
 */
export interface CreatePricePlanDetails {
    /**
     * 
     * @type {PricingCycleConfig}
     * @memberof CreatePricePlanDetails
     */
    'pricingCycleConfig'?: PricingCycleConfig;
    /**
     * List of currencies supported by the price plan
     * @type {Array<string>}
     * @memberof CreatePricePlanDetails
     */
    'supportedCurrencies': Array<string>;
    /**
     * List of usage rate cards
     * @type {Array<UsageRateCard>}
     * @memberof CreatePricePlanDetails
     */
    'usageRateCards'?: Array<UsageRateCard>;
    /**
     * 
     * @type {Array<FixedFeeRateCard>}
     * @memberof CreatePricePlanDetails
     */
    'fixedFeeRateCards'?: Array<FixedFeeRateCard>;
    /**
     * 
     * @type {Array<LicenseRateCard>}
     * @memberof CreatePricePlanDetails
     */
    'licenseRateCards'?: Array<LicenseRateCard>;
    /**
     * 
     * @type {Array<BillingEntitlementRateCard>}
     * @memberof CreatePricePlanDetails
     */
    'billingEntitlementRateCards'?: Array<BillingEntitlementRateCard>;
    /**
     * 
     * @type {MinimumCommitment}
     * @memberof CreatePricePlanDetails
     */
    'minimumCommitment'?: MinimumCommitment;
    /**
     * 
     * @type {Array<CreditGrantRateCard>}
     * @memberof CreatePricePlanDetails
     */
    'creditGrantRateCards'?: Array<CreditGrantRateCard>;
    /**
     * 
     * @type {Array<EntitlementOverageRateCard>}
     * @memberof CreatePricePlanDetails
     */
    'entitlementOverageRateCards'?: Array<EntitlementOverageRateCard>;
    /**
     * This option can be enabled while creating a price plan to opt for deferred revenue finalization. i.e, Togai will assume that the price plan may change any time during the pricing cycle and  thereby does not compute the revenue in near-real time.  This gives the flexibility of editing rate cards in price plan from beginning of the pricing cycle. Enabling this mode comes with the following limitations. 1. Following rate cards are not supported under a `deferredRevenue` plan     * creditGrantRateCards,     * billingEntitlementRateCards,     * entitlementOverageRateCards,     * IN_ADVANCE fixedFeeRateCards,     * IN_ADVANCE licenseRateCards 2. Metrics API return revenue metrics only after the grace period of the account\'s pricing cycle  (i.e, only once the invoice becomes DUE) 
     * @type {boolean}
     * @memberof CreatePricePlanDetails
     */
    'deferredRevenue'?: boolean;
}
/**
 * 
 * @export
 * @interface CreatePricePlanDetailsOverride
 */
export interface CreatePricePlanDetailsOverride {
    /**
     * 
     * @type {PricingCycleConfig}
     * @memberof CreatePricePlanDetailsOverride
     */
    'pricingCycleConfig'?: PricingCycleConfig;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreatePricePlanDetailsOverride
     */
    'supportedCurrencies'?: Array<string>;
    /**
     * 
     * @type {Array<UsageRateCard>}
     * @memberof CreatePricePlanDetailsOverride
     */
    'usageRateCards'?: Array<UsageRateCard>;
    /**
     * 
     * @type {Array<BillingEntitlementRateCard>}
     * @memberof CreatePricePlanDetailsOverride
     */
    'billingEntitlementRateCards'?: Array<BillingEntitlementRateCard>;
    /**
     * 
     * @type {Array<EntitlementOverageRateCard>}
     * @memberof CreatePricePlanDetailsOverride
     */
    'entitlementOverageRateCards'?: Array<EntitlementOverageRateCard>;
    /**
     * 
     * @type {Array<FixedFeeRateCard>}
     * @memberof CreatePricePlanDetailsOverride
     */
    'fixedFeeRateCards'?: Array<FixedFeeRateCard>;
    /**
     * 
     * @type {Array<LicenseRateCard>}
     * @memberof CreatePricePlanDetailsOverride
     */
    'licenseRateCards'?: Array<LicenseRateCard>;
    /**
     * 
     * @type {MinimumCommitment}
     * @memberof CreatePricePlanDetailsOverride
     */
    'minimumCommitment'?: MinimumCommitment;
    /**
     * 
     * @type {Array<CreditGrantRateCard>}
     * @memberof CreatePricePlanDetailsOverride
     */
    'creditGrantRateCards'?: Array<CreditGrantRateCard>;
}
/**
 * Request to create price plan migration request
 * @export
 * @interface CreatePricePlanMigrationRequest
 */
export interface CreatePricePlanMigrationRequest {
    /**
     * Id of source price plan
     * @type {string}
     * @memberof CreatePricePlanMigrationRequest
     */
    'sourceId': string;
    /**
     * Version of the source price plan
     * @type {number}
     * @memberof CreatePricePlanMigrationRequest
     */
    'sourceVersion': number;
    /**
     * Id of target price plan
     * @type {string}
     * @memberof CreatePricePlanMigrationRequest
     */
    'targetId'?: string;
    /**
     * Version of the target price plan
     * @type {number}
     * @memberof CreatePricePlanMigrationRequest
     */
    'targetVersion'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreatePricePlanMigrationRequest
     */
    'migrationMode': CreatePricePlanMigrationRequestMigrationModeEnum;
    /**
     * If this flag is true, current pricing cycle of the account on the date of association will continue rather  than the configurations of the newly associated price plan. Pricing cycle overrides specified  using  `pricePlanDetailsOverride` will take precedence over the pricing cycle configurations of  the new price plan that the account needs to migrate to. PricingCycleInterval of the existing plan and  the new plan must be same for this to work. We\'ll return a `400 BadRequest` otherwise. Examples:   - Ongoing plan (1st Oct to 30th Oct) - {dayOffset: 1, monthOffset: NIL}     New association (15th Oct to 15th Nov) of different price plan with retainStartOffsets option true      will use the same pricing cycle configuration {dayOffset: 1, monthOffset: NIL} rather than using the     pricing cycle configuration of the new price plan that the account needs to migrate to.   - Ongoing plan (1st Oct to 30th Oct) - {dayOffset: 1, monthOffset: NIL}     New association (1st Nov to 30th Nov) of different price plan with retainStartOffsets option true will     throw a `400 BadRequest` as no existing price plan configuration found on date of association 
     * @type {boolean}
     * @memberof CreatePricePlanMigrationRequest
     */
    'retainStartOffsets'?: boolean;
    /**
     * This field specifies whether to process job or to wait till the job is confirmed. Default value: false 
     * @type {boolean}
     * @memberof CreatePricePlanMigrationRequest
     */
    'requireConfirmation'?: boolean;
}

export const CreatePricePlanMigrationRequestMigrationModeEnum = {
    Immediate: 'IMMEDIATE',
    ImmediateIgnoreOverride: 'IMMEDIATE_IGNORE_OVERRIDE',
    NextCycle: 'NEXT_CYCLE',
    NextCycleIgnoreOverride: 'NEXT_CYCLE_IGNORE_OVERRIDE'
} as const;

export type CreatePricePlanMigrationRequestMigrationModeEnum = typeof CreatePricePlanMigrationRequestMigrationModeEnum[keyof typeof CreatePricePlanMigrationRequestMigrationModeEnum];

/**
 * 
 * @export
 * @interface CreatePricePlanMigrationRequestAllOf
 */
export interface CreatePricePlanMigrationRequestAllOf {
    /**
     * This field specifies whether to process job or to wait till the job is confirmed. Default value: false 
     * @type {boolean}
     * @memberof CreatePricePlanMigrationRequestAllOf
     */
    'requireConfirmation'?: boolean;
}
/**
 * Request to create a price plan
 * @export
 * @interface CreatePricePlanRequest
 */
export interface CreatePricePlanRequest {
    /**
     * Name of the price plan
     * @type {string}
     * @memberof CreatePricePlanRequest
     */
    'name': string;
    /**
     * Description of price plan
     * @type {string}
     * @memberof CreatePricePlanRequest
     */
    'description'?: string;
    /**
     * 
     * @type {PricePlanType}
     * @memberof CreatePricePlanRequest
     */
    'type'?: PricePlanType;
    /**
     * 
     * @type {CreatePricePlanDetails}
     * @memberof CreatePricePlanRequest
     */
    'pricePlanDetails': CreatePricePlanDetails;
    /**
     * 
     * @type {Array<CreatePricingRule>}
     * @memberof CreatePricePlanRequest
     */
    'pricingRules'?: Array<CreatePricingRule>;
}


/**
 * 
 * @export
 * @interface CreatePricingRule
 */
export interface CreatePricingRule {
    /**
     * Name of the pricing rule
     * @type {string}
     * @memberof CreatePricingRule
     */
    'name': string;
    /**
     * Order of the pricing rule
     * @type {number}
     * @memberof CreatePricingRule
     */
    'order': number;
    /**
     * JSON logic condition deciding whether to compute this pricing rule or not
     * @type {string}
     * @memberof CreatePricingRule
     */
    'condition'?: string;
    /**
     * JSON logic to be computed
     * @type {string}
     * @memberof CreatePricingRule
     */
    'computation': string;
    /**
     * 
     * @type {PricingRuleAction}
     * @memberof CreatePricingRule
     */
    'action': PricingRuleAction;
}
/**
 * 
 * @export
 * @interface CreateProposalRequest
 */
export interface CreateProposalRequest {
    /**
     * Id of the price plan, Required for ENTITLEMENT_GRANT, ASSOCIATION purchase
     * @type {string}
     * @memberof CreateProposalRequest
     */
    'pricePlanId'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateProposalRequest
     */
    'quantity'?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof CreateProposalRequest
     */
    'rateCardQuantities'?: { [key: string]: number; };
    /**
     * 
     * @type {string}
     * @memberof CreateProposalRequest
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {PurchasePlanOverride}
     * @memberof CreateProposalRequest
     */
    'purchasePlanOverride'?: PurchasePlanOverride;
    /**
     * 
     * @type {CreatePricePlanDetailsOverride}
     * @memberof CreateProposalRequest
     */
    'associationOverride'?: CreatePricePlanDetailsOverride;
    /**
     * 
     * @type {WalletTopupDetails}
     * @memberof CreateProposalRequest
     */
    'walletTopupDetails'?: WalletTopupDetails;
    /**
     * 
     * @type {string}
     * @memberof CreateProposalRequest
     */
    'effectiveFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProposalRequest
     */
    'effectiveUntil'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProposalRequest
     */
    'expiryDate'?: string;
    /**
     * 
     * @type {PurchaseType}
     * @memberof CreateProposalRequest
     */
    'type': PurchaseType;
    /**
     * 
     * @type {string}
     * @memberof CreateProposalRequest
     */
    'paymentMode': CreateProposalRequestPaymentModeEnum;
}

export const CreateProposalRequestPaymentModeEnum = {
    Prepaid: 'PREPAID',
    Postpaid: 'POSTPAID'
} as const;

export type CreateProposalRequestPaymentModeEnum = typeof CreateProposalRequestPaymentModeEnum[keyof typeof CreateProposalRequestPaymentModeEnum];

/**
 * 
 * @export
 * @interface CreateProposalRequestAllOf
 */
export interface CreateProposalRequestAllOf {
    /**
     * 
     * @type {string}
     * @memberof CreateProposalRequestAllOf
     */
    'paymentMode': CreateProposalRequestAllOfPaymentModeEnum;
}

export const CreateProposalRequestAllOfPaymentModeEnum = {
    Prepaid: 'PREPAID',
    Postpaid: 'POSTPAID'
} as const;

export type CreateProposalRequestAllOfPaymentModeEnum = typeof CreateProposalRequestAllOfPaymentModeEnum[keyof typeof CreateProposalRequestAllOfPaymentModeEnum];

/**
 * Create a purchase for an account
 * @export
 * @interface CreatePurchaseRequest
 */
export interface CreatePurchaseRequest {
    /**
     * Id of the price plan, Required for ENTITLEMENT_GRANT, ASSOCIATION purchase
     * @type {string}
     * @memberof CreatePurchaseRequest
     */
    'pricePlanId'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreatePurchaseRequest
     */
    'quantity'?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof CreatePurchaseRequest
     */
    'rateCardQuantities'?: { [key: string]: number; };
    /**
     * 
     * @type {string}
     * @memberof CreatePurchaseRequest
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {PurchasePlanOverride}
     * @memberof CreatePurchaseRequest
     */
    'purchasePlanOverride'?: PurchasePlanOverride;
    /**
     * 
     * @type {CreatePricePlanDetailsOverride}
     * @memberof CreatePurchaseRequest
     */
    'associationOverride'?: CreatePricePlanDetailsOverride;
    /**
     * 
     * @type {WalletTopupDetails}
     * @memberof CreatePurchaseRequest
     */
    'walletTopupDetails'?: WalletTopupDetails;
    /**
     * 
     * @type {string}
     * @memberof CreatePurchaseRequest
     */
    'effectiveFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePurchaseRequest
     */
    'effectiveUntil'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePurchaseRequest
     */
    'expiryDate'?: string;
    /**
     * 
     * @type {PurchaseType}
     * @memberof CreatePurchaseRequest
     */
    'type'?: PurchaseType;
}


/**
 * Request to create usage meter
 * @export
 * @interface CreateUsageMeterRequest
 */
export interface CreateUsageMeterRequest {
    /**
     * Name of the usage meter. Must be unique for an organization.
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'name': string;
    /**
     * Billable name of usage meter. Billable name takes precedence over name to display in invoice.
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'billableName'?: string;
    /**
     * Description of the usage meter
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'description'?: string;
    /**
     * The usage meter\'s applicability will be determined by comparing the filter condition agianst the events.
     * @type {Array<UsageMeterFilterEntry>}
     * @memberof CreateUsageMeterRequest
     */
    'filters'?: Array<UsageMeterFilterEntry>;
    /**
     * Type of usage meter
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'type': CreateUsageMeterRequestTypeEnum;
    /**
     * 
     * @type {UsageMeterAggregation}
     * @memberof CreateUsageMeterRequest
     */
    'aggregation': UsageMeterAggregation;
    /**
     * 
     * @type {Array<Computation>}
     * @memberof CreateUsageMeterRequest
     */
    'computations'?: Array<Computation>;
    /**
     * Event Schema Identifier
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'eventSchemaName'?: string;
}

export const CreateUsageMeterRequestTypeEnum = {
    Counter: 'COUNTER'
} as const;

export type CreateUsageMeterRequestTypeEnum = typeof CreateUsageMeterRequestTypeEnum[keyof typeof CreateUsageMeterRequestTypeEnum];

/**
 * 
 * @export
 * @interface Credit
 */
export interface Credit {
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'purpose': string;
    /**
     * List of entity ids for which the credit is applicable. If null or empty, the credit is applicable to all ids. This list can accept special values like: - ALL_USAGE_METER_RATE_CARDS: To apply the credit to all usage meter rate cards - ALL_FIXED_FEE_RATE_CARDS: To apply the credit to all fixed fee rate cards 
     * @type {Array<string>}
     * @memberof Credit
     */
    'applicableEntityIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'effectiveFrom': string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'effectiveUntil'?: string;
    /**
     * 
     * @type {number}
     * @memberof Credit
     */
    'creditAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Credit
     */
    'priority': number;
    /**
     * The entity through which the credit has been granted
     * @type {string}
     * @memberof Credit
     */
    'grantorId'?: string;
    /**
     * The idempotency key for uniqueness of the credit record
     * @type {string}
     * @memberof Credit
     */
    'idempotencyKey'?: string;
    /**
     * Identifier of credits
     * @type {string}
     * @memberof Credit
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'customerId': string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'status': CreditStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'creditUnit'?: string;
    /**
     * 
     * @type {number}
     * @memberof Credit
     */
    'holdAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Credit
     */
    'consumedAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'updatedAt'?: string;
}

export const CreditStatusEnum = {
    Active: 'ACTIVE',
    Consumed: 'CONSUMED',
    Expired: 'EXPIRED',
    Voided: 'VOIDED'
} as const;

export type CreditStatusEnum = typeof CreditStatusEnum[keyof typeof CreditStatusEnum];

/**
 * 
 * @export
 * @interface CreditAllOf
 */
export interface CreditAllOf {
    /**
     * Identifier of credits
     * @type {string}
     * @memberof CreditAllOf
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreditAllOf
     */
    'customerId': string;
    /**
     * 
     * @type {string}
     * @memberof CreditAllOf
     */
    'status': CreditAllOfStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CreditAllOf
     */
    'creditUnit'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditAllOf
     */
    'holdAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreditAllOf
     */
    'consumedAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreditAllOf
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CreditAllOf
     */
    'updatedAt'?: string;
}

export const CreditAllOfStatusEnum = {
    Active: 'ACTIVE',
    Consumed: 'CONSUMED',
    Expired: 'EXPIRED',
    Voided: 'VOIDED'
} as const;

export type CreditAllOfStatusEnum = typeof CreditAllOfStatusEnum[keyof typeof CreditAllOfStatusEnum];

/**
 * Credit Balance response
 * @export
 * @interface CreditBalanceResponse
 */
export interface CreditBalanceResponse {
    /**
     * 
     * @type {number}
     * @memberof CreditBalanceResponse
     */
    'activeCredits': number;
    /**
     * 
     * @type {number}
     * @memberof CreditBalanceResponse
     */
    'availableBalance': number;
    /**
     * 
     * @type {number}
     * @memberof CreditBalanceResponse
     */
    'runningBalance': number;
    /**
     * 
     * @type {number}
     * @memberof CreditBalanceResponse
     */
    'inapplicableCredits': number;
    /**
     * 
     * @type {string}
     * @memberof CreditBalanceResponse
     */
    'unit': string;
    /**
     * 
     * @type {string}
     * @memberof CreditBalanceResponse
     */
    'lastUpdatedAt': string;
}
/**
 * 
 * @export
 * @interface CreditDetailsResponse
 */
export interface CreditDetailsResponse {
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'purpose': string;
    /**
     * List of entity ids for which the credit is applicable. If null or empty, the credit is applicable to all ids. This list can accept special values like: - ALL_USAGE_METER_RATE_CARDS: To apply the credit to all usage meter rate cards - ALL_FIXED_FEE_RATE_CARDS: To apply the credit to all fixed fee rate cards 
     * @type {Array<string>}
     * @memberof CreditDetailsResponse
     */
    'applicableEntityIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'effectiveFrom': string;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'effectiveUntil'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditDetailsResponse
     */
    'creditAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreditDetailsResponse
     */
    'priority': number;
    /**
     * The entity through which the credit has been granted
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'grantorId'?: string;
    /**
     * The idempotency key for uniqueness of the credit record
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'idempotencyKey'?: string;
    /**
     * Identifier of credits
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'customerId': string;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'status': CreditDetailsResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'creditUnit'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditDetailsResponse
     */
    'holdAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreditDetailsResponse
     */
    'consumedAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {Array<CreditTransaction>}
     * @memberof CreditDetailsResponse
     */
    'transactions': Array<CreditTransaction>;
}

export const CreditDetailsResponseStatusEnum = {
    Active: 'ACTIVE',
    Consumed: 'CONSUMED',
    Expired: 'EXPIRED',
    Voided: 'VOIDED'
} as const;

export type CreditDetailsResponseStatusEnum = typeof CreditDetailsResponseStatusEnum[keyof typeof CreditDetailsResponseStatusEnum];

/**
 * 
 * @export
 * @interface CreditDetailsResponseAllOf
 */
export interface CreditDetailsResponseAllOf {
    /**
     * 
     * @type {Array<CreditTransaction>}
     * @memberof CreditDetailsResponseAllOf
     */
    'transactions': Array<CreditTransaction>;
}
/**
 * Credit grant rate card
 * @export
 * @interface CreditGrantRateCard
 */
export interface CreditGrantRateCard {
    /**
     * 
     * @type {string}
     * @memberof CreditGrantRateCard
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreditGrantRateCard
     */
    'displayName'?: string;
    /**
     * A tag string to group creditGrantRateCard
     * @type {string}
     * @memberof CreditGrantRateCard
     */
    'tag'?: string;
    /**
     * 
     * @type {GrantDetails}
     * @memberof CreditGrantRateCard
     */
    'grantDetails': GrantDetails;
    /**
     * 
     * @type {CreditRateDetails}
     * @memberof CreditGrantRateCard
     */
    'rateDetails': CreditRateDetails;
    /**
     * 
     * @type {InvoiceTiming}
     * @memberof CreditGrantRateCard
     */
    'invoiceTiming'?: InvoiceTiming;
    /**
     * 
     * @type {CreditGrantType}
     * @memberof CreditGrantRateCard
     */
    'type'?: CreditGrantType;
    /**
     * 
     * @type {RecurrenceConfig}
     * @memberof CreditGrantRateCard
     */
    'recurrenceConfig'?: RecurrenceConfig;
}


/**
 * 
 * @export
 * @interface CreditGrantRates
 */
export interface CreditGrantRates {
    /**
     * 
     * @type {string}
     * @memberof CreditGrantRates
     */
    'id': string;
    /**
     * 
     * @type {Array<SlabDetail>}
     * @memberof CreditGrantRates
     */
    'slabDetails': Array<SlabDetail>;
    /**
     * 
     * @type {number}
     * @memberof CreditGrantRates
     */
    'creditAmount': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreditGrantRates
     */
    'rateConfig'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CreditGrantRevenueSummary
 */
export interface CreditGrantRevenueSummary {
    /**
     * 
     * @type {number}
     * @memberof CreditGrantRevenueSummary
     */
    'revenue': number;
}
/**
 * Credit grant applies either for a one-time occurrence or for each cycle.
 * @export
 * @enum {string}
 */

export const CreditGrantType = {
    OneTime: 'ONE_TIME',
    Recurring: 'RECURRING'
} as const;

export type CreditGrantType = typeof CreditGrantType[keyof typeof CreditGrantType];


/**
 * Amount to be credited
 * @export
 * @interface CreditRateDetails
 */
export interface CreditRateDetails {
    /**
     * 
     * @type {PricingModel}
     * @memberof CreditRateDetails
     */
    'pricingModel': PricingModel;
    /**
     * 
     * @type {Array<CurrencySlabRateDetail>}
     * @memberof CreditRateDetails
     */
    'currencySlabRateDetails': Array<CurrencySlabRateDetail>;
}


/**
 * Payload to grant Credits
 * @export
 * @interface CreditRequest
 */
export interface CreditRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditRequest
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof CreditRequest
     */
    'purpose': string;
    /**
     * List of entity ids for which the credit is applicable. If null or empty, the credit is applicable to all ids. This list can accept special values like: - ALL_USAGE_METER_RATE_CARDS: To apply the credit to all usage meter rate cards - ALL_FIXED_FEE_RATE_CARDS: To apply the credit to all fixed fee rate cards 
     * @type {Array<string>}
     * @memberof CreditRequest
     */
    'applicableEntityIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreditRequest
     */
    'effectiveFrom': string;
    /**
     * 
     * @type {string}
     * @memberof CreditRequest
     */
    'effectiveUntil'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditRequest
     */
    'creditAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreditRequest
     */
    'priority': number;
    /**
     * The entity through which the credit has been granted
     * @type {string}
     * @memberof CreditRequest
     */
    'grantorId'?: string;
    /**
     * The idempotency key for uniqueness of the credit record
     * @type {string}
     * @memberof CreditRequest
     */
    'idempotencyKey'?: string;
}
/**
 * 
 * @export
 * @interface CreditTransaction
 */
export interface CreditTransaction {
    /**
     * Identifier of credit transactions
     * @type {string}
     * @memberof CreditTransaction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreditTransaction
     */
    'creditId': string;
    /**
     * 
     * @type {string}
     * @memberof CreditTransaction
     */
    'transactionType': CreditTransactionTransactionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreditTransaction
     */
    'invoiceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreditTransaction
     */
    'entityId'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditTransaction
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreditTransaction
     */
    'createdAt': string;
}

export const CreditTransactionTransactionTypeEnum = {
    Credited: 'CREDITED',
    Debited: 'DEBITED',
    Expired: 'EXPIRED',
    Voided: 'VOIDED'
} as const;

export type CreditTransactionTransactionTypeEnum = typeof CreditTransactionTransactionTypeEnum[keyof typeof CreditTransactionTransactionTypeEnum];

/**
 * Configuration for getting the currency
 * @export
 * @interface CurrencyConfig
 */
export interface CurrencyConfig {
    /**
     * Mode to get the currency - CUSTOM: Use the currency provided in the request - ACCOUNT_INVOICE: Use the invoice currency of the given account 
     * @type {string}
     * @memberof CurrencyConfig
     */
    'mode': CurrencyConfigModeEnum;
    /**
     * Currency to be used, this will be considered if mode is CUSTOM
     * @type {string}
     * @memberof CurrencyConfig
     */
    'currency'?: string;
    /**
     * Id of the account of which invoice currency will be used, this will be considered if mode is ACCOUNT_INVOICE
     * @type {string}
     * @memberof CurrencyConfig
     */
    'accountId'?: string;
}

export const CurrencyConfigModeEnum = {
    Custom: 'CUSTOM',
    AccountInvoice: 'ACCOUNT_INVOICE'
} as const;

export type CurrencyConfigModeEnum = typeof CurrencyConfigModeEnum[keyof typeof CurrencyConfigModeEnum];

/**
 * 
 * @export
 * @interface CurrencyRateValue
 */
export interface CurrencyRateValue {
    /**
     * 
     * @type {string}
     * @memberof CurrencyRateValue
     */
    'currency': string;
    /**
     * 
     * @type {number}
     * @memberof CurrencyRateValue
     */
    'rate': number;
}
/**
 * The association of a currency along with its slab detail
 * @export
 * @interface CurrencySlabRateDetail
 */
export interface CurrencySlabRateDetail {
    /**
     * 
     * @type {string}
     * @memberof CurrencySlabRateDetail
     */
    'currency': string;
    /**
     * The amount of credit that needs to be credited
     * @type {number}
     * @memberof CurrencySlabRateDetail
     */
    'creditAmount': number;
    /**
     * 
     * @type {Array<SlabDetail>}
     * @memberof CurrencySlabRateDetail
     */
    'slabDetails': Array<SlabDetail>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CurrencySlabRateDetail
     */
    'rateConfig'?: { [key: string]: string; };
}
/**
 * Custom line item. Either `value` or `quantity` + `valuePerQuantity` is required. In case `quantity` and `valuePerQuantity` are provided, `value` is computed as (`quantity` X `valuePerQuantity`) 
 * @export
 * @interface CustomInvoiceLineItem
 */
export interface CustomInvoiceLineItem {
    /**
     * 
     * @type {string}
     * @memberof CustomInvoiceLineItem
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomInvoiceLineItem
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof CustomInvoiceLineItem
     */
    'valuePerQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomInvoiceLineItem
     */
    'quantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomInvoiceLineItem
     */
    'value'?: number;
}
/**
 * Structure of customer
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * Identifier of customer
     * @type {string}
     * @memberof Customer
     */
    'id': string;
    /**
     * Unique identifier of customer
     * @type {string}
     * @memberof Customer
     */
    'togaiCustomerId': string;
    /**
     * Name of the Customer
     * @type {string}
     * @memberof Customer
     */
    'name': string;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof Customer
     */
    'primaryEmail': string;
    /**
     * billing address of the customer
     * @type {string}
     * @memberof Customer
     */
    'billingAddress': string;
    /**
     * 
     * @type {Address}
     * @memberof Customer
     */
    'address': Address;
    /**
     * Status of the customer
     * @type {string}
     * @memberof Customer
     */
    'status': CustomerStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'updatedAt': string;
}

export const CustomerStatusEnum = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type CustomerStatusEnum = typeof CustomerStatusEnum[keyof typeof CustomerStatusEnum];

/**
 * 
 * @export
 * @interface CustomerPaginatedResponse
 */
export interface CustomerPaginatedResponse {
    /**
     * 
     * @type {Array<Customer>}
     * @memberof CustomerPaginatedResponse
     */
    'data'?: Array<Customer>;
    /**
     * 
     * @type {string}
     * @memberof CustomerPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof CustomerPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * 
 * @export
 * @interface Dependency
 */
export interface Dependency {
    /**
     * 
     * @type {string}
     * @memberof Dependency
     */
    'type': DependencyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Dependency
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof Dependency
     */
    'name': string;
}

export const DependencyTypeEnum = {
    Setting: 'SETTING'
} as const;

export type DependencyTypeEnum = typeof DependencyTypeEnum[keyof typeof DependencyTypeEnum];

/**
 * Structure of dimensions
 * @export
 * @interface DimensionsSchema
 */
export interface DimensionsSchema {
    /**
     * Name of the event dimension
     * @type {string}
     * @memberof DimensionsSchema
     */
    'name': string;
}
/**
 * Request to dis/associate one or more schedules to an account
 * @export
 * @interface EditPricingScheduleRequest
 */
export interface EditPricingScheduleRequest {
    /**
     * 
     * @type {Array<UpdatePricingScheduleRequest>}
     * @memberof EditPricingScheduleRequest
     */
    'edits': Array<UpdatePricingScheduleRequest>;
}
/**
 * enriched field
 * @export
 * @interface EnrichedField
 */
export interface EnrichedField {
    /**
     * 
     * @type {string}
     * @memberof EnrichedField
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EnrichedField
     */
    'type': EnrichedFieldTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EnrichedField
     */
    'value': string;
}

export const EnrichedFieldTypeEnum = {
    Attribute: 'ATTRIBUTE',
    Dimension: 'DIMENSION'
} as const;

export type EnrichedFieldTypeEnum = typeof EnrichedFieldTypeEnum[keyof typeof EnrichedFieldTypeEnum];

/**
 * enrichment dependency
 * @export
 * @interface EnrichmentDependency
 */
export interface EnrichmentDependency {
    /**
     * 
     * @type {string}
     * @memberof EnrichmentDependency
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof EnrichmentDependency
     */
    'type': EnrichmentDependencyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EnrichmentDependency
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnrichmentDependency
     */
    'value': string;
}

export const EnrichmentDependencyTypeEnum = {
    Setting: 'SETTING'
} as const;

export type EnrichmentDependencyTypeEnum = typeof EnrichmentDependencyTypeEnum[keyof typeof EnrichmentDependencyTypeEnum];

/**
 * 
 * @export
 * @interface Enrichments
 */
export interface Enrichments {
    /**
     * 
     * @type {Array<Dependency>}
     * @memberof Enrichments
     */
    'dependencies'?: Array<Dependency>;
    /**
     * 
     * @type {Array<Field>}
     * @memberof Enrichments
     */
    'fields': Array<Field>;
}
/**
 * Configuration for getting the entitlement overages
 * @export
 * @interface EntitlementOverageConfig
 */
export interface EntitlementOverageConfig {
    /**
     * Mode to get the entitlement overages for the entitlement overage rate cards - CUSTOM: Use the entitlement overages provided in the request - LOOKUP_CYCLE: Use the entitlement overages of a given account for the specified cycle 
     * @type {string}
     * @memberof EntitlementOverageConfig
     */
    'mode': EntitlementOverageConfigModeEnum;
    /**
     * Quantity of entitlement overages, this will be considered if mode is CUSTOM
     * @type {Array<EntitlementOverageEntry>}
     * @memberof EntitlementOverageConfig
     */
    'custom'?: Array<EntitlementOverageEntry>;
    /**
     * 
     * @type {EntitlementOverageConfigLookupCycle}
     * @memberof EntitlementOverageConfig
     */
    'lookupCycle'?: EntitlementOverageConfigLookupCycle;
}

export const EntitlementOverageConfigModeEnum = {
    Custom: 'CUSTOM',
    LookupCycle: 'LOOKUP_CYCLE'
} as const;

export type EntitlementOverageConfigModeEnum = typeof EntitlementOverageConfigModeEnum[keyof typeof EntitlementOverageConfigModeEnum];

/**
 * Billing cycle of entitlement overages to be looked up, this will be considered if mode is LOOKUP_CYCLE
 * @export
 * @interface EntitlementOverageConfigLookupCycle
 */
export interface EntitlementOverageConfigLookupCycle {
    /**
     * Effective date of the cycle, will be used to get the license entries of the cycle
     * @type {string}
     * @memberof EntitlementOverageConfigLookupCycle
     */
    'billingCycleEndDate': string;
    /**
     * 
     * @type {string}
     * @memberof EntitlementOverageConfigLookupCycle
     */
    'accountId': string;
}
/**
 * 
 * @export
 * @interface EntitlementOverageEntry
 */
export interface EntitlementOverageEntry {
    /**
     * 
     * @type {string}
     * @memberof EntitlementOverageEntry
     */
    'featureId': string;
    /**
     * 
     * @type {number}
     * @memberof EntitlementOverageEntry
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface EntitlementOverageRateCard
 */
export interface EntitlementOverageRateCard {
    /**
     * Unique Identifier of the attached Feature
     * @type {string}
     * @memberof EntitlementOverageRateCard
     */
    'featureId': string;
    /**
     * Name to be displayed during invoice
     * @type {string}
     * @memberof EntitlementOverageRateCard
     */
    'displayName'?: string;
    /**
     * A tag string to group rate cards
     * @type {string}
     * @memberof EntitlementOverageRateCard
     */
    'tag'?: string;
    /**
     * Maximum quantity allowed for the feature, if not specified, unlimited quantity is allowed
     * @type {number}
     * @memberof EntitlementOverageRateCard
     */
    'maxQuantity'?: number;
    /**
     * 
     * @type {RatePlan}
     * @memberof EntitlementOverageRateCard
     */
    'ratePlan': RatePlan;
    /**
     * 
     * @type {Array<RateValue>}
     * @memberof EntitlementOverageRateCard
     */
    'rateValues': Array<RateValue>;
    /**
     * 
     * @type {BillingConfig}
     * @memberof EntitlementOverageRateCard
     */
    'billingConfig'?: BillingConfig;
}
/**
 * 
 * @export
 * @interface EntitlementOverageRates
 */
export interface EntitlementOverageRates {
    /**
     * 
     * @type {string}
     * @memberof EntitlementOverageRates
     */
    'id': string;
    /**
     * List of slab rates
     * @type {Array<SlabRate>}
     * @memberof EntitlementOverageRates
     */
    'slabRates': Array<SlabRate>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof EntitlementOverageRates
     */
    'rateConfig'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface EntitlementOverageRevenueSummary
 */
export interface EntitlementOverageRevenueSummary {
    /**
     * 
     * @type {number}
     * @memberof EntitlementOverageRevenueSummary
     */
    'revenue': number;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * error description
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
}
/**
 * Contents of the event
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * Name of the Event Schema.  Know more about [event schema](https://docs.togai.com/docs/event-schemas) 
     * @type {string}
     * @memberof Event
     */
    'schemaName': string;
    /**
     * Togai restricts users to ingest events with same id within a period of *45 days*. This restriction is common for [/entitled API](/api-reference/entitlements/ingest-event-if-a-user-is-entitled-to-a-feature), [/ingest API](/api-reference/event-ingestion/ingest-events-to-togai) and [/ingestBatch API](/api-reference/event-ingestion/ingest-events-to-togai-in-batch). i.e, an id used on /ingest API will not be allowed on /ingestBatch or /entitled APIs
     * @type {string}
     * @memberof Event
     */
    'id'?: string;
    /**
     * Source time stamp of the event. This timestamp must be in ISO 8601 format.
     * @type {string}
     * @memberof Event
     */
    'timestamp': string;
    /**
     * The event will be associated with the provided account
     * @type {string}
     * @memberof Event
     */
    'accountId': string;
    /**
     * Attributes are numeric values. It can be usage metric which you push to Togai
     * @type {Array<Attribute>}
     * @memberof Event
     */
    'attributes': Array<Attribute>;
    /**
     * Dimensions are tags/labels associated with the events.
     * @type {{ [key: string]: string; }}
     * @memberof Event
     */
    'dimensions': { [key: string]: string; };
}
/**
 * Structure of an event attribute
 * @export
 * @interface EventAttributeSchema
 */
export interface EventAttributeSchema {
    /**
     * Name of the event attribute.
     * @type {string}
     * @memberof EventAttributeSchema
     */
    'name': string;
    /**
     * Unit for the attribute
     * @type {string}
     * @memberof EventAttributeSchema
     */
    'defaultUnit'?: string;
}
/**
 * 
 * @export
 * @interface EventCorrectionInfo
 */
export interface EventCorrectionInfo {
    /**
     * Unique id generated by Togai to identify an event uniquely
     * @type {string}
     * @memberof EventCorrectionInfo
     */
    'referenceId': string;
    /**
     * 
     * @type {Event}
     * @memberof EventCorrectionInfo
     */
    'eventPayload': Event;
    /**
     * 
     * @type {IngestionStatus}
     * @memberof EventCorrectionInfo
     */
    'ingestionStatus': IngestionStatus;
    /**
     * The associated account belongs to this customer
     * @type {string}
     * @memberof EventCorrectionInfo
     */
    'customerId'?: string;
    /**
     * 
     * @type {EventSource}
     * @memberof EventCorrectionInfo
     */
    'source'?: EventSource;
    /**
     * Created time stamp of the event. This timestamp must be in ISO 8601 format.
     * @type {string}
     * @memberof EventCorrectionInfo
     */
    'createdAt': string;
    /**
     * Status of the event requested for correction
     * @type {string}
     * @memberof EventCorrectionInfo
     */
    'status': EventCorrectionInfoStatusEnum;
    /**
     * Status description of the event requested for correction
     * @type {string}
     * @memberof EventCorrectionInfo
     */
    'reason': string;
}

export const EventCorrectionInfoStatusEnum = {
    Reverted: 'REVERTED',
    RevertedAndReingested: 'REVERTED_AND_REINGESTED',
    Failed: 'FAILED'
} as const;

export type EventCorrectionInfoStatusEnum = typeof EventCorrectionInfoStatusEnum[keyof typeof EventCorrectionInfoStatusEnum];

/**
 * 
 * @export
 * @interface EventCorrectionInfoAllOf
 */
export interface EventCorrectionInfoAllOf {
    /**
     * Status of the event requested for correction
     * @type {string}
     * @memberof EventCorrectionInfoAllOf
     */
    'status': EventCorrectionInfoAllOfStatusEnum;
    /**
     * Status description of the event requested for correction
     * @type {string}
     * @memberof EventCorrectionInfoAllOf
     */
    'reason': string;
}

export const EventCorrectionInfoAllOfStatusEnum = {
    Reverted: 'REVERTED',
    RevertedAndReingested: 'REVERTED_AND_REINGESTED',
    Failed: 'FAILED'
} as const;

export type EventCorrectionInfoAllOfStatusEnum = typeof EventCorrectionInfoAllOfStatusEnum[keyof typeof EventCorrectionInfoAllOfStatusEnum];

/**
 * Event Correction Payload for event correction
 * @export
 * @interface EventCorrectionRequest
 */
export interface EventCorrectionRequest {
    /**
     * 
     * @type {Event}
     * @memberof EventCorrectionRequest
     */
    'event'?: Event;
}
/**
 * Information related to ingestion of an event
 * @export
 * @interface EventPipelineInfo
 */
export interface EventPipelineInfo {
    /**
     * 
     * @type {EventPipelineInfoEventSchema}
     * @memberof EventPipelineInfo
     */
    'eventSchema'?: EventPipelineInfoEventSchema;
    /**
     * 
     * @type {Array<EventPipelineInfoUsageMeters>}
     * @memberof EventPipelineInfo
     */
    'usageMeters'?: Array<EventPipelineInfoUsageMeters>;
    /**
     * 
     * @type {Array<EventPipelineInfoPricePlans>}
     * @memberof EventPipelineInfo
     */
    'pricePlans'?: Array<EventPipelineInfoPricePlans>;
    /**
     * 
     * @type {EventPipelineInfoAccount}
     * @memberof EventPipelineInfo
     */
    'account'?: EventPipelineInfoAccount;
    /**
     * 
     * @type {EventPipelineInfoCustomer}
     * @memberof EventPipelineInfo
     */
    'customer'?: EventPipelineInfoCustomer;
    /**
     * 
     * @type {EventPipelineInfoFeatureDetails}
     * @memberof EventPipelineInfo
     */
    'featureDetails'?: EventPipelineInfoFeatureDetails;
    /**
     * 
     * @type {EventPipelineInfoEnrichments}
     * @memberof EventPipelineInfo
     */
    'enrichments'?: EventPipelineInfoEnrichments;
    /**
     * 
     * @type {Array<EventPipelineInfoRevenueDetails>}
     * @memberof EventPipelineInfo
     */
    'revenueDetails'?: Array<EventPipelineInfoRevenueDetails>;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfo
     */
    'statusBeforeReverting'?: string;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoAccount
 */
export interface EventPipelineInfoAccount {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoAccount
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoAccount
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoAccount
     */
    'alias'?: string;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoCustomer
 */
export interface EventPipelineInfoCustomer {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoCustomer
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoCustomer
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoEnrichments
 */
export interface EventPipelineInfoEnrichments {
    /**
     * 
     * @type {Array<EnrichedField>}
     * @memberof EventPipelineInfoEnrichments
     */
    'attributes'?: Array<EnrichedField>;
    /**
     * 
     * @type {Array<EnrichedField>}
     * @memberof EventPipelineInfoEnrichments
     */
    'dimensions'?: Array<EnrichedField>;
    /**
     * 
     * @type {Array<EnrichmentDependency>}
     * @memberof EventPipelineInfoEnrichments
     */
    'dependencies'?: Array<EnrichmentDependency>;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoEventSchema
 */
export interface EventPipelineInfoEventSchema {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoEventSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof EventPipelineInfoEventSchema
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoFeatureDetails
 */
export interface EventPipelineInfoFeatureDetails {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoFeatureDetails
     */
    'featureId': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoFeatureDetails
     */
    'mappedAttribute': string;
    /**
     * 
     * @type {number}
     * @memberof EventPipelineInfoFeatureDetails
     */
    'overageInCycle'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventPipelineInfoFeatureDetails
     */
    'overageInEvent'?: number;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoPricePlans
 */
export interface EventPipelineInfoPricePlans {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlans
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlans
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlans
     */
    'scheduleId': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlans
     */
    'cycleStart': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlans
     */
    'cycleEnd': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventPipelineInfoPricePlans
     */
    'usageMeters'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoRevenueDetails
 */
export interface EventPipelineInfoRevenueDetails {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoRevenueDetails
     */
    'usageMeterId': string;
    /**
     * 
     * @type {number}
     * @memberof EventPipelineInfoRevenueDetails
     */
    'revenueBaseCurrency': number;
    /**
     * 
     * @type {number}
     * @memberof EventPipelineInfoRevenueDetails
     */
    'revenueInvoiceCurrency': number;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoUsageMeters
 */
export interface EventPipelineInfoUsageMeters {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoUsageMeters
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoUsageMeters
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof EventPipelineInfoUsageMeters
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoUsageMeters
     */
    'status': EventPipelineInfoUsageMetersStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof EventPipelineInfoUsageMeters
     */
    'units'?: number;
}

export const EventPipelineInfoUsageMetersStatusEnum = {
    FilteredOut: 'PROCESSED_FILTERED_OUT',
    UnitsComputed: 'PROCESSED_UNITS_COMPUTED'
} as const;

export type EventPipelineInfoUsageMetersStatusEnum = typeof EventPipelineInfoUsageMetersStatusEnum[keyof typeof EventPipelineInfoUsageMetersStatusEnum];

/**
 * Structure of an event schema
 * @export
 * @interface EventSchema
 */
export interface EventSchema {
    /**
     * Name of the event. Must be unique for an organization.
     * @type {string}
     * @memberof EventSchema
     */
    'name': string;
    /**
     * Description of the event
     * @type {string}
     * @memberof EventSchema
     */
    'description'?: string;
    /**
     * Version of event schema
     * @type {number}
     * @memberof EventSchema
     */
    'version': number;
    /**
     * Status of event schema * DRAFT - Schema is in draft state  * ACTIVE - Schema is currently active  * INACTIVE - Schema is currently inactive * ARCHIVED - Older version of event schema 
     * @type {string}
     * @memberof EventSchema
     */
    'status'?: EventSchemaStatusEnum;
    /**
     * 
     * @type {Array<EventAttributeSchema>}
     * @memberof EventSchema
     */
    'attributes'?: Array<EventAttributeSchema>;
    /**
     * 
     * @type {Array<DimensionsSchema>}
     * @memberof EventSchema
     */
    'dimensions'?: Array<DimensionsSchema>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventSchema
     */
    'filterFields'?: Array<string>;
    /**
     * 
     * @type {FeatureDetails}
     * @memberof EventSchema
     */
    'featureDetails'?: FeatureDetails;
    /**
     * 
     * @type {Enrichments}
     * @memberof EventSchema
     */
    'enrichments'?: Enrichments;
    /**
     * Template used to generate event id based on event payload
     * @type {string}
     * @memberof EventSchema
     */
    'eventIdTemplate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EventSchema
     */
    'eventLevelRevenue'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EventSchema
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSchema
     */
    'updatedAt'?: string;
}

export const EventSchemaStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type EventSchemaStatusEnum = typeof EventSchemaStatusEnum[keyof typeof EventSchemaStatusEnum];

/**
 * 
 * @export
 * @interface EventSchemaListData
 */
export interface EventSchemaListData {
    /**
     * Name of the event. Must be unique for an organization.
     * @type {string}
     * @memberof EventSchemaListData
     */
    'name': string;
    /**
     * Description of the event
     * @type {string}
     * @memberof EventSchemaListData
     */
    'description'?: string;
    /**
     * Version of event schema
     * @type {number}
     * @memberof EventSchemaListData
     */
    'version': number;
    /**
     * Status of event schema * DRAFT - Schema is in draft state  * ACTIVE - Schema is currently active  * INACTIVE - Schema is currently inactive * ARCHIVED - Older version of event schema 
     * @type {string}
     * @memberof EventSchemaListData
     */
    'status'?: EventSchemaListDataStatusEnum;
    /**
     * 
     * @type {Array<EventAttributeSchema>}
     * @memberof EventSchemaListData
     */
    'attributes'?: Array<EventAttributeSchema>;
    /**
     * 
     * @type {Array<DimensionsSchema>}
     * @memberof EventSchemaListData
     */
    'dimensions'?: Array<DimensionsSchema>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventSchemaListData
     */
    'filterFields'?: Array<string>;
    /**
     * 
     * @type {FeatureDetails}
     * @memberof EventSchemaListData
     */
    'featureDetails'?: FeatureDetails;
    /**
     * 
     * @type {Enrichments}
     * @memberof EventSchemaListData
     */
    'enrichments'?: Enrichments;
    /**
     * Template used to generate event id based on event payload
     * @type {string}
     * @memberof EventSchemaListData
     */
    'eventIdTemplate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EventSchemaListData
     */
    'eventLevelRevenue'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EventSchemaListData
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSchemaListData
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventSchemaListData
     */
    'usageMetersCount'?: number;
}

export const EventSchemaListDataStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type EventSchemaListDataStatusEnum = typeof EventSchemaListDataStatusEnum[keyof typeof EventSchemaListDataStatusEnum];

/**
 * 
 * @export
 * @interface EventSchemaListDataAllOf
 */
export interface EventSchemaListDataAllOf {
    /**
     * 
     * @type {number}
     * @memberof EventSchemaListDataAllOf
     */
    'usageMetersCount'?: number;
}
/**
 * 
 * @export
 * @interface EventSchemaListPaginatedResponse
 */
export interface EventSchemaListPaginatedResponse {
    /**
     * 
     * @type {Array<EventSchemaListData>}
     * @memberof EventSchemaListPaginatedResponse
     */
    'data'?: Array<EventSchemaListData>;
    /**
     * 
     * @type {string}
     * @memberof EventSchemaListPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof EventSchemaListPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * Response for event schema versions
 * @export
 * @interface EventSchemaVersionsResponse
 */
export interface EventSchemaVersionsResponse {
    /**
     * 
     * @type {Array<EventSchema>}
     * @memberof EventSchemaVersionsResponse
     */
    'data': Array<EventSchema>;
}
/**
 * event_schema details that are in association with feature
 * @export
 * @interface EventSchemasForFeature
 */
export interface EventSchemasForFeature {
    /**
     * 
     * @type {string}
     * @memberof EventSchemasForFeature
     */
    'schemaName': string;
    /**
     * 
     * @type {string}
     * @memberof EventSchemasForFeature
     */
    'attributeName': string;
}
/**
 * Source of ingestion of event
 * @export
 * @interface EventSource
 */
export interface EventSource {
    /**
     * Unique identifier representing the source
     * @type {string}
     * @memberof EventSource
     */
    'id': string;
    /**
     * Type of source
     * @type {string}
     * @memberof EventSource
     */
    'type': string;
}
/**
 * Raw usage event ingested by the business team and the status of the event ingestion.
 * @export
 * @interface EventWithStatus
 */
export interface EventWithStatus {
    /**
     * Unique id generated by Togai to identify an event uniquely
     * @type {string}
     * @memberof EventWithStatus
     */
    'referenceId': string;
    /**
     * 
     * @type {Event}
     * @memberof EventWithStatus
     */
    'eventPayload': Event;
    /**
     * 
     * @type {IngestionStatus}
     * @memberof EventWithStatus
     */
    'ingestionStatus': IngestionStatus;
    /**
     * The associated account belongs to this customer
     * @type {string}
     * @memberof EventWithStatus
     */
    'customerId'?: string;
    /**
     * 
     * @type {EventSource}
     * @memberof EventWithStatus
     */
    'source'?: EventSource;
    /**
     * Created time stamp of the event. This timestamp must be in ISO 8601 format.
     * @type {string}
     * @memberof EventWithStatus
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface EventWithStatusAndEventPipelineInfo
 */
export interface EventWithStatusAndEventPipelineInfo {
    /**
     * Unique id generated by Togai to identify an event uniquely
     * @type {string}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'referenceId': string;
    /**
     * 
     * @type {Event}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'eventPayload': Event;
    /**
     * 
     * @type {IngestionStatus}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'ingestionStatus': IngestionStatus;
    /**
     * The associated account belongs to this customer
     * @type {string}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'customerId'?: string;
    /**
     * 
     * @type {EventSource}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'source'?: EventSource;
    /**
     * Created time stamp of the event. This timestamp must be in ISO 8601 format.
     * @type {string}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'createdAt': string;
    /**
     * 
     * @type {EventPipelineInfo}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'eventPipelineInfo': EventPipelineInfo;
}
/**
 * 
 * @export
 * @interface EventWithStatusAndEventPipelineInfoAllOf
 */
export interface EventWithStatusAndEventPipelineInfoAllOf {
    /**
     * 
     * @type {EventPipelineInfo}
     * @memberof EventWithStatusAndEventPipelineInfoAllOf
     */
    'eventPipelineInfo': EventPipelineInfo;
}
/**
 * Events Correction response
 * @export
 * @interface EventsCorrectionResponse
 */
export interface EventsCorrectionResponse {
    /**
     * 
     * @type {Array<EventCorrectionInfo>}
     * @memberof EventsCorrectionResponse
     */
    'data': Array<EventCorrectionInfo>;
}
/**
 * Expiry type of grant
 * @export
 * @enum {string}
 */

export const ExpiryType = {
    PricingCycle: 'PRICING_CYCLE',
    NoExpiry: 'NO_EXPIRY',
    Custom: 'CUSTOM'
} as const;

export type ExpiryType = typeof ExpiryType[keyof typeof ExpiryType];


/**
 * external payment reference object
 * @export
 * @interface ExternalPaymentReference
 */
export interface ExternalPaymentReference {
    /**
     * 
     * @type {string}
     * @memberof ExternalPaymentReference
     */
    'sourceName': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalPaymentReference
     */
    'sourceType': ExternalPaymentReferenceSourceTypeEnum;
    /**
     * Check number or Card transaction number
     * @type {string}
     * @memberof ExternalPaymentReference
     */
    'transactionNumber': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalPaymentReference
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ExternalPaymentReference
     */
    'metadata'?: { [key: string]: any; };
}

export const ExternalPaymentReferenceSourceTypeEnum = {
    Gateway: 'GATEWAY',
    Cash: 'CASH',
    Cheque: 'CHEQUE',
    BankTransfer: 'BANK_TRANSFER',
    Card: 'CARD'
} as const;

export type ExternalPaymentReferenceSourceTypeEnum = typeof ExternalPaymentReferenceSourceTypeEnum[keyof typeof ExternalPaymentReferenceSourceTypeEnum];

/**
 * Represents a Feature
 * @export
 * @interface Feature
 */
export interface Feature {
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'billableName'?: string;
    /**
     * Display name of feature. This is an auto-generated field which contains billableName of feature. If billableName is not provided, name will be used as display name. 
     * @type {string}
     * @memberof Feature
     */
    'displayName': string;
    /**
     * Association of a feature with event_schemas
     * @type {Array<EventSchemasForFeature>}
     * @memberof Feature
     */
    'schemaAssociations': Array<EventSchemasForFeature>;
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'updatedAt'?: string;
}
/**
 * Feature configuration object
 * @export
 * @interface FeatureConfig
 */
export interface FeatureConfig {
    /**
     * 
     * @type {string}
     * @memberof FeatureConfig
     */
    'effectiveFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeatureConfig
     */
    'effectiveUntil': string;
    /**
     * 
     * @type {number}
     * @memberof FeatureConfig
     */
    'featureCreditLimit': number;
}
/**
 * Get feature credits response
 * @export
 * @interface FeatureCreditEntry
 */
export interface FeatureCreditEntry {
    /**
     * 
     * @type {string}
     * @memberof FeatureCreditEntry
     */
    'id': string;
    /**
     * Source of the feature credit
     * @type {string}
     * @memberof FeatureCreditEntry
     */
    'source': FeatureCreditEntrySourceEnum;
    /**
     * Status of the feature credit entry
     * @type {string}
     * @memberof FeatureCreditEntry
     */
    'status': FeatureCreditEntryStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof FeatureCreditEntry
     */
    'effectiveFrom': string;
    /**
     * 
     * @type {string}
     * @memberof FeatureCreditEntry
     */
    'effectiveUntil': string;
    /**
     * 
     * @type {number}
     * @memberof FeatureCreditEntry
     */
    'granted'?: number;
    /**
     * 
     * @type {number}
     * @memberof FeatureCreditEntry
     */
    'balance'?: number;
    /**
     * 
     * @type {number}
     * @memberof FeatureCreditEntry
     */
    'used': number;
}

export const FeatureCreditEntrySourceEnum = {
    Entitlement: 'ENTITLEMENT',
    PricePlan: 'PRICE_PLAN',
    Overage: 'OVERAGE',
    Refund: 'REFUND'
} as const;

export type FeatureCreditEntrySourceEnum = typeof FeatureCreditEntrySourceEnum[keyof typeof FeatureCreditEntrySourceEnum];
export const FeatureCreditEntryStatusEnum = {
    Active: 'ACTIVE',
    Expired: 'EXPIRED',
    Voided: 'VOIDED'
} as const;

export type FeatureCreditEntryStatusEnum = typeof FeatureCreditEntryStatusEnum[keyof typeof FeatureCreditEntryStatusEnum];

/**
 * details of feature associated with event schema with attribute name
 * @export
 * @interface FeatureDetails
 */
export interface FeatureDetails {
    /**
     * 
     * @type {string}
     * @memberof FeatureDetails
     */
    'featureId': string;
    /**
     * 
     * @type {string}
     * @memberof FeatureDetails
     */
    'attributeName': string;
}
/**
 * Represents a Feature for List Response
 * @export
 * @interface FeatureListResponse
 */
export interface FeatureListResponse {
    /**
     * 
     * @type {string}
     * @memberof FeatureListResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FeatureListResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FeatureListResponse
     */
    'billableName'?: string;
    /**
     * Display name of feature. This is an auto-generated field which contains billableName of feature. If billableName is not provided, name will be used as display name. 
     * @type {string}
     * @memberof FeatureListResponse
     */
    'displayName': string;
    /**
     * 
     * @type {number}
     * @memberof FeatureListResponse
     */
    'schemaCount': number;
    /**
     * 
     * @type {string}
     * @memberof FeatureListResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof FeatureListResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface FeaturePaginatedListData
 */
export interface FeaturePaginatedListData {
    /**
     * 
     * @type {Array<FeatureListResponse>}
     * @memberof FeaturePaginatedListData
     */
    'data'?: Array<FeatureListResponse>;
    /**
     * 
     * @type {string}
     * @memberof FeaturePaginatedListData
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof FeaturePaginatedListData
     */
    'context'?: PaginationOptions;
}
/**
 * 
 * @export
 * @interface Field
 */
export interface Field {
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'type': FieldTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'enrichmentType': FieldEnrichmentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'value': string;
    /**
     * 
     * @type {number}
     * @memberof Field
     */
    'order': number;
}

export const FieldTypeEnum = {
    Attribute: 'ATTRIBUTE',
    Dimension: 'DIMENSION'
} as const;

export type FieldTypeEnum = typeof FieldTypeEnum[keyof typeof FieldTypeEnum];
export const FieldEnrichmentTypeEnum = {
    Value: 'VALUE',
    JsonLogic: 'JSON_LOGIC',
    JsonLogicFromDependency: 'JSON_LOGIC_FROM_DEPENDENCY'
} as const;

export type FieldEnrichmentTypeEnum = typeof FieldEnrichmentTypeEnum[keyof typeof FieldEnrichmentTypeEnum];

/**
 * 
 * @export
 * @interface FileDownloadUrlResponse
 */
export interface FileDownloadUrlResponse {
    /**
     * 
     * @type {string}
     * @memberof FileDownloadUrlResponse
     */
    'downloadUrl': string;
}
/**
 * 
 * @export
 * @interface FixedFeeRate
 */
export interface FixedFeeRate {
    /**
     * 
     * @type {string}
     * @memberof FixedFeeRate
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof FixedFeeRate
     */
    'rate': number;
}
/**
 * 
 * @export
 * @interface FixedFeeRateCard
 */
export interface FixedFeeRateCard {
    /**
     * Unique Identifier of the attached AddOn
     * @type {string}
     * @memberof FixedFeeRateCard
     */
    'id': string;
    /**
     * Name of the attached AddOn
     * @type {string}
     * @memberof FixedFeeRateCard
     */
    'displayName'?: string;
    /**
     * A tag string to group fixedFeeRateCards
     * @type {string}
     * @memberof FixedFeeRateCard
     */
    'tag'?: string;
    /**
     * 
     * @type {InvoiceTiming}
     * @memberof FixedFeeRateCard
     */
    'invoiceTiming'?: InvoiceTiming;
    /**
     * 
     * @type {FixedFeeType}
     * @memberof FixedFeeRateCard
     */
    'type'?: FixedFeeType;
    /**
     * 
     * @type {Array<CurrencyRateValue>}
     * @memberof FixedFeeRateCard
     */
    'rateValues': Array<CurrencyRateValue>;
    /**
     * 
     * @type {boolean}
     * @memberof FixedFeeRateCard
     */
    'enableProration': boolean;
    /**
     * 
     * @type {RecurrenceConfig}
     * @memberof FixedFeeRateCard
     */
    'recurrenceConfig'?: RecurrenceConfig;
}


/**
 * 
 * @export
 * @interface FixedFeeRevenueSummary
 */
export interface FixedFeeRevenueSummary {
    /**
     * 
     * @type {number}
     * @memberof FixedFeeRevenueSummary
     */
    'revenue': number;
}
/**
 * Fixed fee applies either for a one-time occurrence or for each cycle.
 * @export
 * @enum {string}
 */

export const FixedFeeType = {
    OneTime: 'ONE_TIME',
    Recurring: 'RECURRING'
} as const;

export type FixedFeeType = typeof FixedFeeType[keyof typeof FixedFeeType];


/**
 * Request to get delegate token for customer portal
 * @export
 * @interface GetCustomerPortalDelegateTokenRequest
 */
export interface GetCustomerPortalDelegateTokenRequest {
    /**
     * Identifier of the customer
     * @type {string}
     * @memberof GetCustomerPortalDelegateTokenRequest
     */
    'customerId': string;
    /**
     * Identifier of the accounts under the customer for which access is requested. Maximum of 5 account ids can be provided 
     * @type {Array<string>}
     * @memberof GetCustomerPortalDelegateTokenRequest
     */
    'accountIds'?: Array<string>;
    /**
     * Flag to specify if access for every account under the customer is required
     * @type {boolean}
     * @memberof GetCustomerPortalDelegateTokenRequest
     */
    'allAccountsAccess'?: boolean;
    /**
     * Expiry in seconds from the time of generation.  If not provided, generated token will have the expiry of the token used for requesting. 
     * @type {number}
     * @memberof GetCustomerPortalDelegateTokenRequest
     */
    'expiry'?: number;
}
/**
 * 
 * @export
 * @interface GetEntitlementValuesResponse
 */
export interface GetEntitlementValuesResponse {
    /**
     * 
     * @type {Array<GetEntitlementValuesResponseDataInner>}
     * @memberof GetEntitlementValuesResponse
     */
    'data': Array<GetEntitlementValuesResponseDataInner>;
}
/**
 * 
 * @export
 * @interface GetEntitlementValuesResponseDataInner
 */
export interface GetEntitlementValuesResponseDataInner {
    /**
     * Feature ID
     * @type {string}
     * @memberof GetEntitlementValuesResponseDataInner
     */
    'featureId': string;
    /**
     * Value of the feature
     * @type {string}
     * @memberof GetEntitlementValuesResponseDataInner
     */
    'value': string;
}
/**
 * Get single event response
 * @export
 * @interface GetEventResponse
 */
export interface GetEventResponse {
    /**
     * 
     * @type {Array<EventWithStatusAndEventPipelineInfo>}
     * @memberof GetEventResponse
     */
    'events': Array<EventWithStatusAndEventPipelineInfo>;
}
/**
 * Get batch events response
 * @export
 * @interface GetEventsResponse
 */
export interface GetEventsResponse {
    /**
     * 
     * @type {Array<EventWithStatus>}
     * @memberof GetEventsResponse
     */
    'events': Array<EventWithStatus>;
    /**
     * 
     * @type {string}
     * @memberof GetEventsResponse
     */
    'nextToken'?: string;
}
/**
 * 
 * @export
 * @interface GetFeatureCreditEntriesPaginatedResponse
 */
export interface GetFeatureCreditEntriesPaginatedResponse {
    /**
     * 
     * @type {Array<FeatureCreditEntry>}
     * @memberof GetFeatureCreditEntriesPaginatedResponse
     */
    'data'?: Array<FeatureCreditEntry>;
    /**
     * 
     * @type {string}
     * @memberof GetFeatureCreditEntriesPaginatedResponse
     */
    'nextToken'?: string;
}
/**
 * Get feature credits response
 * @export
 * @interface GetFeatureCreditsResponse
 */
export interface GetFeatureCreditsResponse {
    /**
     * 
     * @type {string}
     * @memberof GetFeatureCreditsResponse
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof GetFeatureCreditsResponse
     */
    'featureId': string;
    /**
     * 
     * @type {number}
     * @memberof GetFeatureCreditsResponse
     */
    'granted': number;
    /**
     * 
     * @type {number}
     * @memberof GetFeatureCreditsResponse
     */
    'balance': number;
    /**
     * 
     * @type {number}
     * @memberof GetFeatureCreditsResponse
     */
    'overageLimit'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetFeatureCreditsResponse
     */
    'usedOverage': number;
}
/**
 * 
 * @export
 * @interface GetJobResponse
 */
export interface GetJobResponse {
    /**
     * 
     * @type {string}
     * @memberof GetJobResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetJobResponse
     */
    'type': GetJobResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GetJobResponse
     */
    'settledAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJobResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetJobResponse
     */
    'status': GetJobResponseStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof GetJobResponse
     */
    'totalJobEntries': number;
    /**
     * 
     * @type {number}
     * @memberof GetJobResponse
     */
    'pendingJobEntries': number;
    /**
     * 
     * @type {number}
     * @memberof GetJobResponse
     */
    'failedJobEntries': number;
    /**
     * 
     * @type {number}
     * @memberof GetJobResponse
     */
    'completedJobEntries': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GetJobResponse
     */
    'metadata'?: { [key: string]: string; };
}

export const GetJobResponseTypeEnum = {
    PricePlan: 'PRICE_PLAN',
    EventCorrections: 'EVENT_CORRECTIONS',
    BillRun: 'BILL_RUN'
} as const;

export type GetJobResponseTypeEnum = typeof GetJobResponseTypeEnum[keyof typeof GetJobResponseTypeEnum];
export const GetJobResponseStatusEnum = {
    Scheduled: 'SCHEDULED',
    Pending: 'PENDING',
    Initialized: 'INITIALIZED',
    WaitingForConfirmation: 'WAITING_FOR_CONFIRMATION',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Cancelled: 'CANCELLED'
} as const;

export type GetJobResponseStatusEnum = typeof GetJobResponseStatusEnum[keyof typeof GetJobResponseStatusEnum];

/**
 * Get license updates response
 * @export
 * @interface GetLicenseUpdatesResponse
 */
export interface GetLicenseUpdatesResponse {
    /**
     * 
     * @type {Array<LicenseUpdateResponse>}
     * @memberof GetLicenseUpdatesResponse
     */
    'data': Array<LicenseUpdateResponse>;
    /**
     * 
     * @type {string}
     * @memberof GetLicenseUpdatesResponse
     */
    'nextToken'?: string;
}
/**
 * Request to get metrics from togai
 * @export
 * @interface GetMetricsRequest
 */
export interface GetMetricsRequest {
    /**
     * Start date time of the query (inclusive)
     * @type {string}
     * @memberof GetMetricsRequest
     */
    'startTime': string;
    /**
     * End date time of the query (exclusive)
     * @type {string}
     * @memberof GetMetricsRequest
     */
    'endTime': string;
    /**
     * 
     * @type {Array<MetricQuery>}
     * @memberof GetMetricsRequest
     */
    'metricQueries': Array<MetricQuery>;
}
/**
 * Response to GetMetrics Request
 * @export
 * @interface GetMetricsResponse
 */
export interface GetMetricsResponse {
    /**
     * 
     * @type {Array<MetricQueryResponse>}
     * @memberof GetMetricsResponse
     */
    'results': Array<MetricQueryResponse>;
}
/**
 * 
 * @export
 * @interface GetProposalResponse
 */
export interface GetProposalResponse {
    /**
     * 
     * @type {string}
     * @memberof GetProposalResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetProposalResponse
     */
    'accountId': string;
    /**
     * Id of the price plan, Required for ENTITLEMENT_GRANT, ASSOCIATION purchase
     * @type {string}
     * @memberof GetProposalResponse
     */
    'pricePlanId'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetProposalResponse
     */
    'quantity'?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetProposalResponse
     */
    'rateCardQuantities'?: { [key: string]: number; };
    /**
     * 
     * @type {string}
     * @memberof GetProposalResponse
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetProposalResponse
     */
    'pricePlanVersion'?: number;
    /**
     * 
     * @type {PricePlanDetailsOverride}
     * @memberof GetProposalResponse
     */
    'purchasePlanOverride'?: PricePlanDetailsOverride;
    /**
     * 
     * @type {CreatePricePlanDetailsOverride}
     * @memberof GetProposalResponse
     */
    'associationOverride'?: CreatePricePlanDetailsOverride;
    /**
     * 
     * @type {WalletTopupDetails}
     * @memberof GetProposalResponse
     */
    'walletTopupDetails'?: WalletTopupDetails;
    /**
     * 
     * @type {string}
     * @memberof GetProposalResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetProposalResponse
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetProposalResponse
     */
    'effectiveFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetProposalResponse
     */
    'effectiveUntil'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetProposalResponse
     */
    'expiryDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetProposalResponse
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetProposalResponse
     */
    'invoiceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetProposalResponse
     */
    'invoiceCurrency'?: string;
    /**
     * 
     * @type {PurchaseStatus}
     * @memberof GetProposalResponse
     */
    'status': PurchaseStatus;
    /**
     * 
     * @type {PurchaseType}
     * @memberof GetProposalResponse
     */
    'type': PurchaseType;
    /**
     * 
     * @type {string}
     * @memberof GetProposalResponse
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetProposalResponse
     */
    'paymentMode': GetProposalResponsePaymentModeEnum;
    /**
     * 
     * @type {string}
     * @memberof GetProposalResponse
     */
    'proposalResponseDate'?: string;
}

export const GetProposalResponsePaymentModeEnum = {
    Prepaid: 'PREPAID',
    Postpaid: 'POSTPAID'
} as const;

export type GetProposalResponsePaymentModeEnum = typeof GetProposalResponsePaymentModeEnum[keyof typeof GetProposalResponsePaymentModeEnum];

/**
 * 
 * @export
 * @interface GetPurchaseResponse
 */
export interface GetPurchaseResponse {
    /**
     * 
     * @type {string}
     * @memberof GetPurchaseResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetPurchaseResponse
     */
    'accountId': string;
    /**
     * Id of the price plan, Required for ENTITLEMENT_GRANT, ASSOCIATION purchase
     * @type {string}
     * @memberof GetPurchaseResponse
     */
    'pricePlanId'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetPurchaseResponse
     */
    'quantity'?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetPurchaseResponse
     */
    'rateCardQuantities'?: { [key: string]: number; };
    /**
     * 
     * @type {string}
     * @memberof GetPurchaseResponse
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetPurchaseResponse
     */
    'pricePlanVersion'?: number;
    /**
     * 
     * @type {PricePlanDetailsOverride}
     * @memberof GetPurchaseResponse
     */
    'purchasePlanOverride'?: PricePlanDetailsOverride;
    /**
     * 
     * @type {CreatePricePlanDetailsOverride}
     * @memberof GetPurchaseResponse
     */
    'associationOverride'?: CreatePricePlanDetailsOverride;
    /**
     * 
     * @type {WalletTopupDetails}
     * @memberof GetPurchaseResponse
     */
    'walletTopupDetails'?: WalletTopupDetails;
    /**
     * 
     * @type {string}
     * @memberof GetPurchaseResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetPurchaseResponse
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPurchaseResponse
     */
    'effectiveFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPurchaseResponse
     */
    'effectiveUntil'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPurchaseResponse
     */
    'expiryDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetPurchaseResponse
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetPurchaseResponse
     */
    'invoiceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPurchaseResponse
     */
    'invoiceCurrency'?: string;
    /**
     * 
     * @type {PurchaseStatus}
     * @memberof GetPurchaseResponse
     */
    'status': PurchaseStatus;
    /**
     * 
     * @type {PurchaseType}
     * @memberof GetPurchaseResponse
     */
    'type': PurchaseType;
    /**
     * 
     * @type {string}
     * @memberof GetPurchaseResponse
     */
    'comment'?: string;
    /**
     * 
     * @type {PricePlanDetails}
     * @memberof GetPurchaseResponse
     */
    'purchasePlan'?: PricePlanDetails;
    /**
     * 
     * @type {Array<PurchaseFeatureDetails>}
     * @memberof GetPurchaseResponse
     */
    'features'?: Array<PurchaseFeatureDetails>;
}


/**
 * 
 * @export
 * @interface GetPurchaseResponseAllOf
 */
export interface GetPurchaseResponseAllOf {
    /**
     * 
     * @type {PricePlanDetails}
     * @memberof GetPurchaseResponseAllOf
     */
    'purchasePlan'?: PricePlanDetails;
    /**
     * 
     * @type {Array<PurchaseFeatureDetails>}
     * @memberof GetPurchaseResponseAllOf
     */
    'features'?: Array<PurchaseFeatureDetails>;
}
/**
 * Grant details of Credit Grant Rate Card
 * @export
 * @interface GrantDetails
 */
export interface GrantDetails {
    /**
     * 
     * @type {number}
     * @memberof GrantDetails
     */
    'priority': number;
    /**
     * 
     * @type {ExpiryType}
     * @memberof GrantDetails
     */
    'expiryType': ExpiryType;
    /**
     * 
     * @type {string}
     * @memberof GrantDetails
     */
    'expiryDuration'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GrantDetails
     */
    'applicableEntityIds'?: Array<string>;
}


/**
 * Payload for ingesting batch events
 * @export
 * @interface IngestBatchEventRequest
 */
export interface IngestBatchEventRequest {
    /**
     * 
     * @type {Array<Event>}
     * @memberof IngestBatchEventRequest
     */
    'events': Array<Event>;
}
/**
 * Payload for ingesting events
 * @export
 * @interface IngestEventRequest
 */
export interface IngestEventRequest {
    /**
     * 
     * @type {Event}
     * @memberof IngestEventRequest
     */
    'event': Event;
}
/**
 * 
 * @export
 * @interface IngestEventResponse
 */
export interface IngestEventResponse {
    /**
     * 
     * @type {boolean}
     * @memberof IngestEventResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof IngestEventResponse
     */
    'statusCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof IngestEventResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof IngestEventResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof IngestEventResponse
     */
    'code'?: string;
    /**
     * 
     * @type {object}
     * @memberof IngestEventResponse
     */
    'details'?: object;
}
/**
 * Status about the event ingestion.
 * @export
 * @interface IngestionStatus
 */
export interface IngestionStatus {
    /**
     * Ingestion status
     * @type {string}
     * @memberof IngestionStatus
     */
    'status': IngestionStatusStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof IngestionStatus
     */
    'statusDescription'?: string;
}

export const IngestionStatusStatusEnum = {
    IngestionInProgress: 'INGESTION_IN_PROGRESS',
    IngestionFailed: 'INGESTION_FAILED',
    IngestionFailedSchemaNotDefined: 'INGESTION_FAILED_SCHEMA_NOT_DEFINED',
    IngestionFailedEnrichmentFailed: 'INGESTION_FAILED_ENRICHMENT_FAILED',
    IngestionFailedUnitsInvalid: 'INGESTION_FAILED_UNITS_INVALID',
    IngestionCompletedNoMatchingMeters: 'INGESTION_COMPLETED_NO_MATCHING_METERS',
    IngestionCompletedEventMetered: 'INGESTION_COMPLETED_EVENT_METERED',
    IngestionCompletedEventNotMetered: 'INGESTION_COMPLETED_EVENT_NOT_METERED',
    IngestionFailedPastGracePeriod: 'INGESTION_FAILED_PAST_GRACE_PERIOD',
    IngestionFailedAccountNotFound: 'INGESTION_FAILED_ACCOUNT_NOT_FOUND',
    IngestionFailedDuplicateEvent: 'INGESTION_FAILED_DUPLICATE_EVENT',
    IngestionFailedNoEventId: 'INGESTION_FAILED_NO_EVENT_ID',
    IngestionFailedInvalidNamedLicenseEvent: 'INGESTION_FAILED_INVALID_NAMED_LICENSE_EVENT',
    IngestionFailedInsufficientCredits: 'INGESTION_FAILED_INSUFFICIENT_CREDITS',
    Reverted: 'REVERTED',
    Unknown: 'UNKNOWN'
} as const;

export type IngestionStatusStatusEnum = typeof IngestionStatusStatusEnum[keyof typeof IngestionStatusStatusEnum];

/**
 * Structure of invoice
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * Identifier of invoice
     * @type {string}
     * @memberof Invoice
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'customerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'ownerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'pricePlanId'?: string;
    /**
     * 
     * @type {Array<InvoiceLineItem>}
     * @memberof Invoice
     */
    'usageInfo'?: Array<InvoiceLineItem>;
    /**
     * 
     * @type {InvoiceLineItem}
     * @memberof Invoice
     */
    'revenueInfo'?: InvoiceLineItem;
    /**
     * 
     * @type {InvoiceDetails}
     * @memberof Invoice
     */
    'invoiceDetails'?: InvoiceDetails;
    /**
     * Status of the invoice
     * @type {string}
     * @memberof Invoice
     */
    'status': InvoiceStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'finalizingStatus'?: InvoiceFinalizingStatusEnum;
    /**
     * Represents the class of entity( INVOICE/ORDER/BILLABLE)
     * @type {string}
     * @memberof Invoice
     */
    'invoiceClass': InvoiceInvoiceClassEnum;
    /**
     * Represents the type of entity(STANDARD/AD_HOC/COMPOSITE)
     * @type {string}
     * @memberof Invoice
     */
    'invoiceType': InvoiceInvoiceTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Invoice
     */
    'autoAdvance'?: boolean;
    /**
     * Start date of the invoice
     * @type {string}
     * @memberof Invoice
     */
    'startDate'?: string;
    /**
     * End date of the invoice
     * @type {string}
     * @memberof Invoice
     */
    'endDate'?: string;
    /**
     * Inclusive end date of the invoice
     * @type {string}
     * @memberof Invoice
     */
    'endDateInclusive'?: string;
    /**
     * Invoice date of the invoice
     * @type {string}
     * @memberof Invoice
     */
    'invoiceDate': string;
    /**
     * Due date of the invoice
     * @type {string}
     * @memberof Invoice
     */
    'dueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'generatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'updatedAt': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Invoice
     */
    'metadata'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<InvoiceInfoInner>}
     * @memberof Invoice
     */
    'info'?: Array<InvoiceInfoInner>;
    /**
     * Sequence id of the invoice
     * @type {string}
     * @memberof Invoice
     */
    'sequenceId'?: string;
    /**
     * Download URL of the pdf file corresponding to the invoice
     * @type {string}
     * @memberof Invoice
     */
    'pdfUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'totalAmount': number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'paidAmount': number;
    /**
     * Number of days from the invoice date after which an invoice is considered overdue.
     * @type {number}
     * @memberof Invoice
     */
    'netTermDays': number;
}

export const InvoiceStatusEnum = {
    Draft: 'DRAFT',
    Due: 'DUE',
    Paid: 'PAID',
    Void: 'VOID',
    UnCollectible: 'UN_COLLECTIBLE',
    RefundInitiated: 'REFUND_INITIATED',
    RefundCompleted: 'REFUND_COMPLETED',
    Merged: 'MERGED',
    PartiallyPaid: 'PARTIALLY_PAID'
} as const;

export type InvoiceStatusEnum = typeof InvoiceStatusEnum[keyof typeof InvoiceStatusEnum];
export const InvoiceFinalizingStatusEnum = {
    Finalizing: 'FINALIZING',
    Finalized: 'FINALIZED'
} as const;

export type InvoiceFinalizingStatusEnum = typeof InvoiceFinalizingStatusEnum[keyof typeof InvoiceFinalizingStatusEnum];
export const InvoiceInvoiceClassEnum = {
    Invoice: 'INVOICE',
    Order: 'ORDER',
    Billable: 'BILLABLE'
} as const;

export type InvoiceInvoiceClassEnum = typeof InvoiceInvoiceClassEnum[keyof typeof InvoiceInvoiceClassEnum];
export const InvoiceInvoiceTypeEnum = {
    Standard: 'STANDARD',
    AdHoc: 'AD_HOC',
    Custom: 'CUSTOM',
    Composite: 'COMPOSITE'
} as const;

export type InvoiceInvoiceTypeEnum = typeof InvoiceInvoiceTypeEnum[keyof typeof InvoiceInvoiceTypeEnum];

/**
 * 
 * @export
 * @interface InvoiceDetails
 */
export interface InvoiceDetails {
    /**
     * 
     * @type {InvoiceDetailsCustomer}
     * @memberof InvoiceDetails
     */
    'customer'?: InvoiceDetailsCustomer;
    /**
     * 
     * @type {InvoiceDetailsAccount}
     * @memberof InvoiceDetails
     */
    'account'?: InvoiceDetailsAccount;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetails
     */
    'pricePlanName'?: string;
    /**
     * 
     * @type {InvoiceDetailsInvoiceGroup}
     * @memberof InvoiceDetails
     */
    'invoiceGroup'?: InvoiceDetailsInvoiceGroup;
    /**
     * 
     * @type {InvoiceDetailsOrganization}
     * @memberof InvoiceDetails
     */
    'organization'?: InvoiceDetailsOrganization;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetails
     */
    'logoUrl'?: string;
}
/**
 * 
 * @export
 * @interface InvoiceDetailsAccount
 */
export interface InvoiceDetailsAccount {
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsAccount
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsAccount
     */
    'invoiceCurrency': string;
    /**
     * 
     * @type {Address}
     * @memberof InvoiceDetailsAccount
     */
    'address': Address;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsAccount
     */
    'primaryEmail': string;
}
/**
 * 
 * @export
 * @interface InvoiceDetailsCustomer
 */
export interface InvoiceDetailsCustomer {
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsCustomer
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsCustomer
     */
    'primaryEmail': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsCustomer
     */
    'billingAddress'?: string;
    /**
     * 
     * @type {Address}
     * @memberof InvoiceDetailsCustomer
     */
    'address'?: Address;
}
/**
 * 
 * @export
 * @interface InvoiceDetailsInvoiceGroup
 */
export interface InvoiceDetailsInvoiceGroup {
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsInvoiceGroup
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsInvoiceGroup
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsInvoiceGroup
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceDetailsInvoiceGroup
     */
    'dailyInvoiceConsolidation': boolean;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsInvoiceGroup
     */
    'invoiceCurrency': string;
    /**
     * 
     * @type {Address}
     * @memberof InvoiceDetailsInvoiceGroup
     */
    'address': Address;
}
/**
 * 
 * @export
 * @interface InvoiceDetailsOrganization
 */
export interface InvoiceDetailsOrganization {
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsOrganization
     */
    'businessName': string;
    /**
     * 
     * @type {Address}
     * @memberof InvoiceDetailsOrganization
     */
    'address': Address;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsOrganization
     */
    'primaryEmail': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InvoiceDetailsOrganization
     */
    'metadata'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface InvoiceGroupAccountsPaginatedResponse
 */
export interface InvoiceGroupAccountsPaginatedResponse {
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroupAccountsPaginatedResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroupAccountsPaginatedResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroupAccountsPaginatedResponse
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceGroupAccountsPaginatedResponse
     */
    'dailyInvoiceConsolidation': boolean;
    /**
     * 
     * @type {number}
     * @memberof InvoiceGroupAccountsPaginatedResponse
     */
    'netTermDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroupAccountsPaginatedResponse
     */
    'invoiceCurrency': string;
    /**
     * 
     * @type {Address}
     * @memberof InvoiceGroupAccountsPaginatedResponse
     */
    'billingAddress': Address;
    /**
     * 
     * @type {number}
     * @memberof InvoiceGroupAccountsPaginatedResponse
     */
    'accountsCount': number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroupAccountsPaginatedResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroupAccountsPaginatedResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InvoiceGroupAccountsPaginatedResponse
     */
    'accounts': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroupAccountsPaginatedResponse
     */
    'nextToken'?: string;
}
/**
 * 
 * @export
 * @interface InvoiceGroupAccountsPaginatedResponseAllOf
 */
export interface InvoiceGroupAccountsPaginatedResponseAllOf {
    /**
     * 
     * @type {Array<string>}
     * @memberof InvoiceGroupAccountsPaginatedResponseAllOf
     */
    'accounts': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroupAccountsPaginatedResponseAllOf
     */
    'nextToken'?: string;
}
/**
 * Invoice group details
 * @export
 * @interface InvoiceGroupDetails
 */
export interface InvoiceGroupDetails {
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroupDetails
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroupDetails
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroupDetails
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceGroupDetails
     */
    'dailyInvoiceConsolidation': boolean;
    /**
     * 
     * @type {number}
     * @memberof InvoiceGroupDetails
     */
    'netTermDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroupDetails
     */
    'invoiceCurrency': string;
    /**
     * 
     * @type {Address}
     * @memberof InvoiceGroupDetails
     */
    'billingAddress': Address;
}
/**
 * 
 * @export
 * @interface InvoiceGroupPaginatedResponse
 */
export interface InvoiceGroupPaginatedResponse {
    /**
     * 
     * @type {Array<InvoiceGroups>}
     * @memberof InvoiceGroupPaginatedResponse
     */
    'data'?: Array<InvoiceGroups>;
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroupPaginatedResponse
     */
    'nextToken'?: string;
}
/**
 * 
 * @export
 * @interface InvoiceGroups
 */
export interface InvoiceGroups {
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroups
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroups
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroups
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceGroups
     */
    'dailyInvoiceConsolidation': boolean;
    /**
     * 
     * @type {number}
     * @memberof InvoiceGroups
     */
    'netTermDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroups
     */
    'invoiceCurrency': string;
    /**
     * 
     * @type {Address}
     * @memberof InvoiceGroups
     */
    'billingAddress': Address;
    /**
     * 
     * @type {number}
     * @memberof InvoiceGroups
     */
    'accountsCount': number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroups
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroups
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface InvoiceGroupsAllOf
 */
export interface InvoiceGroupsAllOf {
    /**
     * 
     * @type {number}
     * @memberof InvoiceGroupsAllOf
     */
    'accountsCount': number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroupsAllOf
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceGroupsAllOf
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface InvoiceInfoInner
 */
export interface InvoiceInfoInner {
    /**
     * Type of the information
     * @type {string}
     * @memberof InvoiceInfoInner
     */
    'type': string;
    /**
     * Value of the information
     * @type {string}
     * @memberof InvoiceInfoInner
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface InvoiceLineItem
 */
export interface InvoiceLineItem {
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineItem
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineItem
     */
    'description': string;
    /**
     * Type of the line item - GRAND_TOTAL_AMOUNT: Sum of all total amount of individual invoices in a grouped(composite) invoice - TOTAL_AMOUNT: Total revenue of the invoice - NET_AMOUNT: Net revenue of the invoice ( Gross revenue - Discounts ) - GROSS_AMOUNT: Gross revenue of the invoice  - PRICE_PLAN_AMOUNT: SUB_TOTAL_AMOUNT + true up amount - SUB_TOTAL_AMOUNT: Sum of all rate card revenues - TRUE_UP_AMOUNT: Minimum commitment - SUB_TOTAL_AMOUNT (Always positive) - TOTAL_USAGE: List of all the usage meter usages - USAGE_METER_USAGE: Usage of an usage meter - USAGE_RATE_CARD_AMOUNT: Revenue generated from usage rate card - USAGE_RATE_CARD_SLAB_AMOUNT: Revenue generated from usage rate card slab - FIXED_FEE_RATE_CARD_AMOUNT: Revenue generated from fixed fee rate card - CREDIT_GRANT_RATE_CARD_AMOUNT: : Revenue generated from credit grant rate card - BILLING_ENTITLEMENT_RATE_CARD_AMOUNT: Revenue generated from billing entitlement rate card - ENTITLEMENT_OVERAGE_RATE_CARD_AMOUNT: : Revenue generated from entitlement overage rate card - ENTITLEMENT_OVERAGE_RATE_CARD_SLAB_AMOUNT: Revenue generated from entitlement overage rate card slab - LICENSE_RATE_CARD_AMOUNT: Revenue generated from license rate card - TOTAL_CREDITS: Sum of all credit amounts - SUB_CREDITS: Granted credit value - TOTAL_ADVANCED_FEES: Sum of all advanced fee revenue - ADVANCED_FIXED_FEE: Revenue generated from advanced fixed fee rate card - ADVANCED_LICENSE_RATE_CARD_AMOUNT: Revenue generated from advanced license rate card - ADVANCED_BILLING_ENTITLEMENT_RATE_CARD_AMOUNT: Revenue generated from advanced billing entitlement rate card - ADVANCED_CREDIT_GRANT_RATE_CARD_AMOUNT: Revenue generated from advanced credit grant rate card - TOTAL_MISCELLANEOUS_CHARGES: Net revenue of all MISCELLANEOUS_CHARGE - MISCELLANEOUS_CHARGE: Custom amount added to a DRAFT invoice - TOTAL_PURCHASE_AMOUNT: Net revenue all rate cards in a purchase plan - CUSTOM_AMOUNT: Custom amount added a DRAFT invoice - CUSTOM_TAG: User defined tags given to each rate card - TOTAL_PRICING_RULE_ADDITION_AMOUNT: Sum of all line items added by applying pricing rules - PRICING_RULE_ADDITION_AMOUNT: Amount added to invoice as a result of applying a pricing rule - PRICING_RULE_REVENUE_UPDATE_AMOUNT: Difference in revenue(value) obtained as a result of applying a pricing rule - PRICING_RULE_USAGE_UPDATE_AMOUNT: Difference in usage(quantity) obtained as a result of applying a pricing rule - RATE_CONFIG_ADJUSTMENT_AMOUNT: Difference in revenue obtained as a result of applying rate config[\'minimumRate\', \'maximumRate\'] at rate card level 
     * @type {string}
     * @memberof InvoiceLineItem
     */
    'type': InvoiceLineItemTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLineItem
     */
    'valuePerQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLineItem
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineItem
     */
    'units'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLineItem
     */
    'value': number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof InvoiceLineItem
     */
    'metadata'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<InvoiceLineItem>}
     * @memberof InvoiceLineItem
     */
    'lineItems': Array<InvoiceLineItem>;
}

export const InvoiceLineItemTypeEnum = {
    TotalUsage: 'TOTAL_USAGE',
    UsageMeterUsage: 'USAGE_METER_USAGE',
    GrandTotalAmount: 'GRAND_TOTAL_AMOUNT',
    TotalAmount: 'TOTAL_AMOUNT',
    NetAmount: 'NET_AMOUNT',
    GrossAmount: 'GROSS_AMOUNT',
    SubTotalAmount: 'SUB_TOTAL_AMOUNT',
    PricePlanAmount: 'PRICE_PLAN_AMOUNT',
    FixedFeeRateCardAmount: 'FIXED_FEE_RATE_CARD_AMOUNT',
    CreditGrantRateCardAmount: 'CREDIT_GRANT_RATE_CARD_AMOUNT',
    BillingEntitlementRateCardAmount: 'BILLING_ENTITLEMENT_RATE_CARD_AMOUNT',
    EntitlementOverageRateCardAmount: 'ENTITLEMENT_OVERAGE_RATE_CARD_AMOUNT',
    EntitlementOverageRateCardSlabAmount: 'ENTITLEMENT_OVERAGE_RATE_CARD_SLAB_AMOUNT',
    LicenseRateCardAmount: 'LICENSE_RATE_CARD_AMOUNT',
    UsageCycleAmount: 'USAGE_CYCLE_AMOUNT',
    LicenseRateCardSlabAmount: 'LICENSE_RATE_CARD_SLAB_AMOUNT',
    UsageRateCardAmount: 'USAGE_RATE_CARD_AMOUNT',
    UsageRateCardSlabAmount: 'USAGE_RATE_CARD_SLAB_AMOUNT',
    TotalCredits: 'TOTAL_CREDITS',
    SubCredits: 'SUB_CREDITS',
    TotalAdvancedFees: 'TOTAL_ADVANCED_FEES',
    AdvancedFixedFee: 'ADVANCED_FIXED_FEE',
    AdvancedLicenseRateCardAmount: 'ADVANCED_LICENSE_RATE_CARD_AMOUNT',
    AdvancedBillingEntitlementRateCardAmount: 'ADVANCED_BILLING_ENTITLEMENT_RATE_CARD_AMOUNT',
    AdvancedCreditGrantRateCardAmount: 'ADVANCED_CREDIT_GRANT_RATE_CARD_AMOUNT',
    TotalMiscellaneousCharges: 'TOTAL_MISCELLANEOUS_CHARGES',
    MiscellaneousCharge: 'MISCELLANEOUS_CHARGE',
    TrueUpAmount: 'TRUE_UP_AMOUNT',
    TotalPurchaseAmount: 'TOTAL_PURCHASE_AMOUNT',
    CustomAmount: 'CUSTOM_AMOUNT',
    CustomTag: 'CUSTOM_TAG',
    TotalPricingRuleAdditionAmount: 'TOTAL_PRICING_RULE_ADDITION_AMOUNT',
    PricingRuleAdditionAmount: 'PRICING_RULE_ADDITION_AMOUNT',
    PricingRuleRevenueUpdateAmount: 'PRICING_RULE_REVENUE_UPDATE_AMOUNT',
    PricingRuleUsageUpdateAmount: 'PRICING_RULE_USAGE_UPDATE_AMOUNT',
    RateConfigAdjustmentAmount: 'RATE_CONFIG_ADJUSTMENT_AMOUNT',
    TotalTaxAmount: 'TOTAL_TAX_AMOUNT',
    TaxAmount: 'TAX_AMOUNT',
    ProxyAmount: 'PROXY_AMOUNT'
} as const;

export type InvoiceLineItemTypeEnum = typeof InvoiceLineItemTypeEnum[keyof typeof InvoiceLineItemTypeEnum];

/**
 * Structure of invoice response
 * @export
 * @interface InvoiceSummary
 */
export interface InvoiceSummary {
    /**
     * Identifier of invoice
     * @type {string}
     * @memberof InvoiceSummary
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceSummary
     */
    'customerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceSummary
     */
    'ownerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceSummary
     */
    'pricePlanId'?: string;
    /**
     * Status of the invoice
     * @type {string}
     * @memberof InvoiceSummary
     */
    'status': InvoiceSummaryStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoiceSummary
     */
    'finalizingStatus'?: InvoiceSummaryFinalizingStatusEnum;
    /**
     * Represents the class of entity( INVOICE/ORDER/BILLABLE)
     * @type {string}
     * @memberof InvoiceSummary
     */
    'invoiceClass': InvoiceSummaryInvoiceClassEnum;
    /**
     * Represents the type of entity(STANDARD/AD_HOC/COMPOSITE)
     * @type {string}
     * @memberof InvoiceSummary
     */
    'invoiceType': InvoiceSummaryInvoiceTypeEnum;
    /**
     * Start date of the invoice
     * @type {string}
     * @memberof InvoiceSummary
     */
    'startDate'?: string;
    /**
     * End date of the invoice
     * @type {string}
     * @memberof InvoiceSummary
     */
    'endDate'?: string;
    /**
     * Inclusive end date of the invoice
     * @type {string}
     * @memberof InvoiceSummary
     */
    'endDateInclusive'?: string;
    /**
     * Invoice date of the invoice
     * @type {string}
     * @memberof InvoiceSummary
     */
    'invoiceDate': string;
    /**
     * Due date of the invoice
     * @type {string}
     * @memberof InvoiceSummary
     */
    'dueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceSummary
     */
    'generatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceSummary
     */
    'updatedAt': string;
    /**
     * Sequence id of the invoice
     * @type {string}
     * @memberof InvoiceSummary
     */
    'sequenceId'?: string;
    /**
     * Download URL of the pdf file corresponding to the invoice
     * @type {string}
     * @memberof InvoiceSummary
     */
    'pdfUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceSummary
     */
    'totalAmount': number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceSummary
     */
    'paidAmount': number;
    /**
     * 
     * @type {InvoiceDetails}
     * @memberof InvoiceSummary
     */
    'invoiceDetails'?: InvoiceDetails;
    /**
     * Number of days from the invoice date after which an invoice is considered overdue.
     * @type {number}
     * @memberof InvoiceSummary
     */
    'netTermDays': number;
}

export const InvoiceSummaryStatusEnum = {
    Draft: 'DRAFT',
    Due: 'DUE',
    Paid: 'PAID',
    Void: 'VOID',
    UnCollectible: 'UN_COLLECTIBLE',
    RefundInitiated: 'REFUND_INITIATED',
    RefundCompleted: 'REFUND_COMPLETED',
    Merged: 'MERGED',
    PartiallyPaid: 'PARTIALLY_PAID'
} as const;

export type InvoiceSummaryStatusEnum = typeof InvoiceSummaryStatusEnum[keyof typeof InvoiceSummaryStatusEnum];
export const InvoiceSummaryFinalizingStatusEnum = {
    Finalizing: 'FINALIZING',
    Finalized: 'FINALIZED'
} as const;

export type InvoiceSummaryFinalizingStatusEnum = typeof InvoiceSummaryFinalizingStatusEnum[keyof typeof InvoiceSummaryFinalizingStatusEnum];
export const InvoiceSummaryInvoiceClassEnum = {
    Invoice: 'INVOICE',
    Order: 'ORDER',
    Billable: 'BILLABLE'
} as const;

export type InvoiceSummaryInvoiceClassEnum = typeof InvoiceSummaryInvoiceClassEnum[keyof typeof InvoiceSummaryInvoiceClassEnum];
export const InvoiceSummaryInvoiceTypeEnum = {
    Standard: 'STANDARD',
    AdHoc: 'AD_HOC',
    Custom: 'CUSTOM',
    Composite: 'COMPOSITE'
} as const;

export type InvoiceSummaryInvoiceTypeEnum = typeof InvoiceSummaryInvoiceTypeEnum[keyof typeof InvoiceSummaryInvoiceTypeEnum];

/**
 * If IN_ADVANCE, the rate card will be invoiced in the previous billing cycle. If IN_ARREARS, the rate card will be invoiced in the current billing cycle. If PREPAID, credits/entitlements will be granted only after invoice is paid 
 * @export
 * @enum {string}
 */

export const InvoiceTiming = {
    IN_ADVANCE: 'IN_ADVANCE',
    IN_ARREARS: 'IN_ARREARS',
    PREPAID: 'PREPAID'
} as const;

export type InvoiceTiming = typeof InvoiceTiming[keyof typeof InvoiceTiming];


/**
 * 
 * @export
 * @interface JobEntriesPaginatedResponse
 */
export interface JobEntriesPaginatedResponse {
    /**
     * 
     * @type {Array<JobEntriesResponse>}
     * @memberof JobEntriesPaginatedResponse
     */
    'data'?: Array<JobEntriesResponse>;
    /**
     * 
     * @type {string}
     * @memberof JobEntriesPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof JobEntriesPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * 
 * @export
 * @interface JobEntriesResponse
 */
export interface JobEntriesResponse {
    /**
     * 
     * @type {string}
     * @memberof JobEntriesResponse
     */
    'entityId': string;
    /**
     * 
     * @type {string}
     * @memberof JobEntriesResponse
     */
    'jobId': string;
    /**
     * 
     * @type {string}
     * @memberof JobEntriesResponse
     */
    'status': JobEntriesResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof JobEntriesResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof JobEntriesResponse
     */
    'metadata'?: { [key: string]: string; };
}

export const JobEntriesResponseStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Cancelled: 'CANCELLED'
} as const;

export type JobEntriesResponseStatusEnum = typeof JobEntriesResponseStatusEnum[keyof typeof JobEntriesResponseStatusEnum];

/**
 * 
 * @export
 * @interface JobsPaginatedResponse
 */
export interface JobsPaginatedResponse {
    /**
     * 
     * @type {Array<JobsWithoutStatusInfoResponse>}
     * @memberof JobsPaginatedResponse
     */
    'data'?: Array<JobsWithoutStatusInfoResponse>;
    /**
     * 
     * @type {string}
     * @memberof JobsPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof JobsPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * 
 * @export
 * @interface JobsWithoutStatusInfoResponse
 */
export interface JobsWithoutStatusInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof JobsWithoutStatusInfoResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof JobsWithoutStatusInfoResponse
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof JobsWithoutStatusInfoResponse
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof JobsWithoutStatusInfoResponse
     */
    'updatedAt': string;
}
/**
 * Configuration for getting the license entries
 * @export
 * @interface LicenseEntriesConfig
 */
export interface LicenseEntriesConfig {
    /**
     * Mode to get the license entries for the license rate cards - CUSTOM: Use the license entries provided in the request - LOOKUP_RANGE: Use the license entries of a given account for the specified range - LOOKUP_CYCLE: Use the license entries of a given account for the specified cycle 
     * @type {string}
     * @memberof LicenseEntriesConfig
     */
    'mode': LicenseEntriesConfigModeEnum;
    /**
     * List of license entries, this will be considered if mode is CUSTOM
     * @type {Array<LicenseEntry>}
     * @memberof LicenseEntriesConfig
     */
    'custom'?: Array<LicenseEntry>;
    /**
     * 
     * @type {LicenseEntriesConfigLookupRange}
     * @memberof LicenseEntriesConfig
     */
    'lookupRange'?: LicenseEntriesConfigLookupRange;
    /**
     * 
     * @type {LicenseEntriesConfigLookupCycle}
     * @memberof LicenseEntriesConfig
     */
    'lookupCycle'?: LicenseEntriesConfigLookupCycle;
}

export const LicenseEntriesConfigModeEnum = {
    Custom: 'CUSTOM',
    LookupRange: 'LOOKUP_RANGE',
    LookupCycle: 'LOOKUP_CYCLE'
} as const;

export type LicenseEntriesConfigModeEnum = typeof LicenseEntriesConfigModeEnum[keyof typeof LicenseEntriesConfigModeEnum];

/**
 * Cycle of license entries to be looked up, this will be considered if mode is LOOKUP_CYCLE
 * @export
 * @interface LicenseEntriesConfigLookupCycle
 */
export interface LicenseEntriesConfigLookupCycle {
    /**
     * Effective date of the cycle, will be used to get the license entries of the cycle
     * @type {string}
     * @memberof LicenseEntriesConfigLookupCycle
     */
    'cycleEffectiveOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof LicenseEntriesConfigLookupCycle
     */
    'accountId': string;
}
/**
 * Range of license entries to be looked up, this will be considered if mode is LOOKUP_RANGE
 * @export
 * @interface LicenseEntriesConfigLookupRange
 */
export interface LicenseEntriesConfigLookupRange {
    /**
     * 
     * @type {string}
     * @memberof LicenseEntriesConfigLookupRange
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof LicenseEntriesConfigLookupRange
     */
    'end': string;
    /**
     * 
     * @type {string}
     * @memberof LicenseEntriesConfigLookupRange
     */
    'accountId': string;
}
/**
 * 
 * @export
 * @interface LicenseEntry
 */
export interface LicenseEntry {
    /**
     * 
     * @type {string}
     * @memberof LicenseEntry
     */
    'licenseId': string;
    /**
     * 
     * @type {number}
     * @memberof LicenseEntry
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof LicenseEntry
     */
    'effectiveFrom': string;
}
/**
 * License Entry Details update request
 * @export
 * @interface LicenseEntryDetailsUpdateRequest
 */
export interface LicenseEntryDetailsUpdateRequest {
    /**
     * The account id for which the license is being updated
     * @type {string}
     * @memberof LicenseEntryDetailsUpdateRequest
     */
    'accountId': string;
    /**
     * The effective from date of the license entry
     * @type {string}
     * @memberof LicenseEntryDetailsUpdateRequest
     */
    'effectiveFrom': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof LicenseEntryDetailsUpdateRequest
     */
    'metadata': { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface LicenseRate
 */
export interface LicenseRate {
    /**
     * 
     * @type {string}
     * @memberof LicenseRate
     */
    'id': string;
    /**
     * List of slab rates
     * @type {Array<SlabRate>}
     * @memberof LicenseRate
     */
    'slabRates': Array<SlabRate>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof LicenseRate
     */
    'rateConfig'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface LicenseRateCard
 */
export interface LicenseRateCard {
    /**
     * Unique Identifier of the attached AddOn
     * @type {string}
     * @memberof LicenseRateCard
     */
    'id': string;
    /**
     * 
     * @type {AddOnType}
     * @memberof LicenseRateCard
     */
    'type'?: AddOnType;
    /**
     * Name of the attached AddOn
     * @type {string}
     * @memberof LicenseRateCard
     */
    'displayName'?: string;
    /**
     * A tag string to group licenseRateCards
     * @type {string}
     * @memberof LicenseRateCard
     */
    'tag'?: string;
    /**
     * 
     * @type {InvoiceTiming}
     * @memberof LicenseRateCard
     */
    'invoiceTiming'?: InvoiceTiming;
    /**
     * 
     * @type {UsageCycleInterval}
     * @memberof LicenseRateCard
     */
    'usageCycle'?: UsageCycleInterval;
    /**
     * 
     * @type {boolean}
     * @memberof LicenseRateCard
     */
    'enableProration': boolean;
    /**
     * 
     * @type {LicenseRateCardConfig}
     * @memberof LicenseRateCard
     */
    'config'?: LicenseRateCardConfig;
    /**
     * 
     * @type {RatePlan}
     * @memberof LicenseRateCard
     */
    'ratePlan': RatePlan;
    /**
     * 
     * @type {Array<RateValue>}
     * @memberof LicenseRateCard
     */
    'rateValues': Array<RateValue>;
    /**
     * 
     * @type {ProratedRefundMode}
     * @memberof LicenseRateCard
     */
    'proratedRefundMode'?: ProratedRefundMode;
}


/**
 * 
 * @export
 * @interface LicenseRateCardConfig
 */
export interface LicenseRateCardConfig {
    /**
     * Max allowed quantity for a particular license in a price plan
     * @type {number}
     * @memberof LicenseRateCardConfig
     */
    'maxQuantity'?: number;
    /**
     * 
     * @type {MaxQuantityBreachAction}
     * @memberof LicenseRateCardConfig
     */
    'maxQuantityBreachAction'?: MaxQuantityBreachAction;
}


/**
 * License update
 * @export
 * @interface LicenseUpdate
 */
export interface LicenseUpdate {
    /**
     * 
     * @type {string}
     * @memberof LicenseUpdate
     */
    'licenseId': string;
    /**
     * 
     * @type {string}
     * @memberof LicenseUpdate
     */
    'accountId': string;
    /**
     * Absolute quantity of the license
     * @type {number}
     * @memberof LicenseUpdate
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof LicenseUpdate
     */
    'effectiveFrom': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof LicenseUpdate
     */
    'metadata'?: { [key: string]: string; };
}
/**
 * License update request
 * @export
 * @interface LicenseUpdateRequest
 */
export interface LicenseUpdateRequest {
    /**
     * The license id for which the update is requested
     * @type {string}
     * @memberof LicenseUpdateRequest
     */
    'licenseId': string;
    /**
     * The account id for which the license is being updated
     * @type {string}
     * @memberof LicenseUpdateRequest
     */
    'accountId': string;
    /**
     * The type of update to be performed
     * @type {string}
     * @memberof LicenseUpdateRequest
     */
    'updateType': LicenseUpdateRequestUpdateTypeEnum;
    /**
     * The quantity to be updated
     * @type {number}
     * @memberof LicenseUpdateRequest
     */
    'quantity': number;
    /**
     * The effective from date for the update
     * @type {string}
     * @memberof LicenseUpdateRequest
     */
    'effectiveFrom'?: string;
    /**
     * The idempotency key for uniqueness of the license update request
     * @type {string}
     * @memberof LicenseUpdateRequest
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof LicenseUpdateRequest
     */
    'metadata'?: { [key: string]: string; };
}

export const LicenseUpdateRequestUpdateTypeEnum = {
    Relative: 'RELATIVE',
    Absolute: 'ABSOLUTE'
} as const;

export type LicenseUpdateRequestUpdateTypeEnum = typeof LicenseUpdateRequestUpdateTypeEnum[keyof typeof LicenseUpdateRequestUpdateTypeEnum];

/**
 * 
 * @export
 * @interface LicenseUpdateResponse
 */
export interface LicenseUpdateResponse {
    /**
     * 
     * @type {string}
     * @memberof LicenseUpdateResponse
     */
    'licenseId': string;
    /**
     * 
     * @type {string}
     * @memberof LicenseUpdateResponse
     */
    'accountId': string;
    /**
     * Absolute quantity of the license
     * @type {number}
     * @memberof LicenseUpdateResponse
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof LicenseUpdateResponse
     */
    'effectiveFrom': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof LicenseUpdateResponse
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof LicenseUpdateResponse
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface LicenseUpdateResponseAllOf
 */
export interface LicenseUpdateResponseAllOf {
    /**
     * 
     * @type {string}
     * @memberof LicenseUpdateResponseAllOf
     */
    'createdAt': string;
}
/**
 * List credits response
 * @export
 * @interface ListCreditsResponse
 */
export interface ListCreditsResponse {
    /**
     * 
     * @type {Array<Credit>}
     * @memberof ListCreditsResponse
     */
    'data': Array<Credit>;
    /**
     * 
     * @type {string}
     * @memberof ListCreditsResponse
     */
    'nextToken'?: string;
}
/**
 * List invoices response
 * @export
 * @interface ListInvoicesResponse
 */
export interface ListInvoicesResponse {
    /**
     * 
     * @type {Array<InvoiceSummary>}
     * @memberof ListInvoicesResponse
     */
    'data': Array<InvoiceSummary>;
    /**
     * 
     * @type {string}
     * @memberof ListInvoicesResponse
     */
    'nextToken'?: string;
}
/**
 * List payments response
 * @export
 * @interface ListPaymentResponse
 */
export interface ListPaymentResponse {
    /**
     * 
     * @type {Array<Payment>}
     * @memberof ListPaymentResponse
     */
    'data': Array<Payment>;
    /**
     * 
     * @type {string}
     * @memberof ListPaymentResponse
     */
    'nextToken'?: string;
}
/**
 * Payload to update custom line items
 * @export
 * @interface ManageMiscellaneousChargesRequest
 */
export interface ManageMiscellaneousChargesRequest {
    /**
     * 
     * @type {Array<MiscellaneousCharge>}
     * @memberof ManageMiscellaneousChargesRequest
     */
    'items': Array<MiscellaneousCharge>;
}
/**
 * Action to be taken when the license maxQuantity is breached:  - `DO_NOTHING`: Refrain from granting any new licenses. 
 * @export
 * @enum {string}
 */

export const MaxQuantityBreachAction = {
    DoNothing: 'DO_NOTHING'
} as const;

export type MaxQuantityBreachAction = typeof MaxQuantityBreachAction[keyof typeof MaxQuantityBreachAction];


/**
 * 
 * @export
 * @interface MetricDataPoints
 */
export interface MetricDataPoints {
    /**
     * 
     * @type {MetricDataPointsGroupedBy}
     * @memberof MetricDataPoints
     */
    'groupedBy'?: MetricDataPointsGroupedBy;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetricDataPoints
     */
    'timestamps': Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof MetricDataPoints
     */
    'metricValues': Array<number>;
}
/**
 * 
 * @export
 * @interface MetricDataPointsGroupedBy
 */
export interface MetricDataPointsGroupedBy {
    /**
     * 
     * @type {string}
     * @memberof MetricDataPointsGroupedBy
     */
    'fieldName': string;
    /**
     * 
     * @type {string}
     * @memberof MetricDataPointsGroupedBy
     */
    'fieldValue': string;
}
/**
 * Define the metric you would like to get - allowed options are EVENTS - Aggregation of raw events, USAGE - Default to METER_USAGE. To be deprecated soon, METER_USAGE - Aggregated usage value from Usage meters, NAMED_LICENSE_USAGE - Aggregated usage value from Named Licenses, REVENUE - Aggregated revenue value from Pricing Plans USAGE_FOR_CYCLE - Usage in pricing cycle REVENUE_FOR_CYCLE - Revenue in pricing cycle 
 * @export
 * @enum {string}
 */

export const MetricName = {
    Events: 'EVENTS',
    Usage: 'USAGE',
    MeterUsage: 'METER_USAGE',
    NamedLicenseUsage: 'NAMED_LICENSE_USAGE',
    Revenue: 'REVENUE',
    UsageForCycle: 'USAGE_FOR_CYCLE',
    RevenueForCycle: 'REVENUE_FOR_CYCLE'
} as const;

export type MetricName = typeof MetricName[keyof typeof MetricName];


/**
 * Object representing a single metrics query
 * @export
 * @interface MetricQuery
 */
export interface MetricQuery {
    /**
     * Mandatory  for all request.  User defined ID for identifying the request for your internal reference 
     * @type {string}
     * @memberof MetricQuery
     */
    'id': string;
    /**
     * 
     * @type {MetricName}
     * @memberof MetricQuery
     */
    'name': MetricName;
    /**
     * Set the aggregation period. Allowed periods are HOUR, DAY, WEEK, MONTH
     * @type {string}
     * @memberof MetricQuery
     */
    'aggregationPeriod': MetricQueryAggregationPeriodEnum;
    /**
     * Group your metric with a groupBy field.  Allowed fields are  ACCOUNT_ID EVENT_STATUS  SCHEMA_NAME  USAGE_METER_ID [Use BILLABLE_ID as this will be deprecated soon...] BILLABLE_ID RAW_EVENT_STATUS Please refer the table above for the list of combinations allowed in the groupBy 
     * @type {string}
     * @memberof MetricQuery
     */
    'groupBy'?: string;
    /**
     * Configurations. | Metric Name       | Config Key | Allowed Values  | Default value |              Description          | |-------------------|------------|-----------------|---------------|-----------------------------------| | REVENUE           | CURRENCY   | BASE or INVOICE | BASE          | currency to return the revenue in | | REVENUE_FOR_CYCLE | CURRENCY   | BASE or INVOICE | BASE          | currency to return the revenue in | 
     * @type {{ [key: string]: string; }}
     * @memberof MetricQuery
     */
    'configs'?: { [key: string]: string; };
    /**
     * Filter on specific fields.  Refer possible fieldNames and fieldValues from the table above. 
     * @type {Array<MetricQueryFilterEntry>}
     * @memberof MetricQuery
     */
    'filters'?: Array<MetricQueryFilterEntry>;
}

export const MetricQueryAggregationPeriodEnum = {
    Hour: 'HOUR',
    Day: 'DAY',
    Week: 'WEEK',
    Month: 'MONTH'
} as const;

export type MetricQueryAggregationPeriodEnum = typeof MetricQueryAggregationPeriodEnum[keyof typeof MetricQueryAggregationPeriodEnum];

/**
 *  | Metric Name       | FilterEntry Name |    Allowed groupBy fields                                           |      Default Values      |                 Allowed Values                                  | |-------------------|------------------|---------------------------------------------------------------------|--------------------------|-----------------------------------------------------------------| | EVENTS            | ACCOUNT_ID       | ACCOUNT_ID, EVENT_STATUS, SCHEMA_NAME, RAW_EVENT_STATUS             | None                     | *\\<one or more valid account IDs>                               | | EVENTS            | CUSTOMER_ID      | ACCOUNT_ID, EVENT_STATUS, SCHEMA_NAME, RAW_EVENT_STATUS             | None                     | *\\<one or more valid customer IDs>                              | | EVENTS            | SCHEMA_NAME      | ACCOUNT_ID, EVENT_STATUS, SCHEMA_NAME, RAW_EVENT_STATUS             | None                     | *\\<at most one valid schema names>                              | | EVENTS            | EVENT_STATUS     | ACCOUNT_ID, EVENT_STATUS, SCHEMA_NAME, RAW_EVENT_STATUS             | [PROCESSED, UNPROCESSED] | oneOrMoreOf PROCESSED, UNPROCESSED, IN_PROGRESS, IngestionStatus|       | USAGE             | ACCOUNT_ID       | ACCOUNT_ID, USAGE_METER_ID, BILLABLE_ID CUSTOMER_ID                 | None                     | *\\<one or more valid account IDs>                               | | USAGE             | CUSTOMER_ID      | ACCOUNT_ID, USAGE_METER_ID, BILLABLE_ID CUSTOMER_ID                 | None                     | *\\<one or more valid customer IDs>                              | | USAGE             | USAGE_METER_ID   | ACCOUNT_ID, USAGE_METER_ID, BILLABLE_ID CUSTOMER_ID                 | None                     | *\\<one or more valid usage meter name>                          | | USAGE             | BILLABLE_ID      | ACCOUNT_ID, USAGE_METER_ID, BILLABLE_ID CUSTOMER_ID                 | None                     | *\\<one or more valid usage meter name>                          | | REVENUE           | ACCOUNT_ID       | ACCOUNT_ID, USAGE_METER_ID, BILLABLE_ID CUSTOMER_ID                 | None                     | *\\<one or more valid account IDs>                               | | REVENUE           | CUSTOMER_ID      | ACCOUNT_ID, USAGE_METER_ID, BILLABLE_ID CUSTOMER_ID                 | None                     | *\\<one or more valid customer IDs>                              | | REVENUE           | USAGE_METER_ID   | ACCOUNT_ID, USAGE_METER_ID, BILLABLE_ID CUSTOMER_ID                 | None                     | *\\<one or more valid usage meter name>                          | | REVENUE           | BILLABLE_ID      | ACCOUNT_ID, USAGE_METER_ID, BILLABLE_ID CUSTOMER_ID                 | None                     | *\\<one or more valid usage meter name>                          | | EVENTS            | ORGANIZATION_ID  | ACCOUNT_ID, USAGE_METER_ID, BILLABLE_ID CUSTOMER_ID                 | <From auth token>        |                                                                 | | USAGE             | ORGANIZATION_ID  | ACCOUNT_ID, USAGE_METER_ID, BILLABLE_ID CUSTOMER_ID                 | <From auth token>        |                                                                 | | REVENUE           | ORGANIZATION_ID  | ACCOUNT_ID, USAGE_METER_ID, BILLABLE_ID CUSTOMER_ID                 | <From auth token>        |                                                                 | | USAGE_FOR_CYCLE   | ACCOUNT_ID       | ACCOUNT_ID, USAGE_METER_ID, BILLABLE_ID CUSTOMER_ID                 | None                     | *\\<one or more valid account IDs>                               | | USAGE_FOR_CYCLE   | CUSTOMER_ID      | ACCOUNT_ID, USAGE_METER_ID, BILLABLE_ID CUSTOMER_ID                 | None                     | *\\<one or more valid customer IDs>                              | | USAGE_FOR_CYCLE   | USAGE_METER_ID   | ACCOUNT_ID, USAGE_METER_ID, BILLABLE_ID CUSTOMER_ID                 | None                     | *\\<one or more valid usage meter name>                          | | USAGE_FOR_CYCLE   | BILLABLE_ID      | ACCOUNT_ID, USAGE_METER_ID, BILLABLE_ID CUSTOMER_ID                 | None                     | *\\<one or more valid usage meter name>                          | | REVENUE_FOR_CYCLE | ACCOUNT_ID       | ACCOUNT_ID, USAGE_METER_ID, BILLABLE_ID CUSTOMER_ID                 | None                     | *\\<one or more valid account IDs>                               | | REVENUE_FOR_CYCLE | CUSTOMER_ID      | ACCOUNT_ID, USAGE_METER_ID, BILLABLE_ID CUSTOMER_ID                 | None                     | *\\<one or more valid customer IDs>                              | | REVENUE_FOR_CYCLE | USAGE_METER_ID   | ACCOUNT_ID, USAGE_METER_ID, BILLABLE_ID CUSTOMER_ID                 | None                     | *\\<one or more valid usage meter name>                          | | REVENUE_FOR_CYCLE | BILLABLE_ID      | ACCOUNT_ID, USAGE_METER_ID, BILLABLE_ID CUSTOMER_ID                 | None                     | *\\<one or more valid usage meter name>                          | 
 * @export
 * @interface MetricQueryFilterEntry
 */
export interface MetricQueryFilterEntry {
    /**
     * 
     * @type {string}
     * @memberof MetricQueryFilterEntry
     */
    'fieldName': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetricQueryFilterEntry
     */
    'fieldValues': Array<string>;
}
/**
 * Response to GetMetrics Request
 * @export
 * @interface MetricQueryResponse
 */
export interface MetricQueryResponse {
    /**
     * 
     * @type {string}
     * @memberof MetricQueryResponse
     */
    'id': string;
    /**
     * 
     * @type {MetricName}
     * @memberof MetricQueryResponse
     */
    'name': MetricName;
    /**
     * 
     * @type {Array<MetricDataPoints>}
     * @memberof MetricQueryResponse
     */
    'data': Array<MetricDataPoints>;
}


/**
 * 
 * @export
 * @interface MinimumCommitment
 */
export interface MinimumCommitment {
    /**
     * 
     * @type {string}
     * @memberof MinimumCommitment
     */
    'displayName': string;
    /**
     * 
     * @type {Array<CurrencyRateValue>}
     * @memberof MinimumCommitment
     */
    'rateValues': Array<CurrencyRateValue>;
}
/**
 * Miscellaneous charges are the charges that can be added to the invoice. A charge must either have rate and quantity or value. In case of rate and quantity, the value must not be provided as it is automatically calculated as (rate * quantity).
 * @export
 * @interface MiscellaneousCharge
 */
export interface MiscellaneousCharge {
    /**
     * Name of the miscellaneous charge
     * @type {string}
     * @memberof MiscellaneousCharge
     */
    'name': string;
    /**
     * Rate of the charge
     * @type {number}
     * @memberof MiscellaneousCharge
     */
    'rate'?: number;
    /**
     * Quantity of the charge
     * @type {number}
     * @memberof MiscellaneousCharge
     */
    'quantity'?: number;
    /**
     * Value of the charge Possible values: 1. Fixed number [Example: 10] 2. Json Logic [Example: {\"*\": [{\"var\": \"um.lineitem.id\"}, 0.1]}]    You can use all line item ids as variables in the json logic 
     * @type {string}
     * @memberof MiscellaneousCharge
     */
    'value'?: string;
    /**
     * Specifies whether to consider this miscellaneous charge for revenue or not
     * @type {boolean}
     * @memberof MiscellaneousCharge
     */
    'considerForRevenue'?: boolean;
}
/**
 * Miscellaneous charges response
 * @export
 * @interface MiscellaneousChargesResponse
 */
export interface MiscellaneousChargesResponse {
    /**
     * 
     * @type {Array<MiscellaneousCharge>}
     * @memberof MiscellaneousChargesResponse
     */
    'data': Array<MiscellaneousCharge>;
}
/**
 * Configuration for getting the named license entries
 * @export
 * @interface NamedLicenseEntriesConfig
 */
export interface NamedLicenseEntriesConfig {
    /**
     * Mode to get the named license entries for the license rate cards - CUSTOM: Use the named license entries provided in the request - LOOKUP_RANGE: Use the named license entries of a given account for the specified range - LOOKUP_CYCLE: Use the named license entries of a given account for the specified cycle 
     * @type {string}
     * @memberof NamedLicenseEntriesConfig
     */
    'mode': NamedLicenseEntriesConfigModeEnum;
    /**
     * List of named license entries, this will be considered if mode is CUSTOM
     * @type {Array<NamedLicenseEntry>}
     * @memberof NamedLicenseEntriesConfig
     */
    'custom'?: Array<NamedLicenseEntry>;
    /**
     * 
     * @type {NamedLicenseEntriesConfigLookupRange}
     * @memberof NamedLicenseEntriesConfig
     */
    'lookupRange'?: NamedLicenseEntriesConfigLookupRange;
    /**
     * 
     * @type {NamedLicenseEntriesConfigLookupCycle}
     * @memberof NamedLicenseEntriesConfig
     */
    'lookupCycle'?: NamedLicenseEntriesConfigLookupCycle;
}

export const NamedLicenseEntriesConfigModeEnum = {
    Custom: 'CUSTOM',
    LookupRange: 'LOOKUP_RANGE',
    LookupCycle: 'LOOKUP_CYCLE'
} as const;

export type NamedLicenseEntriesConfigModeEnum = typeof NamedLicenseEntriesConfigModeEnum[keyof typeof NamedLicenseEntriesConfigModeEnum];

/**
 * Cycle of named license entries to be looked up, this will be considered if mode is LOOKUP_CYCLE
 * @export
 * @interface NamedLicenseEntriesConfigLookupCycle
 */
export interface NamedLicenseEntriesConfigLookupCycle {
    /**
     * Effective date of the cycle, will be used to get the named license entries of the cycle
     * @type {string}
     * @memberof NamedLicenseEntriesConfigLookupCycle
     */
    'cycleEffectiveOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof NamedLicenseEntriesConfigLookupCycle
     */
    'accountId': string;
}
/**
 * Range of named license entries to be looked up, this will be considered if mode is LOOKUP_RANGE
 * @export
 * @interface NamedLicenseEntriesConfigLookupRange
 */
export interface NamedLicenseEntriesConfigLookupRange {
    /**
     * 
     * @type {string}
     * @memberof NamedLicenseEntriesConfigLookupRange
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof NamedLicenseEntriesConfigLookupRange
     */
    'end': string;
    /**
     * 
     * @type {string}
     * @memberof NamedLicenseEntriesConfigLookupRange
     */
    'accountId': string;
}
/**
 * 
 * @export
 * @interface NamedLicenseEntry
 */
export interface NamedLicenseEntry {
    /**
     * 
     * @type {string}
     * @memberof NamedLicenseEntry
     */
    'licenseId': string;
    /**
     * 
     * @type {number}
     * @memberof NamedLicenseEntry
     */
    'name': number;
    /**
     * 
     * @type {string}
     * @memberof NamedLicenseEntry
     */
    'effectiveFrom': string;
    /**
     * 
     * @type {string}
     * @memberof NamedLicenseEntry
     */
    'effectiveUntil'?: string;
}
/**
 * Named License update response
 * @export
 * @interface NamedLicenseUpdate
 */
export interface NamedLicenseUpdate {
    /**
     * 
     * @type {string}
     * @memberof NamedLicenseUpdate
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NamedLicenseUpdate
     */
    'licenseId': string;
    /**
     * 
     * @type {string}
     * @memberof NamedLicenseUpdate
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof NamedLicenseUpdate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NamedLicenseUpdate
     */
    'effectiveFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof NamedLicenseUpdate
     */
    'effectiveUntil'?: string;
    /**
     * 
     * @type {string}
     * @memberof NamedLicenseUpdate
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof NamedLicenseUpdate
     */
    'updatedAt': string;
}
/**
 * Named License updates paginated response
 * @export
 * @interface NamedLicenseUpdatesPaginatedResponse
 */
export interface NamedLicenseUpdatesPaginatedResponse {
    /**
     * 
     * @type {Array<NamedLicenseUpdate>}
     * @memberof NamedLicenseUpdatesPaginatedResponse
     */
    'data': Array<NamedLicenseUpdate>;
    /**
     * 
     * @type {string}
     * @memberof NamedLicenseUpdatesPaginatedResponse
     */
    'nextToken'?: string;
}
/**
 * 
 * @export
 * @interface PaginationOptions
 */
export interface PaginationOptions {
    /**
     * 
     * @type {number}
     * @memberof PaginationOptions
     */
    'pageSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginationOptions
     */
    'sortOrder'?: PaginationOptionsSortOrderEnum;
}

export const PaginationOptionsSortOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type PaginationOptionsSortOrderEnum = typeof PaginationOptionsSortOrderEnum[keyof typeof PaginationOptionsSortOrderEnum];

/**
 * Payment object
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'notes'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'accountId': string;
    /**
     * 
     * @type {ExternalPaymentReference}
     * @memberof Payment
     */
    'externalPaymentReferences': ExternalPaymentReference;
    /**
     * 
     * @type {Array<PaymentLineItemRecord>}
     * @memberof Payment
     */
    'lineItemRecords': Array<PaymentLineItemRecord>;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'totalAmount': number;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'currency': string;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'createdAt': string;
}
/**
 * payment line item record object
 * @export
 * @interface PaymentLineItemRecord
 */
export interface PaymentLineItemRecord {
    /**
     * 
     * @type {string}
     * @memberof PaymentLineItemRecord
     */
    'type': PaymentLineItemRecordTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentLineItemRecord
     */
    'togaiId'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentLineItemRecord
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentLineItemRecord
     */
    'order': number;
}

export const PaymentLineItemRecordTypeEnum = {
    Invoice: 'INVOICE',
    Credit: 'CREDIT',
    WalletCredit: 'WALLET_CREDIT'
} as const;

export type PaymentLineItemRecordTypeEnum = typeof PaymentLineItemRecordTypeEnum[keyof typeof PaymentLineItemRecordTypeEnum];

/**
 * Represents effectiveness period and config of a price plan. i.e, price plan bound by time.
 * @export
 * @interface PlanOverride
 */
export interface PlanOverride {
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'pricePlanId': string;
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'pricePlanName': string;
    /**
     * 
     * @type {PricePlanDetailsOverride}
     * @memberof PlanOverride
     */
    'pricePlanDetailsOverride'?: PricePlanDetailsOverride;
    /**
     * 
     * @type {Array<PricingRule>}
     * @memberof PlanOverride
     */
    'pricingRulesOverride'?: Array<PricingRule>;
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'endDate': string;
}
/**
 * Pre action to be performed before association or disassociation
 * @export
 * @interface PreAction
 */
export interface PreAction {
    /**
     * Type of pre action to be performed
     * @type {string}
     * @memberof PreAction
     */
    'type': PreActionTypeEnum;
    /**
     * Configuration required for performing pre action - `GRANT_LICENSE`: grant one time licenses to an account before association   - `licenseId` [Required]: Id of the license to be granted   - `updateType` [Required]: Type of update to be performed on the license (RELATIVE or ABSOLUTE)   - `quantity` [Required]: Quantity of license to be granted   - `effectiveFrom` [Optional]: Effective date from which the license will be granted 
     * @type {{ [key: string]: string; }}
     * @memberof PreAction
     */
    'config'?: { [key: string]: string; };
}

export const PreActionTypeEnum = {
    GrantLicense: 'GRANT_LICENSE'
} as const;

export type PreActionTypeEnum = typeof PreActionTypeEnum[keyof typeof PreActionTypeEnum];

/**
 * Price plan entity
 * @export
 * @interface PricePlan
 */
export interface PricePlan {
    /**
     * Price plan id
     * @type {string}
     * @memberof PricePlan
     */
    'id': string;
    /**
     * Name of the price plan
     * @type {string}
     * @memberof PricePlan
     */
    'name': string;
    /**
     * 
     * @type {PricePlanType}
     * @memberof PricePlan
     */
    'type': PricePlanType;
    /**
     * Description of price plan
     * @type {string}
     * @memberof PricePlan
     */
    'description'?: string;
    /**
     * Status of Price plan
     * @type {string}
     * @memberof PricePlan
     */
    'status': PricePlanStatusEnum;
    /**
     * 
     * @type {Array<PricingSchedule>}
     * @memberof PricePlan
     */
    'pricingSchedule': Array<PricingSchedule>;
}

export const PricePlanStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type PricePlanStatusEnum = typeof PricePlanStatusEnum[keyof typeof PricePlanStatusEnum];

/**
 * 
 * @export
 * @interface PricePlanDetails
 */
export interface PricePlanDetails {
    /**
     * 
     * @type {Array<string>}
     * @memberof PricePlanDetails
     */
    'supportedCurrencies': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PricePlanDetails
     */
    'activeCurrencies': Array<string>;
    /**
     * 
     * @type {PricingCycleConfig}
     * @memberof PricePlanDetails
     */
    'pricingCycleConfig'?: PricingCycleConfig;
    /**
     * 
     * @type {Array<UsageRateCard>}
     * @memberof PricePlanDetails
     */
    'usageRateCards'?: Array<UsageRateCard>;
    /**
     * 
     * @type {Array<FixedFeeRateCard>}
     * @memberof PricePlanDetails
     */
    'fixedFeeRateCards'?: Array<FixedFeeRateCard>;
    /**
     * 
     * @type {Array<LicenseRateCard>}
     * @memberof PricePlanDetails
     */
    'licenseRateCards'?: Array<LicenseRateCard>;
    /**
     * 
     * @type {Array<BillingEntitlementRateCard>}
     * @memberof PricePlanDetails
     */
    'billingEntitlementRateCards'?: Array<BillingEntitlementRateCard>;
    /**
     * 
     * @type {Array<EntitlementOverageRateCard>}
     * @memberof PricePlanDetails
     */
    'entitlementOverageRateCards'?: Array<EntitlementOverageRateCard>;
    /**
     * 
     * @type {MinimumCommitment}
     * @memberof PricePlanDetails
     */
    'minimumCommitment'?: MinimumCommitment;
    /**
     * 
     * @type {Array<CreditGrantRateCard>}
     * @memberof PricePlanDetails
     */
    'creditGrantRateCards'?: Array<CreditGrantRateCard>;
    /**
     * 
     * @type {PricePlanType}
     * @memberof PricePlanDetails
     */
    'type'?: PricePlanType;
    /**
     * 
     * @type {boolean}
     * @memberof PricePlanDetails
     */
    'deferredRevenue'?: boolean;
}


/**
 * Configuration for getting the usage rate card
 * @export
 * @interface PricePlanDetailsConfig
 */
export interface PricePlanDetailsConfig {
    /**
     * Mode to get the usage rate card - CUSTOM: Use the price plan details provided in the request - PRICE_PLAN: Use the usage rate cards of the given price plan - ACCOUNT: Use the usage rate cards of a associated price plan of the given account 
     * @type {string}
     * @memberof PricePlanDetailsConfig
     */
    'mode': PricePlanDetailsConfigModeEnum;
    /**
     * 
     * @type {CreatePricePlanDetails}
     * @memberof PricePlanDetailsConfig
     */
    'pricePlanDetails'?: CreatePricePlanDetails;
    /**
     * Id of the price plan, this will be considered if mode is PRICE_PLAN
     * @type {string}
     * @memberof PricePlanDetailsConfig
     */
    'pricePlanId'?: string;
    /**
     * Id of the account, this will be considered if mode is ACCOUNT
     * @type {string}
     * @memberof PricePlanDetailsConfig
     */
    'accountId'?: string;
    /**
     * Will be used for getting the usage rate card, only used if mode is ACCOUNT or PRICE_PLAN
     * @type {string}
     * @memberof PricePlanDetailsConfig
     */
    'effectiveOn'?: string;
    /**
     * nth cycle, will be used to calculate revenue for the particular cycle, only used if mode is CUSTOM or PRICE_PLAN
     * @type {number}
     * @memberof PricePlanDetailsConfig
     */
    'pricingCycleOrdinal'?: number;
}

export const PricePlanDetailsConfigModeEnum = {
    Custom: 'CUSTOM',
    PricePlan: 'PRICE_PLAN',
    Account: 'ACCOUNT'
} as const;

export type PricePlanDetailsConfigModeEnum = typeof PricePlanDetailsConfigModeEnum[keyof typeof PricePlanDetailsConfigModeEnum];

/**
 * 
 * @export
 * @interface PricePlanDetailsOverride
 */
export interface PricePlanDetailsOverride {
    /**
     * 
     * @type {PricingCycleConfig}
     * @memberof PricePlanDetailsOverride
     */
    'pricingCycleConfig'?: PricingCycleConfig;
    /**
     * 
     * @type {Array<string>}
     * @memberof PricePlanDetailsOverride
     */
    'supportedCurrencies'?: Array<string>;
    /**
     * 
     * @type {Array<UsageRateCard>}
     * @memberof PricePlanDetailsOverride
     */
    'usageRateCards'?: Array<UsageRateCard>;
    /**
     * 
     * @type {Array<BillingEntitlementRateCard>}
     * @memberof PricePlanDetailsOverride
     */
    'billingEntitlementRateCards'?: Array<BillingEntitlementRateCard>;
    /**
     * 
     * @type {Array<EntitlementOverageRateCard>}
     * @memberof PricePlanDetailsOverride
     */
    'entitlementOverageRateCards'?: Array<EntitlementOverageRateCard>;
    /**
     * 
     * @type {Array<FixedFeeRateCard>}
     * @memberof PricePlanDetailsOverride
     */
    'fixedFeeRateCards'?: Array<FixedFeeRateCard>;
    /**
     * 
     * @type {Array<LicenseRateCard>}
     * @memberof PricePlanDetailsOverride
     */
    'licenseRateCards'?: Array<LicenseRateCard>;
    /**
     * 
     * @type {MinimumCommitment}
     * @memberof PricePlanDetailsOverride
     */
    'minimumCommitment'?: MinimumCommitment;
    /**
     * 
     * @type {Array<CreditGrantRateCard>}
     * @memberof PricePlanDetailsOverride
     */
    'creditGrantRateCards'?: Array<CreditGrantRateCard>;
}
/**
 * 
 * @export
 * @interface PricePlanDetailsOverrideAllOf
 */
export interface PricePlanDetailsOverrideAllOf {
    /**
     * 
     * @type {Array<FixedFeeRateCard>}
     * @memberof PricePlanDetailsOverrideAllOf
     */
    'fixedFeeRateCards'?: Array<FixedFeeRateCard>;
}
/**
 * 
 * @export
 * @interface PricePlanInfo
 */
export interface PricePlanInfo {
    /**
     * 
     * @type {string}
     * @memberof PricePlanInfo
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PricePlanInfo
     */
    'description'?: string;
}
/**
 * Data of price plan list
 * @export
 * @interface PricePlanListData
 */
export interface PricePlanListData {
    /**
     * Identifier of price plan
     * @type {string}
     * @memberof PricePlanListData
     */
    'id': string;
    /**
     * Name of the price plan
     * @type {string}
     * @memberof PricePlanListData
     */
    'name': string;
    /**
     * Version of the price plan
     * @type {number}
     * @memberof PricePlanListData
     */
    'version': number;
    /**
     * Description of price plan
     * @type {string}
     * @memberof PricePlanListData
     */
    'description'?: string;
    /**
     * Status of Price plan
     * @type {string}
     * @memberof PricePlanListData
     */
    'status': PricePlanListDataStatusEnum;
    /**
     * Usage meters id linked to the price plan
     * @type {Array<string>}
     * @memberof PricePlanListData
     */
    'usageMeters': Array<string>;
    /**
     * 
     * @type {PricePlanDetails}
     * @memberof PricePlanListData
     */
    'pricePlanDetails': PricePlanDetails;
    /**
     * 
     * @type {Array<PricingRule>}
     * @memberof PricePlanListData
     */
    'pricingRules'?: Array<PricingRule>;
    /**
     * 
     * @type {string}
     * @memberof PricePlanListData
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PricePlanListData
     */
    'updatedAt': string;
    /**
     * 
     * @type {PricePlanType}
     * @memberof PricePlanListData
     */
    'type': PricePlanType;
}

export const PricePlanListDataStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type PricePlanListDataStatusEnum = typeof PricePlanListDataStatusEnum[keyof typeof PricePlanListDataStatusEnum];

/**
 * Migrate all account associations of a price plan to another price plan
 * @export
 * @interface PricePlanMigrationConfig
 */
export interface PricePlanMigrationConfig {
    /**
     * Id of source price plan
     * @type {string}
     * @memberof PricePlanMigrationConfig
     */
    'sourceId': string;
    /**
     * Version of the source price plan
     * @type {number}
     * @memberof PricePlanMigrationConfig
     */
    'sourceVersion': number;
    /**
     * Id of target price plan
     * @type {string}
     * @memberof PricePlanMigrationConfig
     */
    'targetId'?: string;
    /**
     * Version of the target price plan
     * @type {number}
     * @memberof PricePlanMigrationConfig
     */
    'targetVersion'?: number;
    /**
     * 
     * @type {string}
     * @memberof PricePlanMigrationConfig
     */
    'migrationMode': PricePlanMigrationConfigMigrationModeEnum;
    /**
     * If this flag is true, current pricing cycle of the account on the date of association will continue rather  than the configurations of the newly associated price plan. Pricing cycle overrides specified  using  `pricePlanDetailsOverride` will take precedence over the pricing cycle configurations of  the new price plan that the account needs to migrate to. PricingCycleInterval of the existing plan and  the new plan must be same for this to work. We\'ll return a `400 BadRequest` otherwise. Examples:   - Ongoing plan (1st Oct to 30th Oct) - {dayOffset: 1, monthOffset: NIL}     New association (15th Oct to 15th Nov) of different price plan with retainStartOffsets option true      will use the same pricing cycle configuration {dayOffset: 1, monthOffset: NIL} rather than using the     pricing cycle configuration of the new price plan that the account needs to migrate to.   - Ongoing plan (1st Oct to 30th Oct) - {dayOffset: 1, monthOffset: NIL}     New association (1st Nov to 30th Nov) of different price plan with retainStartOffsets option true will     throw a `400 BadRequest` as no existing price plan configuration found on date of association 
     * @type {boolean}
     * @memberof PricePlanMigrationConfig
     */
    'retainStartOffsets'?: boolean;
}

export const PricePlanMigrationConfigMigrationModeEnum = {
    Immediate: 'IMMEDIATE',
    ImmediateIgnoreOverride: 'IMMEDIATE_IGNORE_OVERRIDE',
    NextCycle: 'NEXT_CYCLE',
    NextCycleIgnoreOverride: 'NEXT_CYCLE_IGNORE_OVERRIDE'
} as const;

export type PricePlanMigrationConfigMigrationModeEnum = typeof PricePlanMigrationConfigMigrationModeEnum[keyof typeof PricePlanMigrationConfigMigrationModeEnum];

/**
 * 
 * @export
 * @interface PricePlanPaginatedResponse
 */
export interface PricePlanPaginatedResponse {
    /**
     * 
     * @type {Array<PricePlanListData>}
     * @memberof PricePlanPaginatedResponse
     */
    'data': Array<PricePlanListData>;
    /**
     * 
     * @type {string}
     * @memberof PricePlanPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof PricePlanPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * Type of price plan
 * @export
 * @enum {string}
 */

export const PricePlanType = {
    Billing: 'BILLING',
    Purchase: 'PURCHASE'
} as const;

export type PricePlanType = typeof PricePlanType[keyof typeof PricePlanType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PriceType = {
    Flat: 'FLAT',
    PerUnit: 'PER_UNIT',
    Package: 'PACKAGE'
} as const;

export type PriceType = typeof PriceType[keyof typeof PriceType];


/**
 * Represents configurations related to pricing cycle
 * @export
 * @interface PricingCycleConfig
 */
export interface PricingCycleConfig {
    /**
     * 
     * @type {PricingCycleInterval}
     * @memberof PricingCycleConfig
     */
    'interval': PricingCycleInterval;
    /**
     * 
     * @type {PricingCycleConfigStartOffset}
     * @memberof PricingCycleConfig
     */
    'startOffset'?: PricingCycleConfigStartOffset;
    /**
     * Togai allows you to ingest past dated events that will be processed by a pricing cycle till the end grace period.  For example: Pricing cycle is Monthly from 1st to 30th and gracePeriod is 5 days which next month 1 to 5th date, you can ingest past dated events during this grace period. 
     * @type {number}
     * @memberof PricingCycleConfig
     */
    'gracePeriod': number;
    /**
     * Togai calculates the startOffsets based on the date of association instead of requiring from the user and  these offsets will be applied as an override if this flag is enabled. Examples: WEEKLY -   - 23/10/2023 (Monday) - {dayOffset: 1, monthOffset: NIL}    - 25/10/2023 (Wednesday) - {dayOffset: 3, monthOffset: NIL}    - 29/10/2023 (Sunday) - {dayOffset: 7, monthOffset: NIL} MONTHLY -   - 1st Oct - {dayOffset: 1, monthOffset: NIL}   - 12th Oct - {dayOffset: 12, monthOffset: NIL}   - 28th Oct - {dayOffset: 28, monthOffset: NIL}   - 30th Oct - {dayOffset: 30, monthOffset: NIL}   - 31th Oct - {dayOffset: LAST, monthOffset: NIL} QUARTERLY   - 15th Jan, 15th Apr, 15th Jul and 15th Oct - {dayOffset: 15, monthOffset: 1}   - 15th Feb, 15th May, 15th Aug and 15th Nov - {dayOffset: 15, monthOffset: 2}    - 15th Mar, 15th Jun, 15th Sep and 15th Dec - {dayOffset: 15, monthOffset: 3} HALF_YEARLY   - 15th Jan and 15th Jul - {dayOffset: 15, monthOffset: 1}    - 15th Apr and 15th Oct - {dayOffset: 15, monthOffset: 4}    - 15th Jun and 15th Dec - {dayOffset: 15, monthOffset: 6} ANNUALLY   - 15th Jan - {dayOffset: 15, monthOffset: 1}   - 29th Feb on Leap year  - {dayOffset: LAST, monthOffset: 2}   - 28th Feb  - {dayOffset: LAST, monthOffset: 2}   - 15th Aug - {dayOffset: 15, monthOffset: 8}   - 15th Dec - {dayOffset: 15, monthOffset: 12} 
     * @type {boolean}
     * @memberof PricingCycleConfig
     */
    'anniversaryCycle'?: boolean;
}


/**
 * Represents the start of pricing cycle in terms of  - dayOffset - number of days from beginning of week / month and  - monthOffset - number of months from beginning of interval (quarter, half-year or year) Note: If a day with offset doesn\'t exist for a month, closest previous day is considered Examples: WEEKLY -   - {dayOffset: 1, monthOffset: NIL} - First day of every week (Monday)   - {dayOffset: 3, monthOffset: NIL} - 3rd day of every week (Wednesday)   - {dayOffset: LAST, monthOffset: NIL} - Last day of every week (Sunday) MONTHLY -   - {dayOffset: 1, monthOffset: NIL} - First day of every month   - {dayOffset: 12, monthOffset: NIL} - 12th of every month   - {dayOffset: 28, monthOffset: NIL} - 28th of every month. i.e, 28th of Jan, 28th of Feb, ...   - {dayOffset: 30, monthOffset: NIL} - 30th of every month. i.e, 28th of Jan, 28th of Feb, ...   - {dayOffset: LAST, monthOffset: NIL} - Last day of every month. i.e, 31st of Jan, 28th of Feb, ... QUARTERLY   - {dayOffset: 15, monthOffset: FIRST} - 15th Jan, 15th Apr, 15th Jul and 15th Oct   - {dayOffset: 15, monthOffset: 2} - 15th Feb, 15th May, 15th Aug and 15th Nov   - {dayOffset: 15, monthOffset: LAST} - 15th Mar, 15th Jun, 15th Sep and 15th Dec   - {dayOffset: LAST, monthOffset: FIRST} - 31st Jan, 30th Apr, 30th Jul and 31th Oct HALF_YEARLY   - {dayOffset: 15, monthOffset: FIRST} - 15th Jan and 15th Jul   - {dayOffset: 15, monthOffset: 4} - 15th Apr and 15th Oct   - {dayOffset: 15, monthOffset: LAST} - 15th Jun and 15th Dec ANNUALLY   - {dayOffset: 15, monthOffset: FIRST} - 15th Jan   - {dayOffset: 15, monthOffset: 1} - 15th Jan   - {dayOffset: LAST, monthOffset: 2} - 29th Feb on Leap year, 28th otherwise    - {dayOffset: 15, monthOffset: 8} - 15th Aug   - {dayOffset: 15, monthOffset: LAST} - 15th Dec 
 * @export
 * @interface PricingCycleConfigStartOffset
 */
export interface PricingCycleConfigStartOffset {
    /**
     * If interval is WEEKLY, min: \"1\" and max: \"7\" as strings. Spl. string allowed: LAST Otherwise, min: \"1\" and max: \"31\" as strings. Spl. string allowed: LAST 
     * @type {string}
     * @memberof PricingCycleConfigStartOffset
     */
    'dayOffset': string;
    /**
     * min: \"1\" and max: \"12\". Spl. string allowed: FIRST / LAST. For QUARTERLY only 1 - 3 is allowed and for HALF_YEARLY 1 - 6. This being an optional field, shouldn\'t be passed for MONTHLY. 
     * @type {string}
     * @memberof PricingCycleConfigStartOffset
     */
    'monthOffset': string;
}
/**
 * Interval field allow you to define the billing interval you would like to set
 * @export
 * @enum {string}
 */

export const PricingCycleInterval = {
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Quarterly: 'QUARTERLY',
    HalfYearly: 'HALF_YEARLY',
    Annually: 'ANNUALLY'
} as const;

export type PricingCycleInterval = typeof PricingCycleInterval[keyof typeof PricingCycleInterval];


/**
 * Togai supports two type of pricing model Tiered and Volume. Tiered pricing model applies respective slab and its rate to the usage value while volume pricing model applies the latest matching slab of the usage value and applies respective rate.  For more understanding read [Rate Cards](https://docs.togai.com/docs/priceplan#setting-up-multiple-rate-cards) 
 * @export
 * @enum {string}
 */

export const PricingModel = {
    Tiered: 'TIERED',
    Volume: 'VOLUME'
} as const;

export type PricingModel = typeof PricingModel[keyof typeof PricingModel];


/**
 * Represents pricing rules of a price plan. i.e, price plan bound by time.
 * @export
 * @interface PricingRule
 */
export interface PricingRule {
    /**
     * 
     * @type {string}
     * @memberof PricingRule
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PricingRule
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PricingRule
     */
    'version': number;
    /**
     * 
     * @type {number}
     * @memberof PricingRule
     */
    'order': number;
    /**
     * JSON logic condition deciding whether to compute this pricing rule or not
     * @type {string}
     * @memberof PricingRule
     */
    'condition'?: string;
    /**
     * JSON logic to be computed
     * @type {string}
     * @memberof PricingRule
     */
    'computation': string;
    /**
     * 
     * @type {PricingRuleAction}
     * @memberof PricingRule
     */
    'action': PricingRuleAction;
}
/**
 * 
 * @export
 * @interface PricingRuleAction
 */
export interface PricingRuleAction {
    /**
     * 
     * @type {string}
     * @memberof PricingRuleAction
     */
    'type': PricingRuleActionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PricingRuleAction
     */
    'target'?: string;
    /**
     * 
     * @type {string}
     * @memberof PricingRuleAction
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PricingRuleAction
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PricingRuleAction
     */
    'metadata'?: { [key: string]: string; };
}

export const PricingRuleActionTypeEnum = {
    Add: 'ADD',
    Update: 'UPDATE'
} as const;

export type PricingRuleActionTypeEnum = typeof PricingRuleActionTypeEnum[keyof typeof PricingRuleActionTypeEnum];

/**
 * Pricing Rules Logs Changes
 * @export
 * @interface PricingRuleChangesLog
 */
export interface PricingRuleChangesLog {
    /**
     * 
     * @type {string}
     * @memberof PricingRuleChangesLog
     */
    'key': string;
    /**
     * 
     * @type {number}
     * @memberof PricingRuleChangesLog
     */
    'oldRevenue': number;
    /**
     * 
     * @type {number}
     * @memberof PricingRuleChangesLog
     */
    'newRevenue': number;
    /**
     * 
     * @type {number}
     * @memberof PricingRuleChangesLog
     */
    'oldUsage'?: number;
    /**
     * 
     * @type {number}
     * @memberof PricingRuleChangesLog
     */
    'newUsage'?: number;
    /**
     * 
     * @type {string}
     * @memberof PricingRuleChangesLog
     */
    'errorMessage'?: string;
}
/**
 * Pricing Rules Logs
 * @export
 * @interface PricingRulesLog
 */
export interface PricingRulesLog {
    /**
     * 
     * @type {string}
     * @memberof PricingRulesLog
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PricingRulesLog
     */
    'ruleId': string;
    /**
     * 
     * @type {string}
     * @memberof PricingRulesLog
     */
    'ruleName'?: string;
    /**
     * 
     * @type {number}
     * @memberof PricingRulesLog
     */
    'order': number;
    /**
     * 
     * @type {PricingRuleChangesLog}
     * @memberof PricingRulesLog
     */
    'changes': PricingRuleChangesLog;
}
/**
 * Pricing Rules Logs response
 * @export
 * @interface PricingRulesLogsPaginatedResponse
 */
export interface PricingRulesLogsPaginatedResponse {
    /**
     * 
     * @type {Array<PricingRulesLog>}
     * @memberof PricingRulesLogsPaginatedResponse
     */
    'data': Array<PricingRulesLog>;
}
/**
 * 
 * @export
 * @interface PricingRulesPaginatedResponse
 */
export interface PricingRulesPaginatedResponse {
    /**
     * 
     * @type {Array<PricingRule>}
     * @memberof PricingRulesPaginatedResponse
     */
    'data': Array<PricingRule>;
}
/**
 * Represents effectiveness period and config of a price plan. i.e, price plan bound by time.
 * @export
 * @interface PricingSchedule
 */
export interface PricingSchedule {
    /**
     * 
     * @type {string}
     * @memberof PricingSchedule
     */
    'id': string;
    /**
     * 
     * @type {PricePlanDetails}
     * @memberof PricingSchedule
     */
    'pricePlanDetails'?: PricePlanDetails;
    /**
     * 
     * @type {string}
     * @memberof PricingSchedule
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof PricingSchedule
     */
    'endDate': string;
    /**
     * 
     * @type {number}
     * @memberof PricingSchedule
     */
    'version': number;
    /**
     * 
     * @type {Array<PricingRule>}
     * @memberof PricingSchedule
     */
    'pricingRules'?: Array<PricingRule>;
    /**
     * 
     * @type {boolean}
     * @memberof PricingSchedule
     */
    'isOverriden': boolean;
}
/**
 * 
 * @export
 * @interface PricingSchedulePaginatedResponse
 */
export interface PricingSchedulePaginatedResponse {
    /**
     * 
     * @type {Array<PricingScheduleWithPricePlanId>}
     * @memberof PricingSchedulePaginatedResponse
     */
    'data'?: Array<PricingScheduleWithPricePlanId>;
    /**
     * 
     * @type {string}
     * @memberof PricingSchedulePaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof PricingSchedulePaginatedResponse
     */
    'previousToken'?: string;
}
/**
 * 
 * @export
 * @interface PricingScheduleWithPricePlanId
 */
export interface PricingScheduleWithPricePlanId {
    /**
     * 
     * @type {string}
     * @memberof PricingScheduleWithPricePlanId
     */
    'id': string;
    /**
     * 
     * @type {PricePlanDetails}
     * @memberof PricingScheduleWithPricePlanId
     */
    'pricePlanDetails'?: PricePlanDetails;
    /**
     * 
     * @type {string}
     * @memberof PricingScheduleWithPricePlanId
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof PricingScheduleWithPricePlanId
     */
    'endDate': string;
    /**
     * 
     * @type {number}
     * @memberof PricingScheduleWithPricePlanId
     */
    'version': number;
    /**
     * 
     * @type {Array<PricingRule>}
     * @memberof PricingScheduleWithPricePlanId
     */
    'pricingRules'?: Array<PricingRule>;
    /**
     * 
     * @type {boolean}
     * @memberof PricingScheduleWithPricePlanId
     */
    'isOverriden': boolean;
    /**
     * 
     * @type {string}
     * @memberof PricingScheduleWithPricePlanId
     */
    'pricePlanId': string;
    /**
     * 
     * @type {string}
     * @memberof PricingScheduleWithPricePlanId
     */
    'pricePlanName'?: string;
    /**
     * 
     * @type {PricePlanInfo}
     * @memberof PricingScheduleWithPricePlanId
     */
    'pricePlanInfo'?: PricePlanInfo;
}
/**
 * 
 * @export
 * @interface PricingScheduleWithPricePlanIdAllOf
 */
export interface PricingScheduleWithPricePlanIdAllOf {
    /**
     * 
     * @type {string}
     * @memberof PricingScheduleWithPricePlanIdAllOf
     */
    'pricePlanId': string;
    /**
     * 
     * @type {string}
     * @memberof PricingScheduleWithPricePlanIdAllOf
     */
    'pricePlanName'?: string;
    /**
     * 
     * @type {PricePlanInfo}
     * @memberof PricingScheduleWithPricePlanIdAllOf
     */
    'pricePlanInfo'?: PricePlanInfo;
}
/**
 * 
 * @export
 * @interface Proposal
 */
export interface Proposal {
    /**
     * 
     * @type {string}
     * @memberof Proposal
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Proposal
     */
    'accountId': string;
    /**
     * Id of the price plan, Required for ENTITLEMENT_GRANT, ASSOCIATION purchase
     * @type {string}
     * @memberof Proposal
     */
    'pricePlanId'?: string;
    /**
     * 
     * @type {number}
     * @memberof Proposal
     */
    'quantity'?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof Proposal
     */
    'rateCardQuantities'?: { [key: string]: number; };
    /**
     * 
     * @type {string}
     * @memberof Proposal
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof Proposal
     */
    'pricePlanVersion'?: number;
    /**
     * 
     * @type {PricePlanDetailsOverride}
     * @memberof Proposal
     */
    'purchasePlanOverride'?: PricePlanDetailsOverride;
    /**
     * 
     * @type {CreatePricePlanDetailsOverride}
     * @memberof Proposal
     */
    'associationOverride'?: CreatePricePlanDetailsOverride;
    /**
     * 
     * @type {WalletTopupDetails}
     * @memberof Proposal
     */
    'walletTopupDetails'?: WalletTopupDetails;
    /**
     * 
     * @type {string}
     * @memberof Proposal
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Proposal
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proposal
     */
    'effectiveFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proposal
     */
    'effectiveUntil'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proposal
     */
    'expiryDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Proposal
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof Proposal
     */
    'invoiceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proposal
     */
    'invoiceCurrency'?: string;
    /**
     * 
     * @type {PurchaseStatus}
     * @memberof Proposal
     */
    'status': PurchaseStatus;
    /**
     * 
     * @type {PurchaseType}
     * @memberof Proposal
     */
    'type': PurchaseType;
    /**
     * 
     * @type {string}
     * @memberof Proposal
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proposal
     */
    'paymentMode': ProposalPaymentModeEnum;
    /**
     * 
     * @type {string}
     * @memberof Proposal
     */
    'proposalResponseDate'?: string;
}

export const ProposalPaymentModeEnum = {
    Prepaid: 'PREPAID',
    Postpaid: 'POSTPAID'
} as const;

export type ProposalPaymentModeEnum = typeof ProposalPaymentModeEnum[keyof typeof ProposalPaymentModeEnum];

/**
 * 
 * @export
 * @interface ProposalAllOf
 */
export interface ProposalAllOf {
    /**
     * 
     * @type {string}
     * @memberof ProposalAllOf
     */
    'paymentMode': ProposalAllOfPaymentModeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProposalAllOf
     */
    'proposalResponseDate'?: string;
}

export const ProposalAllOfPaymentModeEnum = {
    Prepaid: 'PREPAID',
    Postpaid: 'POSTPAID'
} as const;

export type ProposalAllOfPaymentModeEnum = typeof ProposalAllOfPaymentModeEnum[keyof typeof ProposalAllOfPaymentModeEnum];

/**
 * Represents a Proposal for List Response
 * @export
 * @interface ProposalsListResponse
 */
export interface ProposalsListResponse {
    /**
     * 
     * @type {string}
     * @memberof ProposalsListResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProposalsListResponse
     */
    'pricePlanId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProposalsListResponse
     */
    'pricePlanName'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProposalsListResponse
     */
    'pricePlanVersion'?: number;
    /**
     * 
     * @type {PurchaseStatus}
     * @memberof ProposalsListResponse
     */
    'status': PurchaseStatus;
    /**
     * 
     * @type {WalletTopupDetails}
     * @memberof ProposalsListResponse
     */
    'walletTopupDetails'?: WalletTopupDetails;
    /**
     * 
     * @type {string}
     * @memberof ProposalsListResponse
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProposalsListResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProposalsListResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProposalsListResponse
     */
    'expiryDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProposalsListResponse
     */
    'paymentMode': ProposalsListResponsePaymentModeEnum;
    /**
     * 
     * @type {PurchaseType}
     * @memberof ProposalsListResponse
     */
    'type': PurchaseType;
}

export const ProposalsListResponsePaymentModeEnum = {
    Prepaid: 'PREPAID',
    Postpaid: 'POSTPAID'
} as const;

export type ProposalsListResponsePaymentModeEnum = typeof ProposalsListResponsePaymentModeEnum[keyof typeof ProposalsListResponsePaymentModeEnum];

/**
 * 
 * @export
 * @interface ProposalsPaginatedResponse
 */
export interface ProposalsPaginatedResponse {
    /**
     * 
     * @type {Array<ProposalsListResponse>}
     * @memberof ProposalsPaginatedResponse
     */
    'data'?: Array<ProposalsListResponse>;
    /**
     * 
     * @type {string}
     * @memberof ProposalsPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof ProposalsPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ProratedRefundMode = {
    None: 'NONE',
    Credits: 'CREDITS',
    Payment: 'PAYMENT',
    Wallet: 'WALLET'
} as const;

export type ProratedRefundMode = typeof ProratedRefundMode[keyof typeof ProratedRefundMode];


/**
 * Configuration for getting the proration, if not provided no proration will be applied
 * @export
 * @interface ProrationConfig
 */
export interface ProrationConfig {
    /**
     * Mode to get the proration - CUSTOM: Use the proration provided in the request - LOOKUP_CYCLE: Use the proration of a given account for the specified cycle 
     * @type {string}
     * @memberof ProrationConfig
     */
    'mode': ProrationConfigModeEnum;
    /**
     * 
     * @type {ProrationConfigCustomConfig}
     * @memberof ProrationConfig
     */
    'customConfig'?: ProrationConfigCustomConfig;
    /**
     * 
     * @type {ProrationConfigLookupCycleConfig}
     * @memberof ProrationConfig
     */
    'lookupCycleConfig'?: ProrationConfigLookupCycleConfig;
}

export const ProrationConfigModeEnum = {
    Custom: 'CUSTOM',
    LookupCycle: 'LOOKUP_CYCLE'
} as const;

export type ProrationConfigModeEnum = typeof ProrationConfigModeEnum[keyof typeof ProrationConfigModeEnum];

/**
 * Custom proration config, this will be considered if mode is CUSTOM
 * @export
 * @interface ProrationConfigCustomConfig
 */
export interface ProrationConfigCustomConfig {
    /**
     * 
     * @type {string}
     * @memberof ProrationConfigCustomConfig
     */
    'cycleStartDate': string;
    /**
     * 
     * @type {string}
     * @memberof ProrationConfigCustomConfig
     */
    'cycleEndDate': string;
    /**
     * 
     * @type {string}
     * @memberof ProrationConfigCustomConfig
     */
    'currentDate': string;
}
/**
 * Cycle of proration to be looked up, this will be considered if mode is LOOKUP_CYCLE
 * @export
 * @interface ProrationConfigLookupCycleConfig
 */
export interface ProrationConfigLookupCycleConfig {
    /**
     * Defaults to current date time if not provided
     * @type {string}
     * @memberof ProrationConfigLookupCycleConfig
     */
    'currentDateTime'?: string;
    /**
     * Defaults to current date time if not provided
     * @type {string}
     * @memberof ProrationConfigLookupCycleConfig
     */
    'cycleEffectiveOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProrationConfigLookupCycleConfig
     */
    'accountId': string;
}
/**
 * Represents a Purchase
 * @export
 * @interface Purchase
 */
export interface Purchase {
    /**
     * 
     * @type {string}
     * @memberof Purchase
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Purchase
     */
    'accountId': string;
    /**
     * Id of the price plan, Required for ENTITLEMENT_GRANT, ASSOCIATION purchase
     * @type {string}
     * @memberof Purchase
     */
    'pricePlanId'?: string;
    /**
     * 
     * @type {number}
     * @memberof Purchase
     */
    'quantity'?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof Purchase
     */
    'rateCardQuantities'?: { [key: string]: number; };
    /**
     * 
     * @type {string}
     * @memberof Purchase
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof Purchase
     */
    'pricePlanVersion'?: number;
    /**
     * 
     * @type {PricePlanDetailsOverride}
     * @memberof Purchase
     */
    'purchasePlanOverride'?: PricePlanDetailsOverride;
    /**
     * 
     * @type {CreatePricePlanDetailsOverride}
     * @memberof Purchase
     */
    'associationOverride'?: CreatePricePlanDetailsOverride;
    /**
     * 
     * @type {WalletTopupDetails}
     * @memberof Purchase
     */
    'walletTopupDetails'?: WalletTopupDetails;
    /**
     * 
     * @type {string}
     * @memberof Purchase
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Purchase
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Purchase
     */
    'effectiveFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof Purchase
     */
    'effectiveUntil'?: string;
    /**
     * 
     * @type {string}
     * @memberof Purchase
     */
    'expiryDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Purchase
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof Purchase
     */
    'invoiceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Purchase
     */
    'invoiceCurrency'?: string;
    /**
     * 
     * @type {PurchaseStatus}
     * @memberof Purchase
     */
    'status': PurchaseStatus;
    /**
     * 
     * @type {PurchaseType}
     * @memberof Purchase
     */
    'type': PurchaseType;
    /**
     * 
     * @type {string}
     * @memberof Purchase
     */
    'comment'?: string;
}


/**
 * 
 * @export
 * @interface PurchaseFeatureDetails
 */
export interface PurchaseFeatureDetails {
    /**
     * 
     * @type {string}
     * @memberof PurchaseFeatureDetails
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseFeatureDetails
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PurchaseFeatureDetails
     */
    'creditsGranted': number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseFeatureDetails
     */
    'creditsAvailable': number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseFeatureDetails
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseFeatureDetails
     */
    'effectiveFrom': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseFeatureDetails
     */
    'effectiveUntil': string;
}
/**
 * Represents a Purchase for List Response
 * @export
 * @interface PurchaseListResponse
 */
export interface PurchaseListResponse {
    /**
     * 
     * @type {string}
     * @memberof PurchaseListResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseListResponse
     */
    'pricePlanId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseListResponse
     */
    'pricePlanName'?: string;
    /**
     * 
     * @type {number}
     * @memberof PurchaseListResponse
     */
    'quantity'?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof PurchaseListResponse
     */
    'rateCardQuantities'?: { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof PurchaseListResponse
     */
    'pricePlanVersion'?: number;
    /**
     * 
     * @type {PurchaseStatus}
     * @memberof PurchaseListResponse
     */
    'status': PurchaseStatus;
    /**
     * 
     * @type {string}
     * @memberof PurchaseListResponse
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {PricePlanDetails}
     * @memberof PurchaseListResponse
     */
    'purchasePlan'?: PricePlanDetails;
    /**
     * 
     * @type {WalletTopupDetails}
     * @memberof PurchaseListResponse
     */
    'walletTopupDetails'?: WalletTopupDetails;
    /**
     * 
     * @type {number}
     * @memberof PurchaseListResponse
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseListResponse
     */
    'invoiceCurrency'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseListResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseListResponse
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {PurchaseType}
     * @memberof PurchaseListResponse
     */
    'type': PurchaseType;
}


/**
 * 
 * @export
 * @interface PurchasePaginatedListData
 */
export interface PurchasePaginatedListData {
    /**
     * 
     * @type {Array<PurchaseListResponse>}
     * @memberof PurchasePaginatedListData
     */
    'data'?: Array<PurchaseListResponse>;
    /**
     * 
     * @type {string}
     * @memberof PurchasePaginatedListData
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof PurchasePaginatedListData
     */
    'context'?: PaginationOptions;
}
/**
 * entitlements override options for purchase of a price plan for an account
 * @export
 * @interface PurchasePlanOverride
 */
export interface PurchasePlanOverride {
    /**
     * 
     * @type {Array<FixedFeeRateCard>}
     * @memberof PurchasePlanOverride
     */
    'fixedFeeRateCards'?: Array<FixedFeeRateCard>;
    /**
     * 
     * @type {Array<BillingEntitlementRateCard>}
     * @memberof PurchasePlanOverride
     */
    'billingEntitlementRateCards'?: Array<BillingEntitlementRateCard>;
    /**
     * 
     * @type {Array<CreditGrantRateCard>}
     * @memberof PurchasePlanOverride
     */
    'creditGrantRateCards'?: Array<CreditGrantRateCard>;
}
/**
 * Status of the purchase
 * @export
 * @enum {string}
 */

export const PurchaseStatus = {
    Success: 'SUCCESS',
    Failure: 'FAILURE',
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    ProposalActive: 'PROPOSAL_ACTIVE',
    ProposalApproved: 'PROPOSAL_APPROVED',
    ProposalDeclined: 'PROPOSAL_DECLINED',
    ProposalExpired: 'PROPOSAL_EXPIRED'
} as const;

export type PurchaseStatus = typeof PurchaseStatus[keyof typeof PurchaseStatus];


/**
 * Specifies whether this purchase is for granting entitlements or for an association or for wallet topup or prepaid purchase. If left null, ENTITLEMENT_GRANT is taken as default
 * @export
 * @enum {string}
 */

export const PurchaseType = {
    EntitlementGrant: 'ENTITLEMENT_GRANT',
    Association: 'ASSOCIATION',
    WalletTopup: 'WALLET_TOPUP',
    Prepaid: 'PREPAID'
} as const;

export type PurchaseType = typeof PurchaseType[keyof typeof PurchaseType];


/**
 * Contains all rate related configurations
 * @export
 * @interface RatePlan
 */
export interface RatePlan {
    /**
     * 
     * @type {PricingModel}
     * @memberof RatePlan
     */
    'pricingModel': PricingModel;
    /**
     * Rate cards can have single or multiple slab up to 100.
     * @type {Array<Slab>}
     * @memberof RatePlan
     */
    'slabs': Array<Slab>;
}


/**
 * Represents a rate
 * @export
 * @interface RateValue
 */
export interface RateValue {
    /**
     * 
     * @type {string}
     * @memberof RateValue
     */
    'currency': string;
    /**
     * 
     * @type {Array<SlabRate>}
     * @memberof RateValue
     */
    'slabRates': Array<SlabRate>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RateValue
     */
    'rateConfig'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface RecurrenceConfig
 */
export interface RecurrenceConfig {
    /**
     * Represents the number of pricing cycles after which the rate card will be charged
     * @type {number}
     * @memberof RecurrenceConfig
     */
    'interval'?: number;
    /**
     * Represents the offset for pricing cycles after which the rate card will be charged
     * @type {number}
     * @memberof RecurrenceConfig
     */
    'offset'?: number;
}
/**
 * 
 * @export
 * @interface RemoveAccountAliasRequest
 */
export interface RemoveAccountAliasRequest {
    /**
     * Alias identifier (UUID)
     * @type {string}
     * @memberof RemoveAccountAliasRequest
     */
    'id': string;
    /**
     * Alias will be deleted from this date, If not provided, it will be deleted from now
     * @type {string}
     * @memberof RemoveAccountAliasRequest
     */
    'from'?: string;
}
/**
 * Payload to remove account aliases
 * @export
 * @interface RemoveAccountAliasesRequest
 */
export interface RemoveAccountAliasesRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof RemoveAccountAliasesRequest
     */
    'aliases'?: Array<string>;
    /**
     * 
     * @type {Array<RemoveAccountAliasRequest>}
     * @memberof RemoveAccountAliasesRequest
     */
    'accountAliases'?: Array<RemoveAccountAliasRequest>;
}
/**
 * 
 * @export
 * @interface RevenueInfo
 */
export interface RevenueInfo {
    /**
     * 
     * @type {UsageRateCard}
     * @memberof RevenueInfo
     */
    'usageRateCard'?: UsageRateCard;
    /**
     * 
     * @type {FixedFeeRateCard}
     * @memberof RevenueInfo
     */
    'fixedFeeRateCard'?: FixedFeeRateCard;
    /**
     * 
     * @type {LicenseRateCard}
     * @memberof RevenueInfo
     */
    'licenseRateCard'?: LicenseRateCard;
    /**
     * 
     * @type {BillingEntitlementRateCard}
     * @memberof RevenueInfo
     */
    'billingEntitlementRateCard'?: BillingEntitlementRateCard;
    /**
     * 
     * @type {CreditGrantRateCard}
     * @memberof RevenueInfo
     */
    'creditGrantRateCard'?: CreditGrantRateCard;
    /**
     * 
     * @type {EntitlementOverageRateCard}
     * @memberof RevenueInfo
     */
    'entitlementOverageRateCard'?: EntitlementOverageRateCard;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof RevenueInfo
     */
    'usages': { [key: string]: number; };
    /**
     * 
     * @type {FixedFeeRevenueSummary}
     * @memberof RevenueInfo
     */
    'fixedFeeRevenueSummary'?: FixedFeeRevenueSummary;
    /**
     * 
     * @type {Array<SlabRevenueSummary>}
     * @memberof RevenueInfo
     */
    'licenseRevenueSummary'?: Array<SlabRevenueSummary>;
    /**
     * 
     * @type {BillingEntitlementRevenueSummary}
     * @memberof RevenueInfo
     */
    'billingEntitlementRevenueSummary'?: BillingEntitlementRevenueSummary;
    /**
     * 
     * @type {CreditGrantRevenueSummary}
     * @memberof RevenueInfo
     */
    'creditGrantRevenueSummary'?: CreditGrantRevenueSummary;
    /**
     * 
     * @type {EntitlementOverageRevenueSummary}
     * @memberof RevenueInfo
     */
    'entitlementOverageRevenueSummary'?: EntitlementOverageRevenueSummary;
    /**
     * 
     * @type {Array<SlabRevenueSummary>}
     * @memberof RevenueInfo
     */
    'slabRevenueSummaries'?: Array<SlabRevenueSummary>;
}
/**
 * 
 * @export
 * @interface RevenueSummaryWithMetadata
 */
export interface RevenueSummaryWithMetadata {
    /**
     * 
     * @type {number}
     * @memberof RevenueSummaryWithMetadata
     */
    'revenue': number;
    /**
     * Field: revenue is computed for all rate cards Field: slabRevenues is supported for only usage/license Field: metadata is populated based on application of rateConfig(\'minimumRate\', \'maximumRate\') 
     * @type {Array<RevenueSummaryWithMetadata>}
     * @memberof RevenueSummaryWithMetadata
     */
    'revenueSummary'?: Array<RevenueSummaryWithMetadata>;
    /**
     * 
     * @type {Array<SlabRevenueWithMetadata>}
     * @memberof RevenueSummaryWithMetadata
     */
    'slabRevenues'?: Array<SlabRevenueWithMetadata>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RevenueSummaryWithMetadata
     */
    'metadata'?: { [key: string]: string; };
}
/**
 * Represents a setting
 * @export
 * @interface Setting
 */
export interface Setting {
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'entityType': string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'entityId': string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'name': string;
    /**
     * 
     * @type {SettingDataType}
     * @memberof Setting
     */
    'dataType': SettingDataType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SettingDataType = {
    String: 'STRING',
    Numeric: 'NUMERIC',
    Json: 'JSON',
    JsonLogic: 'JSON_LOGIC'
} as const;

export type SettingDataType = typeof SettingDataType[keyof typeof SettingDataType];


/**
 * 
 * @export
 * @interface SettingPaginatedResponse
 */
export interface SettingPaginatedResponse {
    /**
     * 
     * @type {Array<Setting>}
     * @memberof SettingPaginatedResponse
     */
    'data'?: Array<Setting>;
    /**
     * 
     * @type {string}
     * @memberof SettingPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof SettingPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * Represents a pricing priceType (rates + slabs) for usage price plan
 * @export
 * @interface Slab
 */
export interface Slab {
    /**
     * 
     * @type {number}
     * @memberof Slab
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof Slab
     */
    'startAfter': number;
    /**
     * 
     * @type {PriceType}
     * @memberof Slab
     */
    'priceType': PriceType;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Slab
     */
    'slabConfig'?: { [key: string]: string; };
}


/**
 * The details of a slab
 * @export
 * @interface SlabDetail
 */
export interface SlabDetail {
    /**
     * 
     * @type {number}
     * @memberof SlabDetail
     */
    'startAfter': number;
    /**
     * 
     * @type {PriceType}
     * @memberof SlabDetail
     */
    'priceType': PriceType;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SlabDetail
     */
    'slabConfig'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof SlabDetail
     */
    'rate': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SlabDetail
     */
    'slabRateConfig'?: { [key: string]: string; };
}


/**
 * Represents a rate for a slab
 * @export
 * @interface SlabRate
 */
export interface SlabRate {
    /**
     * 
     * @type {number}
     * @memberof SlabRate
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof SlabRate
     */
    'rate': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SlabRate
     */
    'slabRateConfig'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface SlabRevenue
 */
export interface SlabRevenue {
    /**
     * 
     * @type {number}
     * @memberof SlabRevenue
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof SlabRevenue
     */
    'usage': number;
    /**
     * 
     * @type {number}
     * @memberof SlabRevenue
     */
    'revenue': number;
}
/**
 * 
 * @export
 * @interface SlabRevenueMetadata
 */
export interface SlabRevenueMetadata {
    /**
     * 
     * @type {boolean}
     * @memberof SlabRevenueMetadata
     */
    'minimumRateApplied'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SlabRevenueMetadata
     */
    'maximumRateApplied'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SlabRevenueMetadata
     */
    'packageQuantity'?: number;
}
/**
 * 
 * @export
 * @interface SlabRevenueSummary
 */
export interface SlabRevenueSummary {
    /**
     * 
     * @type {number}
     * @memberof SlabRevenueSummary
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof SlabRevenueSummary
     */
    'usage': number;
    /**
     * 
     * @type {number}
     * @memberof SlabRevenueSummary
     */
    'revenue': number;
    /**
     * 
     * @type {SlabRevenueMetadata}
     * @memberof SlabRevenueSummary
     */
    'metadata'?: SlabRevenueMetadata;
}
/**
 * 
 * @export
 * @interface SlabRevenueWithMetadata
 */
export interface SlabRevenueWithMetadata {
    /**
     * 
     * @type {number}
     * @memberof SlabRevenueWithMetadata
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof SlabRevenueWithMetadata
     */
    'usage': number;
    /**
     * 
     * @type {number}
     * @memberof SlabRevenueWithMetadata
     */
    'revenue': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SlabRevenueWithMetadata
     */
    'metadata'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface SlabRevenueWithMetadataAllOf
 */
export interface SlabRevenueWithMetadataAllOf {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SlabRevenueWithMetadataAllOf
     */
    'metadata'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'token': string;
}
/**
 * Payload to topup wallet of an account
 * @export
 * @interface TopupWalletRequest
 */
export interface TopupWalletRequest {
    /**
     * 
     * @type {number}
     * @memberof TopupWalletRequest
     */
    'topupAmount': number;
}
/**
 * Payload to update account
 * @export
 * @interface UpdateAccountRequest
 */
export interface UpdateAccountRequest {
    /**
     * Name of the Account
     * @type {string}
     * @memberof UpdateAccountRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountRequest
     */
    'status'?: UpdateAccountRequestStatusEnum;
    /**
     * [ISO_4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency in which the account must be invoiced Defaults to Base currency. 
     * @type {string}
     * @memberof UpdateAccountRequest
     */
    'invoiceCurrency'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateAccountRequest
     */
    'netTermDays'?: number;
    /**
     * Primary email of the account
     * @type {string}
     * @memberof UpdateAccountRequest
     */
    'primaryEmail'?: string;
    /**
     * 
     * @type {Address}
     * @memberof UpdateAccountRequest
     */
    'address'?: Address;
    /**
     * Additional information associated with the account. Example: GSTN, VATN NOTE: This replaces the existing metadata if the metadata in the request is not null.  To remove all existing metadata, use empty object 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateAccountRequest
     */
    'metadata'?: { [key: string]: string; };
    /**
     * Tag for accounts are stored in lowercase
     * @type {Array<string>}
     * @memberof UpdateAccountRequest
     */
    'tags'?: Array<string>;
}

export const UpdateAccountRequestStatusEnum = {
    Active: 'ACTIVE',
    Draft: 'DRAFT'
} as const;

export type UpdateAccountRequestStatusEnum = typeof UpdateAccountRequestStatusEnum[keyof typeof UpdateAccountRequestStatusEnum];

/**
 * Request to update an addon
 * @export
 * @interface UpdateAddOnRequest
 */
export interface UpdateAddOnRequest {
    /**
     * Name of addon
     * @type {string}
     * @memberof UpdateAddOnRequest
     */
    'name'?: string;
    /**
     * Billable name of addon. Billable name takes precedence over name to display in invoice.
     * @type {string}
     * @memberof UpdateAddOnRequest
     */
    'billableName'?: string;
}
/**
 * Payload to update customer
 * @export
 * @interface UpdateCustomerRequest
 */
export interface UpdateCustomerRequest {
    /**
     * Name of the Customer
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'name'?: string;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'primaryEmail'?: string;
    /**
     * 
     * @type {Address}
     * @memberof UpdateCustomerRequest
     */
    'address'?: Address;
}
/**
 * Request to update event schema
 * @export
 * @interface UpdateEventSchemaRequest
 */
export interface UpdateEventSchemaRequest {
    /**
     * Description of the event
     * @type {string}
     * @memberof UpdateEventSchemaRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<EventAttributeSchema>}
     * @memberof UpdateEventSchemaRequest
     */
    'attributes'?: Array<EventAttributeSchema>;
    /**
     * 
     * @type {Array<DimensionsSchema>}
     * @memberof UpdateEventSchemaRequest
     */
    'dimensions'?: Array<DimensionsSchema>;
    /**
     * 
     * @type {Enrichments}
     * @memberof UpdateEventSchemaRequest
     */
    'enrichments'?: Enrichments;
    /**
     * List of fields that can be used for filtering in usage meter
     * @type {Array<string>}
     * @memberof UpdateEventSchemaRequest
     */
    'filterFields'?: Array<string>;
    /**
     * Template used to generate event id based on event payload
     * @type {string}
     * @memberof UpdateEventSchemaRequest
     */
    'eventIdTemplate'?: string;
}
/**
 * 
 * @export
 * @interface UpdateFeatureCreditsRequest
 */
export interface UpdateFeatureCreditsRequest {
    /**
     * Expiry date-time for a feature credits entry
     * @type {string}
     * @memberof UpdateFeatureCreditsRequest
     */
    'effectiveUntil'?: string;
    /**
     * Granted units for a feature credits entry
     * @type {number}
     * @memberof UpdateFeatureCreditsRequest
     */
    'granted'?: number;
}
/**
 * Update a Feature properties
 * @export
 * @interface UpdateFeatureRequest
 */
export interface UpdateFeatureRequest {
    /**
     * Name of the feature
     * @type {string}
     * @memberof UpdateFeatureRequest
     */
    'name'?: string;
    /**
     * Billable name of addon. Billable name takes precedence over name to display in invoice.
     * @type {string}
     * @memberof UpdateFeatureRequest
     */
    'billableName'?: string;
    /**
     * Association of a feature with event_schemas
     * @type {Array<EventSchemasForFeature>}
     * @memberof UpdateFeatureRequest
     */
    'schemaAssociations'?: Array<EventSchemasForFeature>;
}
/**
 * Add accounts to an invoice group
 * @export
 * @interface UpdateInvoiceGroupAccounts
 */
export interface UpdateInvoiceGroupAccounts {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateInvoiceGroupAccounts
     */
    'accountIds': Array<string>;
}
/**
 * Payload to update an invoice
 * @export
 * @interface UpdateInvoiceRequest
 */
export interface UpdateInvoiceRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'endDate'?: string;
    /**
     * Status of invoice
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'status'?: UpdateInvoiceRequestStatusEnum;
    /**
     * 
     * @type {Array<CustomInvoiceLineItem>}
     * @memberof UpdateInvoiceRequest
     */
    'lineItems'?: Array<CustomInvoiceLineItem>;
    /**
     * This property defines the behaviour of status updates of invoices like: Enabling this property to true auto updates the status of invoice to DUE or PAID accordingly But disabling this property of left null does not auto update the custom status 
     * @type {boolean}
     * @memberof UpdateInvoiceRequest
     */
    'autoAdvance'?: boolean;
}

export const UpdateInvoiceRequestStatusEnum = {
    Due: 'DUE',
    Paid: 'PAID',
    Void: 'VOID',
    UnCollectible: 'UN_COLLECTIBLE'
} as const;

export type UpdateInvoiceRequestStatusEnum = typeof UpdateInvoiceRequestStatusEnum[keyof typeof UpdateInvoiceRequestStatusEnum];

/**
 * Request to update a price plan
 * @export
 * @interface UpdatePricePlanRequest
 */
export interface UpdatePricePlanRequest {
    /**
     * Description of price plan
     * @type {string}
     * @memberof UpdatePricePlanRequest
     */
    'description'?: string;
    /**
     * 
     * @type {CreatePricePlanDetailsOverride}
     * @memberof UpdatePricePlanRequest
     */
    'pricePlanDetails'?: CreatePricePlanDetailsOverride;
    /**
     * 
     * @type {string}
     * @memberof UpdatePricePlanRequest
     */
    'migrationMode'?: UpdatePricePlanRequestMigrationModeEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdatePricePlanRequest
     */
    'versionsToMigrate'?: UpdatePricePlanRequestVersionsToMigrateEnum;
    /**
     * 
     * @type {Array<CreatePricingRule>}
     * @memberof UpdatePricePlanRequest
     */
    'pricingRules'?: Array<CreatePricingRule>;
}

export const UpdatePricePlanRequestMigrationModeEnum = {
    Immediate: 'IMMEDIATE',
    ImmediateIgnoreOverride: 'IMMEDIATE_IGNORE_OVERRIDE',
    NextCycle: 'NEXT_CYCLE',
    NextCycleIgnoreOverride: 'NEXT_CYCLE_IGNORE_OVERRIDE',
    None: 'NONE'
} as const;

export type UpdatePricePlanRequestMigrationModeEnum = typeof UpdatePricePlanRequestMigrationModeEnum[keyof typeof UpdatePricePlanRequestMigrationModeEnum];
export const UpdatePricePlanRequestVersionsToMigrateEnum = {
    LatestVersion: 'LATEST_VERSION',
    AllVersion: 'ALL_VERSION'
} as const;

export type UpdatePricePlanRequestVersionsToMigrateEnum = typeof UpdatePricePlanRequestVersionsToMigrateEnum[keyof typeof UpdatePricePlanRequestVersionsToMigrateEnum];

/**
 * 
 * @export
 * @interface UpdatePricingScheduleRequest
 */
export interface UpdatePricingScheduleRequest {
    /**
     * Mode of request to create dis/association
     * @type {string}
     * @memberof UpdatePricingScheduleRequest
     */
    'mode'?: UpdatePricingScheduleRequestModeEnum;
    /**
     * Id of the price plan if association request
     * @type {string}
     * @memberof UpdatePricingScheduleRequest
     */
    'pricePlanId'?: string;
    /**
     * Date of effectiveness of the association. The date is expected in YYYY-MM-DD format - Editing of a BILLING plan with deferredRevenue can be achieved with    effectiveFrom as start date of current cycle or using `retainStartOffset` option. 
     * @type {string}
     * @memberof UpdatePricingScheduleRequest
     */
    'effectiveFrom': string;
    /**
     * Date until which the association must be effective. The date is expected in YYYY-MM-DD format 
     * @type {string}
     * @memberof UpdatePricingScheduleRequest
     */
    'effectiveUntil': string;
    /**
     * 
     * @type {CreatePricePlanDetailsOverride}
     * @memberof UpdatePricingScheduleRequest
     */
    'pricePlanDetailsOverride'?: CreatePricePlanDetailsOverride;
    /**
     * 
     * @type {Array<CreatePricingRule>}
     * @memberof UpdatePricingScheduleRequest
     */
    'pricingRulesOverride'?: Array<CreatePricingRule>;
    /**
     * If this flag is true, current pricing cycle of the account on the date of association will continue rather  than the configurations of the newly associated price plan. Pricing cycle overrides specified  using  `pricePlanDetailsOverride` will take precedence over the pricing cycle configurations of  the new price plan that the account needs to migrate to. PricingCycleInterval of the existing plan and  the new plan must be same for this to work. We\'ll return a `400 BadRequest` otherwise. Examples:   - Ongoing plan (1st Oct to 30th Oct) - {dayOffset: 1, monthOffset: NIL}     New association (15th Oct to 15th Nov) of different price plan with retainStartOffsets option true      will use the same pricing cycle configuration {dayOffset: 1, monthOffset: NIL} rather than using the     pricing cycle configuration of the new price plan that the account needs to migrate to.   - Ongoing plan (1st Oct to 30th Oct) - {dayOffset: 1, monthOffset: NIL}     New association (1st Nov to 30th Nov) of different price plan with retainStartOffsets option true will     throw a `400 BadRequest` as no existing price plan configuration found on date of association  
     * @type {boolean}
     * @memberof UpdatePricingScheduleRequest
     */
    'retainStartOffsets'?: boolean;
}

export const UpdatePricingScheduleRequestModeEnum = {
    Associate: 'ASSOCIATE',
    Disassociate: 'DISASSOCIATE'
} as const;

export type UpdatePricingScheduleRequestModeEnum = typeof UpdatePricingScheduleRequestModeEnum[keyof typeof UpdatePricingScheduleRequestModeEnum];

/**
 * Request to associate or disassociate a price plan to an account with actions
 * @export
 * @interface UpdatePricingScheduleRequestWithActions
 */
export interface UpdatePricingScheduleRequestWithActions {
    /**
     * Mode of request to create dis/association
     * @type {string}
     * @memberof UpdatePricingScheduleRequestWithActions
     */
    'mode'?: UpdatePricingScheduleRequestWithActionsModeEnum;
    /**
     * Id of the price plan if association request
     * @type {string}
     * @memberof UpdatePricingScheduleRequestWithActions
     */
    'pricePlanId'?: string;
    /**
     * Date of effectiveness of the association. The date is expected in YYYY-MM-DD format - Editing of a BILLING plan with deferredRevenue can be achieved with    effectiveFrom as start date of current cycle or using `retainStartOffset` option. 
     * @type {string}
     * @memberof UpdatePricingScheduleRequestWithActions
     */
    'effectiveFrom': string;
    /**
     * Date until which the association must be effective. The date is expected in YYYY-MM-DD format 
     * @type {string}
     * @memberof UpdatePricingScheduleRequestWithActions
     */
    'effectiveUntil': string;
    /**
     * 
     * @type {CreatePricePlanDetailsOverride}
     * @memberof UpdatePricingScheduleRequestWithActions
     */
    'pricePlanDetailsOverride'?: CreatePricePlanDetailsOverride;
    /**
     * 
     * @type {Array<CreatePricingRule>}
     * @memberof UpdatePricingScheduleRequestWithActions
     */
    'pricingRulesOverride'?: Array<CreatePricingRule>;
    /**
     * If this flag is true, current pricing cycle of the account on the date of association will continue rather  than the configurations of the newly associated price plan. Pricing cycle overrides specified  using  `pricePlanDetailsOverride` will take precedence over the pricing cycle configurations of  the new price plan that the account needs to migrate to. PricingCycleInterval of the existing plan and  the new plan must be same for this to work. We\'ll return a `400 BadRequest` otherwise. Examples:   - Ongoing plan (1st Oct to 30th Oct) - {dayOffset: 1, monthOffset: NIL}     New association (15th Oct to 15th Nov) of different price plan with retainStartOffsets option true      will use the same pricing cycle configuration {dayOffset: 1, monthOffset: NIL} rather than using the     pricing cycle configuration of the new price plan that the account needs to migrate to.   - Ongoing plan (1st Oct to 30th Oct) - {dayOffset: 1, monthOffset: NIL}     New association (1st Nov to 30th Nov) of different price plan with retainStartOffsets option true will     throw a `400 BadRequest` as no existing price plan configuration found on date of association  
     * @type {boolean}
     * @memberof UpdatePricingScheduleRequestWithActions
     */
    'retainStartOffsets'?: boolean;
    /**
     * Pre actions to be performed before association or disassociation
     * @type {Array<PreAction>}
     * @memberof UpdatePricingScheduleRequestWithActions
     */
    'preActions'?: Array<PreAction>;
}

export const UpdatePricingScheduleRequestWithActionsModeEnum = {
    Associate: 'ASSOCIATE',
    Disassociate: 'DISASSOCIATE'
} as const;

export type UpdatePricingScheduleRequestWithActionsModeEnum = typeof UpdatePricingScheduleRequestWithActionsModeEnum[keyof typeof UpdatePricingScheduleRequestWithActionsModeEnum];

/**
 * 
 * @export
 * @interface UpdatePricingScheduleRequestWithActionsAllOf
 */
export interface UpdatePricingScheduleRequestWithActionsAllOf {
    /**
     * Pre actions to be performed before association or disassociation
     * @type {Array<PreAction>}
     * @memberof UpdatePricingScheduleRequestWithActionsAllOf
     */
    'preActions'?: Array<PreAction>;
}
/**
 * 
 * @export
 * @interface UpdatePricingScheduleResponse
 */
export interface UpdatePricingScheduleResponse {
    /**
     * Identifier of the account
     * @type {string}
     * @memberof UpdatePricingScheduleResponse
     */
    'accountId': string;
    /**
     * Name of the Account
     * @type {string}
     * @memberof UpdatePricingScheduleResponse
     */
    'accountName': string;
    /**
     * 
     * @type {Array<PlanOverride>}
     * @memberof UpdatePricingScheduleResponse
     */
    'pricingSchedules': Array<PlanOverride>;
}
/**
 * Approve or decline a proposal of a billing plan for an account
 * @export
 * @interface UpdateProposalStatus
 */
export interface UpdateProposalStatus {
    /**
     * 
     * @type {string}
     * @memberof UpdateProposalStatus
     */
    'status': UpdateProposalStatusStatusEnum;
}

export const UpdateProposalStatusStatusEnum = {
    Approve: 'APPROVE',
    Decline: 'DECLINE'
} as const;

export type UpdateProposalStatusStatusEnum = typeof UpdateProposalStatusStatusEnum[keyof typeof UpdateProposalStatusStatusEnum];

/**
 * Update Settings
 * @export
 * @interface UpdateSettingRequest
 */
export interface UpdateSettingRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateSettingRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSettingRequest
     */
    'value'?: string;
    /**
     * 
     * @type {SettingDataType}
     * @memberof UpdateSettingRequest
     */
    'dataType'?: SettingDataType;
}


/**
 * Request to update usage meter
 * @export
 * @interface UpdateUsageMeterRequest
 */
export interface UpdateUsageMeterRequest {
    /**
     * Name of usage meter.
     * @type {string}
     * @memberof UpdateUsageMeterRequest
     */
    'name'?: string;
    /**
     * Billable name of usage meter. Billable name takes precedence over name to display in invoice.
     * @type {string}
     * @memberof UpdateUsageMeterRequest
     */
    'billableName'?: string;
    /**
     * Description of the usage meter
     * @type {string}
     * @memberof UpdateUsageMeterRequest
     */
    'description'?: string;
    /**
     * Event Schema Identifier
     * @type {string}
     * @memberof UpdateUsageMeterRequest
     */
    'eventSchemaName'?: string;
    /**
     * Type of usage meter * COUNTER - Count usage 
     * @type {string}
     * @memberof UpdateUsageMeterRequest
     */
    'type'?: UpdateUsageMeterRequestTypeEnum;
    /**
     * 
     * @type {UsageMeterAggregation}
     * @memberof UpdateUsageMeterRequest
     */
    'aggregation'?: UsageMeterAggregation;
    /**
     * 
     * @type {Array<Computation>}
     * @memberof UpdateUsageMeterRequest
     */
    'computations'?: Array<Computation>;
    /**
     * 
     * @type {Array<UsageMeterFilterEntry>}
     * @memberof UpdateUsageMeterRequest
     */
    'filters'?: Array<UsageMeterFilterEntry>;
}

export const UpdateUsageMeterRequestTypeEnum = {
    Counter: 'COUNTER'
} as const;

export type UpdateUsageMeterRequestTypeEnum = typeof UpdateUsageMeterRequestTypeEnum[keyof typeof UpdateUsageMeterRequestTypeEnum];

/**
 * Payload to update wallet of an account
 * @export
 * @interface UpdateWalletRequest
 */
export interface UpdateWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateWalletRequest
     */
    'effectiveFrom'?: string;
    /**
     * 
     * @type {WalletStatus}
     * @memberof UpdateWalletRequest
     */
    'status'?: WalletStatus;
}


/**
 * Configuration for getting the usage
 * @export
 * @interface UsageConfig
 */
export interface UsageConfig {
    /**
     * Mode to get the usage for the usage meters - CUSTOM: Use the usages provided in the request - LOOKUP_RANGE: Use the usage of a given account for the specified range - LOOKUP_CYCLE: Use the usage of a given account for the specified cycle 
     * @type {string}
     * @memberof UsageConfig
     */
    'mode': UsageConfigModeEnum;
    /**
     * Map of usage meter id and usage, this will be considered if mode is CUSTOM
     * @type {{ [key: string]: number; }}
     * @memberof UsageConfig
     */
    'usageMap'?: { [key: string]: number; };
    /**
     * 
     * @type {UsageConfigLookupRange}
     * @memberof UsageConfig
     */
    'lookupRange'?: UsageConfigLookupRange;
    /**
     * 
     * @type {UsageConfigLookupCycle}
     * @memberof UsageConfig
     */
    'lookupCycle'?: UsageConfigLookupCycle;
}

export const UsageConfigModeEnum = {
    Custom: 'CUSTOM',
    LookupRange: 'LOOKUP_RANGE',
    LookupCycle: 'LOOKUP_CYCLE'
} as const;

export type UsageConfigModeEnum = typeof UsageConfigModeEnum[keyof typeof UsageConfigModeEnum];

/**
 * Cycle of usage to be looked up, this will be considered if mode is LOOKUP_CYCLE
 * @export
 * @interface UsageConfigLookupCycle
 */
export interface UsageConfigLookupCycle {
    /**
     * 
     * @type {string}
     * @memberof UsageConfigLookupCycle
     */
    'cycleEffectiveOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsageConfigLookupCycle
     */
    'accountId': string;
}
/**
 * Range of usage to be looked up, this will be considered if mode is LOOKUP_RANGE
 * @export
 * @interface UsageConfigLookupRange
 */
export interface UsageConfigLookupRange {
    /**
     * 
     * @type {string}
     * @memberof UsageConfigLookupRange
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof UsageConfigLookupRange
     */
    'end': string;
    /**
     * 
     * @type {string}
     * @memberof UsageConfigLookupRange
     */
    'accountId': string;
}
/**
 * UsageCycleInterval field allows you to treat the billing interval as many smaller windows. Revenue is calculated for each of the windows (usage cycles) and their sum is considered as the billing interval revenue. Example: 1 Named License being used across entire billing interval. Rate Value: $1/license CASE 1: Without usage cycle. $1 is charged for the entire billing cycle. CASE 2: Usage cycle is configure to be WEEKLY and the billing interval has 4 weeks. In this case $1 is charged  for each week totalling to $4 across for the billing interval 
 * @export
 * @enum {string}
 */

export const UsageCycleInterval = {
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Quarterly: 'QUARTERLY',
    HalfYearly: 'HALF_YEARLY',
    Annually: 'ANNUALLY'
} as const;

export type UsageCycleInterval = typeof UsageCycleInterval[keyof typeof UsageCycleInterval];


/**
 * Start and end dates of usage lookup if usage mode is LOOKUP
 * @export
 * @interface UsageLookupRange
 */
export interface UsageLookupRange {
    /**
     * 
     * @type {string}
     * @memberof UsageLookupRange
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof UsageLookupRange
     */
    'end': string;
}
/**
 * Structure of usage meter
 * @export
 * @interface UsageMeter
 */
export interface UsageMeter {
    /**
     * Identifier of the usage meter
     * @type {string}
     * @memberof UsageMeter
     */
    'id': string;
    /**
     * Name of the usage meter
     * @type {string}
     * @memberof UsageMeter
     */
    'name': string;
    /**
     * Billable name of addon. Billable name takes precedence over name to display in invoice.
     * @type {string}
     * @memberof UsageMeter
     */
    'billableName'?: string;
    /**
     * Display name of usage meter. This is an auto-generated field which contains billableName of usage meter. If billableName is not provided, name will be used as display name. 
     * @type {string}
     * @memberof UsageMeter
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof UsageMeter
     */
    'description'?: string;
    /**
     * 
     * @type {Array<UsageMeterFilterEntry>}
     * @memberof UsageMeter
     */
    'filters'?: Array<UsageMeterFilterEntry>;
    /**
     * Type of usage meter
     * @type {string}
     * @memberof UsageMeter
     */
    'type': UsageMeterTypeEnum;
    /**
     * Status of usage meter
     * @type {string}
     * @memberof UsageMeter
     */
    'status'?: UsageMeterStatusEnum;
    /**
     * 
     * @type {UsageMeterAggregation}
     * @memberof UsageMeter
     */
    'aggregation': UsageMeterAggregation;
    /**
     * 
     * @type {Array<Computation>}
     * @memberof UsageMeter
     */
    'computations'?: Array<Computation>;
    /**
     * 
     * @type {string}
     * @memberof UsageMeter
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsageMeter
     */
    'lastActivatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsageMeter
     */
    'updatedAt'?: string;
}

export const UsageMeterTypeEnum = {
    Counter: 'COUNTER'
} as const;

export type UsageMeterTypeEnum = typeof UsageMeterTypeEnum[keyof typeof UsageMeterTypeEnum];
export const UsageMeterStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type UsageMeterStatusEnum = typeof UsageMeterStatusEnum[keyof typeof UsageMeterStatusEnum];

/**
 * Aggregation to be applied on usage meter result * COUNT - Counts number of events matching the usage meter * SUM - Sums up results of computation of all events matching usage meter 
 * @export
 * @enum {string}
 */

export const UsageMeterAggregation = {
    Count: 'COUNT',
    Sum: 'SUM'
} as const;

export type UsageMeterAggregation = typeof UsageMeterAggregation[keyof typeof UsageMeterAggregation];


/**
 * Filter entry with field and value
 * @export
 * @interface UsageMeterFilterEntry
 */
export interface UsageMeterFilterEntry {
    /**
     * 
     * @type {string}
     * @memberof UsageMeterFilterEntry
     */
    'field': string;
    /**
     * 
     * @type {string}
     * @memberof UsageMeterFilterEntry
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface UsageMeterPaginatedResponse
 */
export interface UsageMeterPaginatedResponse {
    /**
     * 
     * @type {Array<UsageMeter>}
     * @memberof UsageMeterPaginatedResponse
     */
    'data'?: Array<UsageMeter>;
    /**
     * 
     * @type {string}
     * @memberof UsageMeterPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof UsageMeterPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * 
 * @export
 * @interface UsageRate
 */
export interface UsageRate {
    /**
     * The usage meter will be associated with the rate card to transform the usage value to billable value
     * @type {string}
     * @memberof UsageRate
     */
    'usageMeterId': string;
    /**
     * List of slab rates
     * @type {Array<SlabRate>}
     * @memberof UsageRate
     */
    'slabRates': Array<SlabRate>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UsageRate
     */
    'rateConfig'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface UsageRateCard
 */
export interface UsageRateCard {
    /**
     * Name your rate card, this will be displayed in the Togai App
     * @type {string}
     * @memberof UsageRateCard
     */
    'displayName'?: string;
    /**
     * A tag string to group usageRateCards
     * @type {string}
     * @memberof UsageRateCard
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsageRateCard
     */
    'usageMeterId': string;
    /**
     * 
     * @type {RatePlan}
     * @memberof UsageRateCard
     */
    'ratePlan': RatePlan;
    /**
     * 
     * @type {Array<RateValue>}
     * @memberof UsageRateCard
     */
    'rateValues': Array<RateValue>;
}
/**
 * 
 * @export
 * @interface ValidateEntitlementValueRequest
 */
export interface ValidateEntitlementValueRequest {
    /**
     * Value of the entitlement
     * @type {string}
     * @memberof ValidateEntitlementValueRequest
     */
    'value': string;
}
/**
 * Wallet Balance response
 * @export
 * @interface WalletBalanceResponse
 */
export interface WalletBalanceResponse {
    /**
     * 
     * @type {string}
     * @memberof WalletBalanceResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WalletBalanceResponse
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof WalletBalanceResponse
     */
    'customerId': string;
    /**
     * This amount is the difference of total credited amount and sum of consumed, hold amount. ie. credit amount - (consumed amount + hold amount) 
     * @type {number}
     * @memberof WalletBalanceResponse
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof WalletBalanceResponse
     */
    'creditUnit': string;
    /**
     * 
     * @type {string}
     * @memberof WalletBalanceResponse
     */
    'externalId'?: string;
    /**
     * 
     * @type {WalletStatus}
     * @memberof WalletBalanceResponse
     */
    'status': WalletStatus;
    /**
     * 
     * @type {number}
     * @memberof WalletBalanceResponse
     */
    'holdAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof WalletBalanceResponse
     */
    'effectiveFrom': string;
    /**
     * 
     * @type {string}
     * @memberof WalletBalanceResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletBalanceResponse
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WalletBalanceResponse
     */
    'metadata'?: { [key: string]: any; };
}


/**
 * List wallet entries response
 * @export
 * @interface WalletEntriesPaginatedResponse
 */
export interface WalletEntriesPaginatedResponse {
    /**
     * 
     * @type {Array<WalletEntry>}
     * @memberof WalletEntriesPaginatedResponse
     */
    'data': Array<WalletEntry>;
    /**
     * 
     * @type {string}
     * @memberof WalletEntriesPaginatedResponse
     */
    'nextToken'?: string;
}
/**
 * 
 * @export
 * @interface WalletEntry
 */
export interface WalletEntry {
    /**
     * Identifier of credit transactions
     * @type {string}
     * @memberof WalletEntry
     */
    'id': string;
    /**
     * description of the entry
     * @type {string}
     * @memberof WalletEntry
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletEntry
     */
    'walletId': string;
    /**
     * 
     * @type {string}
     * @memberof WalletEntry
     */
    'transactionType': WalletEntryTransactionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WalletEntry
     */
    'status': WalletEntryStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof WalletEntry
     */
    'entityId'?: string;
    /**
     * 
     * @type {number}
     * @memberof WalletEntry
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof WalletEntry
     */
    'createdAt': string;
    /**
     * 
     * @type {number}
     * @memberof WalletEntry
     */
    'closingBalance': number;
}

export const WalletEntryTransactionTypeEnum = {
    Credited: 'CREDITED',
    Debited: 'DEBITED'
} as const;

export type WalletEntryTransactionTypeEnum = typeof WalletEntryTransactionTypeEnum[keyof typeof WalletEntryTransactionTypeEnum];
export const WalletEntryStatusEnum = {
    Completed: 'COMPLETED',
    OnHold: 'ON_HOLD'
} as const;

export type WalletEntryStatusEnum = typeof WalletEntryStatusEnum[keyof typeof WalletEntryStatusEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const WalletStatus = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type WalletStatus = typeof WalletStatus[keyof typeof WalletStatus];


/**
 * Information related to wallet topup purchase
 * @export
 * @interface WalletTopupDetails
 */
export interface WalletTopupDetails {
    /**
     * Specifies the amount to be paid to top up wallet with the specified top up amount.  If left null, purchase amount will be same as top up amount 
     * @type {number}
     * @memberof WalletTopupDetails
     */
    'purchaseAmount'?: number;
    /**
     * Specifies the value to be topped up in the wallet
     * @type {number}
     * @memberof WalletTopupDetails
     */
    'topupAmount': number;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add aliases to an account using customer_id and account_id.
         * @summary Add Aliases to account
         * @param {string} accountId account_id corresponding to an account
         * @param {AddAccountAliasesRequest} addAccountAliasesRequest Payload to add aliases to account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAliases: async (accountId: string, addAccountAliasesRequest: AddAccountAliasesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('addAliases', 'accountId', accountId)
            // verify required parameter 'addAccountAliasesRequest' is not null or undefined
            assertParamExists('addAliases', 'addAccountAliasesRequest', addAccountAliasesRequest)
            const localVarPath = `/accounts/{account_id}/add_aliases`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAccountAliasesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to create an account for a customer using customer_id.
         * @summary Create an account
         * @param {CreateAccountRequest} createAccountRequest Payload to create account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (createAccountRequest: CreateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccountRequest' is not null or undefined
            assertParamExists('createAccount', 'createAccountRequest', createAccountRequest)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to create a proposal of a billing/entitlement plan for an account
         * @summary Propose a purchase of a plan
         * @param {string} accountId account_id corresponding to an account
         * @param {CreateProposalRequest} createProposalRequest Payload to initiate a proposal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProposal: async (accountId: string, createProposalRequest: CreateProposalRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createProposal', 'accountId', accountId)
            // verify required parameter 'createProposalRequest' is not null or undefined
            assertParamExists('createProposal', 'createProposalRequest', createProposalRequest)
            const localVarPath = `/accounts/{account_id}/purchase_proposals`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProposalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to delete a customer using customer_id and account_id.
         * @summary Delete an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account information using customer_id and account_id.
         * @summary Get an account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} [effectiveOn] 
         * @param {boolean} [includeGroupDetails] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (accountId: string, effectiveOn?: string, includeGroupDetails?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (effectiveOn !== undefined) {
                localVarQueryParameter['effectiveOn'] = (effectiveOn as any instanceof Date) ?
                    (effectiveOn as any).toISOString() :
                    effectiveOn;
            }

            if (includeGroupDetails !== undefined) {
                localVarQueryParameter['includeGroupDetails'] = includeGroupDetails;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of accounts of a customer with pagination and sort.
         * @summary List accounts of customer
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of pricing schedules of an account with pagination and sort.
         * @summary List pricing schedules of an account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [includePricePlanInfo] 
         * @param {boolean} [compact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingSchedules: async (accountId: string, nextToken?: string, pageSize?: number, startDate?: string, endDate?: string, includePricePlanInfo?: boolean, compact?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getPricingSchedules', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/pricing_schedules`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (includePricePlanInfo !== undefined) {
                localVarQueryParameter['include_price_plan_info'] = includePricePlanInfo;
            }

            if (compact !== undefined) {
                localVarQueryParameter['compact'] = compact;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get proposal information
         * @summary Get proposal information
         * @param {string} purchaseProposalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProposal: async (purchaseProposalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'purchaseProposalId' is not null or undefined
            assertParamExists('getProposal', 'purchaseProposalId', purchaseProposalId)
            const localVarPath = `/purchase_proposals/{purchase_proposal_id}`
                .replace(`{${"purchase_proposal_id"}}`, encodeURIComponent(String(purchaseProposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get purchase information of an account for a specific plan using account_id and price_plan_id
         * @summary Get a specific purchase of an account
         * @param {string} purchaseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPurchase: async (purchaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'purchaseId' is not null or undefined
            assertParamExists('getPurchase', 'purchaseId', purchaseId)
            const localVarPath = `/purchases/{purchase_id}`
                .replace(`{${"purchase_id"}}`, encodeURIComponent(String(purchaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to initiate a purchase for an account
         * @summary Initiate a purchase
         * @param {string} accountId account_id corresponding to an account
         * @param {CreatePurchaseRequest} createPurchaseRequest Payload to initiate a purchase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateOneTimeEntitlementPlan: async (accountId: string, createPurchaseRequest: CreatePurchaseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('initiateOneTimeEntitlementPlan', 'accountId', accountId)
            // verify required parameter 'createPurchaseRequest' is not null or undefined
            assertParamExists('initiateOneTimeEntitlementPlan', 'createPurchaseRequest', createPurchaseRequest)
            const localVarPath = `/accounts/{account_id}/purchases`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPurchaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all aliases of an account using account_id
         * @summary Get all aliases of an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountAliases: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listAccountAliases', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/account_aliases`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all proposals of an account
         * @summary List all proposals of an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountProposals: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listAccountProposals', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/purchase_proposals`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Purchase information for an account using account_id and price_plan_id
         * @summary Get all purchases for an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountPurchases: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listAccountPurchases', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/purchases`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove existing aliases tagged to an account using this API
         * @summary Remove Aliases to account
         * @param {string} accountId account_id corresponding to an account
         * @param {RemoveAccountAliasesRequest} removeAccountAliasesRequest Payload to remove aliases from account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAliases: async (accountId: string, removeAccountAliasesRequest: RemoveAccountAliasesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('removeAliases', 'accountId', accountId)
            // verify required parameter 'removeAccountAliasesRequest' is not null or undefined
            assertParamExists('removeAliases', 'removeAccountAliasesRequest', removeAccountAliasesRequest)
            const localVarPath = `/accounts/{account_id}/remove_aliases`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeAccountAliasesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to update an account’s information using customer_id and account_id.
         * @summary Update an account
         * @param {string} accountId account_id corresponding to an account
         * @param {UpdateAccountRequest} updateAccountRequest Payload to update account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (accountId: string, updateAccountRequest: UpdateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateAccount', 'accountId', accountId)
            // verify required parameter 'updateAccountRequest' is not null or undefined
            assertParamExists('updateAccount', 'updateAccountRequest', updateAccountRequest)
            const localVarPath = `/accounts/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to detach or attach a price plan with an existing account
         * @summary Dissociate or associate a price plan with an account
         * @param {string} accountId account_id corresponding to an account
         * @param {UpdatePricingScheduleRequestWithActions} updatePricingScheduleRequestWithActions Payload to associate or dissociate a price plan to an account with actions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricingSchedule: async (accountId: string, updatePricingScheduleRequestWithActions: UpdatePricingScheduleRequestWithActions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updatePricingSchedule', 'accountId', accountId)
            // verify required parameter 'updatePricingScheduleRequestWithActions' is not null or undefined
            assertParamExists('updatePricingSchedule', 'updatePricingScheduleRequestWithActions', updatePricingScheduleRequestWithActions)
            const localVarPath = `/accounts/{account_id}/price_plans`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePricingScheduleRequestWithActions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to detach/attach one or more price plans from/to an existing account
         * @summary Edit schedules of an account.
         * @param {string} accountId account_id corresponding to an account
         * @param {EditPricingScheduleRequest} editPricingScheduleRequest Payload to dis/associate one or more price plans to an account
         * @param {boolean} [dryRun] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricingScheduleBatch: async (accountId: string, editPricingScheduleRequest: EditPricingScheduleRequest, dryRun?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updatePricingScheduleBatch', 'accountId', accountId)
            // verify required parameter 'editPricingScheduleRequest' is not null or undefined
            assertParamExists('updatePricingScheduleBatch', 'editPricingScheduleRequest', editPricingScheduleRequest)
            const localVarPath = `/accounts/{account_id}/edit_schedules`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editPricingScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to approve or decline a proposal of a billing plan for an account
         * @summary Approve or decline a purchase of a billing plan
         * @param {string} purchaseProposalId 
         * @param {UpdateProposalStatus} updateProposalStatus Payload to approve or decline a proposal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProposalStatus: async (purchaseProposalId: string, updateProposalStatus: UpdateProposalStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'purchaseProposalId' is not null or undefined
            assertParamExists('updateProposalStatus', 'purchaseProposalId', purchaseProposalId)
            // verify required parameter 'updateProposalStatus' is not null or undefined
            assertParamExists('updateProposalStatus', 'updateProposalStatus', updateProposalStatus)
            const localVarPath = `/purchase_proposals/{purchase_proposal_id}/update_status`
                .replace(`{${"purchase_proposal_id"}}`, encodeURIComponent(String(purchaseProposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProposalStatus, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add aliases to an account using customer_id and account_id.
         * @summary Add Aliases to account
         * @param {string} accountId account_id corresponding to an account
         * @param {AddAccountAliasesRequest} addAccountAliasesRequest Payload to add aliases to account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAliases(accountId: string, addAccountAliasesRequest: AddAccountAliasesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAliases(accountId, addAccountAliasesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to create an account for a customer using customer_id.
         * @summary Create an account
         * @param {CreateAccountRequest} createAccountRequest Payload to create account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(createAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to create a proposal of a billing/entitlement plan for an account
         * @summary Propose a purchase of a plan
         * @param {string} accountId account_id corresponding to an account
         * @param {CreateProposalRequest} createProposalRequest Payload to initiate a proposal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProposal(accountId: string, createProposalRequest: CreateProposalRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Proposal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProposal(accountId, createProposalRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to delete a customer using customer_id and account_id.
         * @summary Delete an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get account information using customer_id and account_id.
         * @summary Get an account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} [effectiveOn] 
         * @param {boolean} [includeGroupDetails] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(accountId: string, effectiveOn?: string, includeGroupDetails?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(accountId, effectiveOn, includeGroupDetails, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of accounts of a customer with pagination and sort.
         * @summary List accounts of customer
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of pricing schedules of an account with pagination and sort.
         * @summary List pricing schedules of an account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [includePricePlanInfo] 
         * @param {boolean} [compact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricingSchedules(accountId: string, nextToken?: string, pageSize?: number, startDate?: string, endDate?: string, includePricePlanInfo?: boolean, compact?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricingSchedulePaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricingSchedules(accountId, nextToken, pageSize, startDate, endDate, includePricePlanInfo, compact, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get proposal information
         * @summary Get proposal information
         * @param {string} purchaseProposalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProposal(purchaseProposalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProposalResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProposal(purchaseProposalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get purchase information of an account for a specific plan using account_id and price_plan_id
         * @summary Get a specific purchase of an account
         * @param {string} purchaseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPurchase(purchaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPurchaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPurchase(purchaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to initiate a purchase for an account
         * @summary Initiate a purchase
         * @param {string} accountId account_id corresponding to an account
         * @param {CreatePurchaseRequest} createPurchaseRequest Payload to initiate a purchase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateOneTimeEntitlementPlan(accountId: string, createPurchaseRequest: CreatePurchaseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Purchase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateOneTimeEntitlementPlan(accountId, createPurchaseRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all aliases of an account using account_id
         * @summary Get all aliases of an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountAliases(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountAliasesPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountAliases(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all proposals of an account
         * @summary List all proposals of an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountProposals(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProposalsPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountProposals(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Purchase information for an account using account_id and price_plan_id
         * @summary Get all purchases for an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountPurchases(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PurchasePaginatedListData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountPurchases(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove existing aliases tagged to an account using this API
         * @summary Remove Aliases to account
         * @param {string} accountId account_id corresponding to an account
         * @param {RemoveAccountAliasesRequest} removeAccountAliasesRequest Payload to remove aliases from account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAliases(accountId: string, removeAccountAliasesRequest: RemoveAccountAliasesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAliases(accountId, removeAccountAliasesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to update an account’s information using customer_id and account_id.
         * @summary Update an account
         * @param {string} accountId account_id corresponding to an account
         * @param {UpdateAccountRequest} updateAccountRequest Payload to update account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(accountId: string, updateAccountRequest: UpdateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(accountId, updateAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to detach or attach a price plan with an existing account
         * @summary Dissociate or associate a price plan with an account
         * @param {string} accountId account_id corresponding to an account
         * @param {UpdatePricingScheduleRequestWithActions} updatePricingScheduleRequestWithActions Payload to associate or dissociate a price plan to an account with actions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePricingSchedule(accountId: string, updatePricingScheduleRequestWithActions: UpdatePricingScheduleRequestWithActions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdatePricingScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePricingSchedule(accountId, updatePricingScheduleRequestWithActions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to detach/attach one or more price plans from/to an existing account
         * @summary Edit schedules of an account.
         * @param {string} accountId account_id corresponding to an account
         * @param {EditPricingScheduleRequest} editPricingScheduleRequest Payload to dis/associate one or more price plans to an account
         * @param {boolean} [dryRun] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePricingScheduleBatch(accountId: string, editPricingScheduleRequest: EditPricingScheduleRequest, dryRun?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdatePricingScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePricingScheduleBatch(accountId, editPricingScheduleRequest, dryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to approve or decline a proposal of a billing plan for an account
         * @summary Approve or decline a purchase of a billing plan
         * @param {string} purchaseProposalId 
         * @param {UpdateProposalStatus} updateProposalStatus Payload to approve or decline a proposal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProposalStatus(purchaseProposalId: string, updateProposalStatus: UpdateProposalStatus, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Proposal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProposalStatus(purchaseProposalId, updateProposalStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Add aliases to an account using customer_id and account_id.
         * @summary Add Aliases to account
         * @param {string} accountId account_id corresponding to an account
         * @param {AddAccountAliasesRequest} addAccountAliasesRequest Payload to add aliases to account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAliases(accountId: string, addAccountAliasesRequest: AddAccountAliasesRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.addAliases(accountId, addAccountAliasesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to create an account for a customer using customer_id.
         * @summary Create an account
         * @param {CreateAccountRequest} createAccountRequest Payload to create account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(createAccountRequest: CreateAccountRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.createAccount(createAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to create a proposal of a billing/entitlement plan for an account
         * @summary Propose a purchase of a plan
         * @param {string} accountId account_id corresponding to an account
         * @param {CreateProposalRequest} createProposalRequest Payload to initiate a proposal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProposal(accountId: string, createProposalRequest: CreateProposalRequest, options?: any): AxiosPromise<Proposal> {
            return localVarFp.createProposal(accountId, createProposalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to delete a customer using customer_id and account_id.
         * @summary Delete an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(accountId: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get account information using customer_id and account_id.
         * @summary Get an account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} [effectiveOn] 
         * @param {boolean} [includeGroupDetails] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accountId: string, effectiveOn?: string, includeGroupDetails?: boolean, options?: any): AxiosPromise<Account> {
            return localVarFp.getAccount(accountId, effectiveOn, includeGroupDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of accounts of a customer with pagination and sort.
         * @summary List accounts of customer
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(nextToken?: string, pageSize?: number, options?: any): AxiosPromise<AccountPaginatedResponse> {
            return localVarFp.getAccounts(nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of pricing schedules of an account with pagination and sort.
         * @summary List pricing schedules of an account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [includePricePlanInfo] 
         * @param {boolean} [compact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingSchedules(accountId: string, nextToken?: string, pageSize?: number, startDate?: string, endDate?: string, includePricePlanInfo?: boolean, compact?: boolean, options?: any): AxiosPromise<PricingSchedulePaginatedResponse> {
            return localVarFp.getPricingSchedules(accountId, nextToken, pageSize, startDate, endDate, includePricePlanInfo, compact, options).then((request) => request(axios, basePath));
        },
        /**
         * Get proposal information
         * @summary Get proposal information
         * @param {string} purchaseProposalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProposal(purchaseProposalId: string, options?: any): AxiosPromise<GetProposalResponse> {
            return localVarFp.getProposal(purchaseProposalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get purchase information of an account for a specific plan using account_id and price_plan_id
         * @summary Get a specific purchase of an account
         * @param {string} purchaseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPurchase(purchaseId: string, options?: any): AxiosPromise<GetPurchaseResponse> {
            return localVarFp.getPurchase(purchaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to initiate a purchase for an account
         * @summary Initiate a purchase
         * @param {string} accountId account_id corresponding to an account
         * @param {CreatePurchaseRequest} createPurchaseRequest Payload to initiate a purchase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateOneTimeEntitlementPlan(accountId: string, createPurchaseRequest: CreatePurchaseRequest, options?: any): AxiosPromise<Purchase> {
            return localVarFp.initiateOneTimeEntitlementPlan(accountId, createPurchaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all aliases of an account using account_id
         * @summary Get all aliases of an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountAliases(accountId: string, options?: any): AxiosPromise<AccountAliasesPaginatedResponse> {
            return localVarFp.listAccountAliases(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all proposals of an account
         * @summary List all proposals of an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountProposals(accountId: string, options?: any): AxiosPromise<ProposalsPaginatedResponse> {
            return localVarFp.listAccountProposals(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Purchase information for an account using account_id and price_plan_id
         * @summary Get all purchases for an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountPurchases(accountId: string, options?: any): AxiosPromise<PurchasePaginatedListData> {
            return localVarFp.listAccountPurchases(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove existing aliases tagged to an account using this API
         * @summary Remove Aliases to account
         * @param {string} accountId account_id corresponding to an account
         * @param {RemoveAccountAliasesRequest} removeAccountAliasesRequest Payload to remove aliases from account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAliases(accountId: string, removeAccountAliasesRequest: RemoveAccountAliasesRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.removeAliases(accountId, removeAccountAliasesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to update an account’s information using customer_id and account_id.
         * @summary Update an account
         * @param {string} accountId account_id corresponding to an account
         * @param {UpdateAccountRequest} updateAccountRequest Payload to update account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(accountId: string, updateAccountRequest: UpdateAccountRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.updateAccount(accountId, updateAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to detach or attach a price plan with an existing account
         * @summary Dissociate or associate a price plan with an account
         * @param {string} accountId account_id corresponding to an account
         * @param {UpdatePricingScheduleRequestWithActions} updatePricingScheduleRequestWithActions Payload to associate or dissociate a price plan to an account with actions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricingSchedule(accountId: string, updatePricingScheduleRequestWithActions: UpdatePricingScheduleRequestWithActions, options?: any): AxiosPromise<UpdatePricingScheduleResponse> {
            return localVarFp.updatePricingSchedule(accountId, updatePricingScheduleRequestWithActions, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to detach/attach one or more price plans from/to an existing account
         * @summary Edit schedules of an account.
         * @param {string} accountId account_id corresponding to an account
         * @param {EditPricingScheduleRequest} editPricingScheduleRequest Payload to dis/associate one or more price plans to an account
         * @param {boolean} [dryRun] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricingScheduleBatch(accountId: string, editPricingScheduleRequest: EditPricingScheduleRequest, dryRun?: boolean, options?: any): AxiosPromise<UpdatePricingScheduleResponse> {
            return localVarFp.updatePricingScheduleBatch(accountId, editPricingScheduleRequest, dryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to approve or decline a proposal of a billing plan for an account
         * @summary Approve or decline a purchase of a billing plan
         * @param {string} purchaseProposalId 
         * @param {UpdateProposalStatus} updateProposalStatus Payload to approve or decline a proposal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProposalStatus(purchaseProposalId: string, updateProposalStatus: UpdateProposalStatus, options?: any): AxiosPromise<Proposal> {
            return localVarFp.updateProposalStatus(purchaseProposalId, updateProposalStatus, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Add aliases to an account using customer_id and account_id.
     * @summary Add Aliases to account
     * @param {string} accountId account_id corresponding to an account
     * @param {AddAccountAliasesRequest} addAccountAliasesRequest Payload to add aliases to account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public addAliases(accountId: string, addAccountAliasesRequest: AddAccountAliasesRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).addAliases(accountId, addAccountAliasesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to create an account for a customer using customer_id.
     * @summary Create an account
     * @param {CreateAccountRequest} createAccountRequest Payload to create account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccount(createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createAccount(createAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to create a proposal of a billing/entitlement plan for an account
     * @summary Propose a purchase of a plan
     * @param {string} accountId account_id corresponding to an account
     * @param {CreateProposalRequest} createProposalRequest Payload to initiate a proposal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createProposal(accountId: string, createProposalRequest: CreateProposalRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createProposal(accountId, createProposalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to delete a customer using customer_id and account_id.
     * @summary Delete an account
     * @param {string} accountId account_id corresponding to an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteAccount(accountId: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).deleteAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get account information using customer_id and account_id.
     * @summary Get an account
     * @param {string} accountId account_id corresponding to an account
     * @param {string} [effectiveOn] 
     * @param {boolean} [includeGroupDetails] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(accountId: string, effectiveOn?: string, includeGroupDetails?: boolean, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(accountId, effectiveOn, includeGroupDetails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of accounts of a customer with pagination and sort.
     * @summary List accounts of customer
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccounts(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccounts(nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of pricing schedules of an account with pagination and sort.
     * @summary List pricing schedules of an account
     * @param {string} accountId account_id corresponding to an account
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {boolean} [includePricePlanInfo] 
     * @param {boolean} [compact] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getPricingSchedules(accountId: string, nextToken?: string, pageSize?: number, startDate?: string, endDate?: string, includePricePlanInfo?: boolean, compact?: boolean, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getPricingSchedules(accountId, nextToken, pageSize, startDate, endDate, includePricePlanInfo, compact, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get proposal information
     * @summary Get proposal information
     * @param {string} purchaseProposalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getProposal(purchaseProposalId: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getProposal(purchaseProposalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get purchase information of an account for a specific plan using account_id and price_plan_id
     * @summary Get a specific purchase of an account
     * @param {string} purchaseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getPurchase(purchaseId: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getPurchase(purchaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to initiate a purchase for an account
     * @summary Initiate a purchase
     * @param {string} accountId account_id corresponding to an account
     * @param {CreatePurchaseRequest} createPurchaseRequest Payload to initiate a purchase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public initiateOneTimeEntitlementPlan(accountId: string, createPurchaseRequest: CreatePurchaseRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).initiateOneTimeEntitlementPlan(accountId, createPurchaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all aliases of an account using account_id
     * @summary Get all aliases of an account
     * @param {string} accountId account_id corresponding to an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAccountAliases(accountId: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listAccountAliases(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all proposals of an account
     * @summary List all proposals of an account
     * @param {string} accountId account_id corresponding to an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAccountProposals(accountId: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listAccountProposals(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Purchase information for an account using account_id and price_plan_id
     * @summary Get all purchases for an account
     * @param {string} accountId account_id corresponding to an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAccountPurchases(accountId: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listAccountPurchases(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove existing aliases tagged to an account using this API
     * @summary Remove Aliases to account
     * @param {string} accountId account_id corresponding to an account
     * @param {RemoveAccountAliasesRequest} removeAccountAliasesRequest Payload to remove aliases from account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public removeAliases(accountId: string, removeAccountAliasesRequest: RemoveAccountAliasesRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).removeAliases(accountId, removeAccountAliasesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to update an account’s information using customer_id and account_id.
     * @summary Update an account
     * @param {string} accountId account_id corresponding to an account
     * @param {UpdateAccountRequest} updateAccountRequest Payload to update account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateAccount(accountId: string, updateAccountRequest: UpdateAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updateAccount(accountId, updateAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to detach or attach a price plan with an existing account
     * @summary Dissociate or associate a price plan with an account
     * @param {string} accountId account_id corresponding to an account
     * @param {UpdatePricingScheduleRequestWithActions} updatePricingScheduleRequestWithActions Payload to associate or dissociate a price plan to an account with actions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updatePricingSchedule(accountId: string, updatePricingScheduleRequestWithActions: UpdatePricingScheduleRequestWithActions, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updatePricingSchedule(accountId, updatePricingScheduleRequestWithActions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to detach/attach one or more price plans from/to an existing account
     * @summary Edit schedules of an account.
     * @param {string} accountId account_id corresponding to an account
     * @param {EditPricingScheduleRequest} editPricingScheduleRequest Payload to dis/associate one or more price plans to an account
     * @param {boolean} [dryRun] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updatePricingScheduleBatch(accountId: string, editPricingScheduleRequest: EditPricingScheduleRequest, dryRun?: boolean, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updatePricingScheduleBatch(accountId, editPricingScheduleRequest, dryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to approve or decline a proposal of a billing plan for an account
     * @summary Approve or decline a purchase of a billing plan
     * @param {string} purchaseProposalId 
     * @param {UpdateProposalStatus} updateProposalStatus Payload to approve or decline a proposal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateProposalStatus(purchaseProposalId: string, updateProposalStatus: UpdateProposalStatus, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updateProposalStatus(purchaseProposalId, updateProposalStatus, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AddOnsApi - axios parameter creator
 * @export
 */
export const AddOnsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an AddOn
         * @summary Create an AddOn
         * @param {CreateAddOnRequest} createAddOnRequest Payload to create addon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddOn: async (createAddOnRequest: CreateAddOnRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAddOnRequest' is not null or undefined
            assertParamExists('createAddOn', 'createAddOnRequest', createAddOnRequest)
            const localVarPath = `/addons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAddOnRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archive an addOn
         * @summary Delete an addon
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAddOn: async (addonId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addonId' is not null or undefined
            assertParamExists('deleteAddOn', 'addonId', addonId)
            const localVarPath = `/addons/{addon_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of an addon
         * @summary Get an addon
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddOn: async (addonId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addonId' is not null or undefined
            assertParamExists('getAddOn', 'addonId', addonId)
            const localVarPath = `/addons/{addon_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of add-ons
         * @summary List addOns
         * @param {'ACTIVE' | 'ARCHIVED'} [status] Filter by status 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddOns: async (status?: 'ACTIVE' | 'ARCHIVED', nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/addons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing addon 
         * @summary Update an addon
         * @param {string} addonId 
         * @param {UpdateAddOnRequest} updateAddOnRequest Payload to update addon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAddOn: async (addonId: string, updateAddOnRequest: UpdateAddOnRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addonId' is not null or undefined
            assertParamExists('updateAddOn', 'addonId', addonId)
            // verify required parameter 'updateAddOnRequest' is not null or undefined
            assertParamExists('updateAddOn', 'updateAddOnRequest', updateAddOnRequest)
            const localVarPath = `/addons/{addon_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAddOnRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddOnsApi - functional programming interface
 * @export
 */
export const AddOnsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddOnsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an AddOn
         * @summary Create an AddOn
         * @param {CreateAddOnRequest} createAddOnRequest Payload to create addon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAddOn(createAddOnRequest: CreateAddOnRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAddOn(createAddOnRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Archive an addOn
         * @summary Delete an addon
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAddOn(addonId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAddOn(addonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of an addon
         * @summary Get an addon
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddOn(addonId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddOn(addonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of add-ons
         * @summary List addOns
         * @param {'ACTIVE' | 'ARCHIVED'} [status] Filter by status 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddOns(status?: 'ACTIVE' | 'ARCHIVED', nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOnPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddOns(status, nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing addon 
         * @summary Update an addon
         * @param {string} addonId 
         * @param {UpdateAddOnRequest} updateAddOnRequest Payload to update addon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAddOn(addonId: string, updateAddOnRequest: UpdateAddOnRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAddOn(addonId, updateAddOnRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddOnsApi - factory interface
 * @export
 */
export const AddOnsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddOnsApiFp(configuration)
    return {
        /**
         * Create an AddOn
         * @summary Create an AddOn
         * @param {CreateAddOnRequest} createAddOnRequest Payload to create addon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddOn(createAddOnRequest: CreateAddOnRequest, options?: any): AxiosPromise<AddOn> {
            return localVarFp.createAddOn(createAddOnRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Archive an addOn
         * @summary Delete an addon
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAddOn(addonId: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteAddOn(addonId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of an addon
         * @summary Get an addon
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddOn(addonId: string, options?: any): AxiosPromise<AddOn> {
            return localVarFp.getAddOn(addonId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of add-ons
         * @summary List addOns
         * @param {'ACTIVE' | 'ARCHIVED'} [status] Filter by status 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddOns(status?: 'ACTIVE' | 'ARCHIVED', nextToken?: string, pageSize?: number, options?: any): AxiosPromise<AddOnPaginatedResponse> {
            return localVarFp.getAddOns(status, nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing addon 
         * @summary Update an addon
         * @param {string} addonId 
         * @param {UpdateAddOnRequest} updateAddOnRequest Payload to update addon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAddOn(addonId: string, updateAddOnRequest: UpdateAddOnRequest, options?: any): AxiosPromise<AddOn> {
            return localVarFp.updateAddOn(addonId, updateAddOnRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddOnsApi - object-oriented interface
 * @export
 * @class AddOnsApi
 * @extends {BaseAPI}
 */
export class AddOnsApi extends BaseAPI {
    /**
     * Create an AddOn
     * @summary Create an AddOn
     * @param {CreateAddOnRequest} createAddOnRequest Payload to create addon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddOnsApi
     */
    public createAddOn(createAddOnRequest: CreateAddOnRequest, options?: AxiosRequestConfig) {
        return AddOnsApiFp(this.configuration).createAddOn(createAddOnRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archive an addOn
     * @summary Delete an addon
     * @param {string} addonId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddOnsApi
     */
    public deleteAddOn(addonId: string, options?: AxiosRequestConfig) {
        return AddOnsApiFp(this.configuration).deleteAddOn(addonId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of an addon
     * @summary Get an addon
     * @param {string} addonId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddOnsApi
     */
    public getAddOn(addonId: string, options?: AxiosRequestConfig) {
        return AddOnsApiFp(this.configuration).getAddOn(addonId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of add-ons
     * @summary List addOns
     * @param {'ACTIVE' | 'ARCHIVED'} [status] Filter by status 
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddOnsApi
     */
    public getAddOns(status?: 'ACTIVE' | 'ARCHIVED', nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return AddOnsApiFp(this.configuration).getAddOns(status, nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing addon 
     * @summary Update an addon
     * @param {string} addonId 
     * @param {UpdateAddOnRequest} updateAddOnRequest Payload to update addon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddOnsApi
     */
    public updateAddOn(addonId: string, updateAddOnRequest: UpdateAddOnRequest, options?: AxiosRequestConfig) {
        return AddOnsApiFp(this.configuration).updateAddOn(addonId, updateAddOnRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AliasesApi - axios parameter creator
 * @export
 */
export const AliasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API let’s you to create an alias
         * @summary Create an alias
         * @param {CreateBulkAliasRequest} createBulkAliasRequest Payload to create bulk aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias: async (createBulkAliasRequest: CreateBulkAliasRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBulkAliasRequest' is not null or undefined
            assertParamExists('createAlias', 'createBulkAliasRequest', createBulkAliasRequest)
            const localVarPath = `/aliases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBulkAliasRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to delete an alias using alias.
         * @summary Delete an alias
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlias: async (alias: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alias' is not null or undefined
            assertParamExists('deleteAlias', 'alias', alias)
            const localVarPath = `/aliases/{alias}`
                .replace(`{${"alias"}}`, encodeURIComponent(String(alias)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get alias information using alias.
         * @summary Get an alias
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlias: async (alias: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alias' is not null or undefined
            assertParamExists('getAlias', 'alias', alias)
            const localVarPath = `/aliases/{alias}`
                .replace(`{${"alias"}}`, encodeURIComponent(String(alias)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of aliases with pagination and sort.
         * @summary List all aliases
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAliases: async (nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aliases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AliasesApi - functional programming interface
 * @export
 */
export const AliasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AliasesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API let’s you to create an alias
         * @summary Create an alias
         * @param {CreateBulkAliasRequest} createBulkAliasRequest Payload to create bulk aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlias(createBulkAliasRequest: CreateBulkAliasRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AliasPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlias(createBulkAliasRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to delete an alias using alias.
         * @summary Delete an alias
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlias(alias: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlias(alias, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get alias information using alias.
         * @summary Get an alias
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlias(alias: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Alias>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlias(alias, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of aliases with pagination and sort.
         * @summary List all aliases
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAliases(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AliasPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAliases(nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AliasesApi - factory interface
 * @export
 */
export const AliasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AliasesApiFp(configuration)
    return {
        /**
         * This API let’s you to create an alias
         * @summary Create an alias
         * @param {CreateBulkAliasRequest} createBulkAliasRequest Payload to create bulk aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias(createBulkAliasRequest: CreateBulkAliasRequest, options?: any): AxiosPromise<AliasPaginatedResponse> {
            return localVarFp.createAlias(createBulkAliasRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to delete an alias using alias.
         * @summary Delete an alias
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlias(alias: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteAlias(alias, options).then((request) => request(axios, basePath));
        },
        /**
         * Get alias information using alias.
         * @summary Get an alias
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlias(alias: string, options?: any): AxiosPromise<Alias> {
            return localVarFp.getAlias(alias, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of aliases with pagination and sort.
         * @summary List all aliases
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAliases(nextToken?: string, pageSize?: number, options?: any): AxiosPromise<AliasPaginatedResponse> {
            return localVarFp.listAliases(nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AliasesApi - object-oriented interface
 * @export
 * @class AliasesApi
 * @extends {BaseAPI}
 */
export class AliasesApi extends BaseAPI {
    /**
     * This API let’s you to create an alias
     * @summary Create an alias
     * @param {CreateBulkAliasRequest} createBulkAliasRequest Payload to create bulk aliases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public createAlias(createBulkAliasRequest: CreateBulkAliasRequest, options?: AxiosRequestConfig) {
        return AliasesApiFp(this.configuration).createAlias(createBulkAliasRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to delete an alias using alias.
     * @summary Delete an alias
     * @param {string} alias 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public deleteAlias(alias: string, options?: AxiosRequestConfig) {
        return AliasesApiFp(this.configuration).deleteAlias(alias, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get alias information using alias.
     * @summary Get an alias
     * @param {string} alias 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public getAlias(alias: string, options?: AxiosRequestConfig) {
        return AliasesApiFp(this.configuration).getAlias(alias, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of aliases with pagination and sort.
     * @summary List all aliases
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public listAliases(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return AliasesApiFp(this.configuration).listAliases(nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates and returns a bearer token. Behavior of this API differs on the basis of the auth mechanism used to make the request.   - For API key auth, this API generates a JWT token whcih is valid for 24 hours and returns it.   - For JWT bearer auth, returns the same JWT token in response For information on how to generate API token, refer [Generating New API Keys](https://docs.togai.com/api-reference/authentication#generating-new-api-keys) section of docs. 
         * @summary Generate short lived bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Generates and returns a bearer token. Behavior of this API differs on the basis of the auth mechanism used to make the request.   - For API key auth, this API generates a JWT token whcih is valid for 24 hours and returns it.   - For JWT bearer auth, returns the same JWT token in response For information on how to generate API token, refer [Generating New API Keys](https://docs.togai.com/api-reference/authentication#generating-new-api-keys) section of docs. 
         * @summary Generate short lived bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Generates and returns a bearer token. Behavior of this API differs on the basis of the auth mechanism used to make the request.   - For API key auth, this API generates a JWT token whcih is valid for 24 hours and returns it.   - For JWT bearer auth, returns the same JWT token in response For information on how to generate API token, refer [Generating New API Keys](https://docs.togai.com/api-reference/authentication#generating-new-api-keys) section of docs. 
         * @summary Generate short lived bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(options?: any): AxiosPromise<TokenResponse> {
            return localVarFp.authenticate(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Generates and returns a bearer token. Behavior of this API differs on the basis of the auth mechanism used to make the request.   - For API key auth, this API generates a JWT token whcih is valid for 24 hours and returns it.   - For JWT bearer auth, returns the same JWT token in response For information on how to generate API token, refer [Generating New API Keys](https://docs.togai.com/api-reference/authentication#generating-new-api-keys) section of docs. 
     * @summary Generate short lived bearer token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticate(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticate(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreditsApi - axios parameter creator
 * @export
 */
export const CreditsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Grant credit
         * @summary Grant credit
         * @param {CreateCreditRequest} [createCreditRequest] Payload to grant credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredit: async (createCreditRequest?: CreateCreditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/credits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCreditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Credit balance for Account
         * @summary Credit balance for Account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditBalanceForAccount: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('creditBalanceForAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/credit_balance`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get credit details
         * @summary Get credit details
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditDetails: async (creditId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'creditId' is not null or undefined
            assertParamExists('getCreditDetails', 'creditId', creditId)
            const localVarPath = `/credits/{credit_id}`
                .replace(`{${"credit_id"}}`, encodeURIComponent(String(creditId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all credits
         * @summary List credits
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [id] Filter option to filter based on credit id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredits: async (nextToken?: string, status?: string, accountId?: string, id?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/credits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Void credit
         * @summary Void credit
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidCredit: async (creditId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'creditId' is not null or undefined
            assertParamExists('voidCredit', 'creditId', creditId)
            const localVarPath = `/credits/{credit_id}/void`
                .replace(`{${"credit_id"}}`, encodeURIComponent(String(creditId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditsApi - functional programming interface
 * @export
 */
export const CreditsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditsApiAxiosParamCreator(configuration)
    return {
        /**
         * Grant credit
         * @summary Grant credit
         * @param {CreateCreditRequest} [createCreditRequest] Payload to grant credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCredit(createCreditRequest?: CreateCreditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCreditResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCredit(createCreditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Credit balance for Account
         * @summary Credit balance for Account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditBalanceForAccount(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditBalanceForAccount(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get credit details
         * @summary Get credit details
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCreditDetails(creditId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCreditDetails(creditId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all credits
         * @summary List credits
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [id] Filter option to filter based on credit id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCredits(nextToken?: string, status?: string, accountId?: string, id?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCreditsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCredits(nextToken, status, accountId, id, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Void credit
         * @summary Void credit
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voidCredit(creditId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voidCredit(creditId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreditsApi - factory interface
 * @export
 */
export const CreditsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditsApiFp(configuration)
    return {
        /**
         * Grant credit
         * @summary Grant credit
         * @param {CreateCreditRequest} [createCreditRequest] Payload to grant credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredit(createCreditRequest?: CreateCreditRequest, options?: any): AxiosPromise<CreateCreditResponse> {
            return localVarFp.createCredit(createCreditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Credit balance for Account
         * @summary Credit balance for Account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditBalanceForAccount(accountId: string, options?: any): AxiosPromise<CreditBalanceResponse> {
            return localVarFp.creditBalanceForAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get credit details
         * @summary Get credit details
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditDetails(creditId: string, options?: any): AxiosPromise<CreditDetailsResponse> {
            return localVarFp.getCreditDetails(creditId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all credits
         * @summary List credits
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [id] Filter option to filter based on credit id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredits(nextToken?: string, status?: string, accountId?: string, id?: string, pageSize?: number, options?: any): AxiosPromise<ListCreditsResponse> {
            return localVarFp.listCredits(nextToken, status, accountId, id, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Void credit
         * @summary Void credit
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidCredit(creditId: string, options?: any): AxiosPromise<Credit> {
            return localVarFp.voidCredit(creditId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreditsApi - object-oriented interface
 * @export
 * @class CreditsApi
 * @extends {BaseAPI}
 */
export class CreditsApi extends BaseAPI {
    /**
     * Grant credit
     * @summary Grant credit
     * @param {CreateCreditRequest} [createCreditRequest] Payload to grant credits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public createCredit(createCreditRequest?: CreateCreditRequest, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).createCredit(createCreditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Credit balance for Account
     * @summary Credit balance for Account
     * @param {string} accountId account_id corresponding to an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditBalanceForAccount(accountId: string, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditBalanceForAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get credit details
     * @summary Get credit details
     * @param {string} creditId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public getCreditDetails(creditId: string, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).getCreditDetails(creditId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all credits
     * @summary List credits
     * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
     * @param {string} [status] Filter option to filter by status.
     * @param {string} [accountId] Filter option to filter based on account id.
     * @param {string} [id] Filter option to filter based on credit id.
     * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public listCredits(nextToken?: string, status?: string, accountId?: string, id?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).listCredits(nextToken, status, accountId, id, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Void credit
     * @summary Void credit
     * @param {string} creditId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public voidCredit(creditId: string, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).voidCredit(creditId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomerPortalApi - axios parameter creator
 * @export
 */
export const CustomerPortalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get delegate token for customer portal
         * @summary Get delegate token for customer portal
         * @param {GetCustomerPortalDelegateTokenRequest} getCustomerPortalDelegateTokenRequest Payload to get delegate token for customer portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerPortalDelegateToken: async (getCustomerPortalDelegateTokenRequest: GetCustomerPortalDelegateTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getCustomerPortalDelegateTokenRequest' is not null or undefined
            assertParamExists('getCustomerPortalDelegateToken', 'getCustomerPortalDelegateTokenRequest', getCustomerPortalDelegateTokenRequest)
            const localVarPath = `/portal/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getCustomerPortalDelegateTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerPortalApi - functional programming interface
 * @export
 */
export const CustomerPortalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomerPortalApiAxiosParamCreator(configuration)
    return {
        /**
         * Get delegate token for customer portal
         * @summary Get delegate token for customer portal
         * @param {GetCustomerPortalDelegateTokenRequest} getCustomerPortalDelegateTokenRequest Payload to get delegate token for customer portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerPortalDelegateToken(getCustomerPortalDelegateTokenRequest: GetCustomerPortalDelegateTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerPortalDelegateToken(getCustomerPortalDelegateTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomerPortalApi - factory interface
 * @export
 */
export const CustomerPortalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomerPortalApiFp(configuration)
    return {
        /**
         * Get delegate token for customer portal
         * @summary Get delegate token for customer portal
         * @param {GetCustomerPortalDelegateTokenRequest} getCustomerPortalDelegateTokenRequest Payload to get delegate token for customer portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerPortalDelegateToken(getCustomerPortalDelegateTokenRequest: GetCustomerPortalDelegateTokenRequest, options?: any): AxiosPromise<TokenResponse> {
            return localVarFp.getCustomerPortalDelegateToken(getCustomerPortalDelegateTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomerPortalApi - object-oriented interface
 * @export
 * @class CustomerPortalApi
 * @extends {BaseAPI}
 */
export class CustomerPortalApi extends BaseAPI {
    /**
     * Get delegate token for customer portal
     * @summary Get delegate token for customer portal
     * @param {GetCustomerPortalDelegateTokenRequest} getCustomerPortalDelegateTokenRequest Payload to get delegate token for customer portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerPortalApi
     */
    public getCustomerPortalDelegateToken(getCustomerPortalDelegateTokenRequest: GetCustomerPortalDelegateTokenRequest, options?: AxiosRequestConfig) {
        return CustomerPortalApiFp(this.configuration).getCustomerPortalDelegateToken(getCustomerPortalDelegateTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomersApi - axios parameter creator
 * @export
 */
export const CustomersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API let’s you to create customers and corresponding accounts.
         * @summary Create a customer
         * @param {CreateCustomerRequest} createCustomerRequest Payload to create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer: async (createCustomerRequest: CreateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCustomerRequest' is not null or undefined
            assertParamExists('createCustomer', 'createCustomerRequest', createCustomerRequest)
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to create a contact for the customer
         * @summary Create a contact for the customer
         * @param {string} customerId 
         * @param {CreateCustomerContactRequest} createCustomerContactRequest Payload to create a contact for a customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerContact: async (customerId: string, createCustomerContactRequest: CreateCustomerContactRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('createCustomerContact', 'customerId', customerId)
            // verify required parameter 'createCustomerContactRequest' is not null or undefined
            assertParamExists('createCustomerContact', 'createCustomerContactRequest', createCustomerContactRequest)
            const localVarPath = `/customers/{customer_id}/contacts`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomerContactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to delete a customer using customer_id.
         * @summary Delete a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer: async (customerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('deleteCustomer', 'customerId', customerId)
            const localVarPath = `/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get customer information using customer_id.
         * @summary Get a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer: async (customerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getCustomer', 'customerId', customerId)
            const localVarPath = `/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of customers with pagination and sort.
         * @summary List customers
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers: async (nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to update a customer’s information using customer_id.
         * @summary Update a customer
         * @param {string} customerId 
         * @param {UpdateCustomerRequest} updateCustomerRequest Payload to update customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer: async (customerId: string, updateCustomerRequest: UpdateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('updateCustomer', 'customerId', customerId)
            // verify required parameter 'updateCustomerRequest' is not null or undefined
            assertParamExists('updateCustomer', 'updateCustomerRequest', updateCustomerRequest)
            const localVarPath = `/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomersApi - functional programming interface
 * @export
 */
export const CustomersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomersApiAxiosParamCreator(configuration)
    return {
        /**
         * This API let’s you to create customers and corresponding accounts.
         * @summary Create a customer
         * @param {CreateCustomerRequest} createCustomerRequest Payload to create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomer(createCustomerRequest: CreateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomer(createCustomerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to create a contact for the customer
         * @summary Create a contact for the customer
         * @param {string} customerId 
         * @param {CreateCustomerContactRequest} createCustomerContactRequest Payload to create a contact for a customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomerContact(customerId: string, createCustomerContactRequest: CreateCustomerContactRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomerContactResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomerContact(customerId, createCustomerContactRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to delete a customer using customer_id.
         * @summary Delete a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomer(customerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomer(customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get customer information using customer_id.
         * @summary Get a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomer(customerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomer(customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of customers with pagination and sort.
         * @summary List customers
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomers(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomers(nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to update a customer’s information using customer_id.
         * @summary Update a customer
         * @param {string} customerId 
         * @param {UpdateCustomerRequest} updateCustomerRequest Payload to update customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomer(customerId, updateCustomerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomersApi - factory interface
 * @export
 */
export const CustomersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomersApiFp(configuration)
    return {
        /**
         * This API let’s you to create customers and corresponding accounts.
         * @summary Create a customer
         * @param {CreateCustomerRequest} createCustomerRequest Payload to create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(createCustomerRequest: CreateCustomerRequest, options?: any): AxiosPromise<CreateCustomerResponse> {
            return localVarFp.createCustomer(createCustomerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to create a contact for the customer
         * @summary Create a contact for the customer
         * @param {string} customerId 
         * @param {CreateCustomerContactRequest} createCustomerContactRequest Payload to create a contact for a customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerContact(customerId: string, createCustomerContactRequest: CreateCustomerContactRequest, options?: any): AxiosPromise<CreateCustomerContactResponse> {
            return localVarFp.createCustomerContact(customerId, createCustomerContactRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to delete a customer using customer_id.
         * @summary Delete a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(customerId: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteCustomer(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get customer information using customer_id.
         * @summary Get a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(customerId: string, options?: any): AxiosPromise<Customer> {
            return localVarFp.getCustomer(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of customers with pagination and sort.
         * @summary List customers
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers(nextToken?: string, pageSize?: number, options?: any): AxiosPromise<CustomerPaginatedResponse> {
            return localVarFp.getCustomers(nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to update a customer’s information using customer_id.
         * @summary Update a customer
         * @param {string} customerId 
         * @param {UpdateCustomerRequest} updateCustomerRequest Payload to update customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: any): AxiosPromise<Customer> {
            return localVarFp.updateCustomer(customerId, updateCustomerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */
export class CustomersApi extends BaseAPI {
    /**
     * This API let’s you to create customers and corresponding accounts.
     * @summary Create a customer
     * @param {CreateCustomerRequest} createCustomerRequest Payload to create customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public createCustomer(createCustomerRequest: CreateCustomerRequest, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).createCustomer(createCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to create a contact for the customer
     * @summary Create a contact for the customer
     * @param {string} customerId 
     * @param {CreateCustomerContactRequest} createCustomerContactRequest Payload to create a contact for a customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public createCustomerContact(customerId: string, createCustomerContactRequest: CreateCustomerContactRequest, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).createCustomerContact(customerId, createCustomerContactRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to delete a customer using customer_id.
     * @summary Delete a customer
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public deleteCustomer(customerId: string, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).deleteCustomer(customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get customer information using customer_id.
     * @summary Get a customer
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomer(customerId: string, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getCustomer(customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of customers with pagination and sort.
     * @summary List customers
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomers(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getCustomers(nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to update a customer’s information using customer_id.
     * @summary Update a customer
     * @param {string} customerId 
     * @param {UpdateCustomerRequest} updateCustomerRequest Payload to update customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).updateCustomer(customerId, updateCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EntitlementsApi - axios parameter creator
 * @export
 */
export const EntitlementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API let’s you to get the entitlement value for a account
         * @summary Get entitlement value for a account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlementValue: async (accountId: string, featureId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getEntitlementValue', 'accountId', accountId)
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('getEntitlementValue', 'featureId', featureId)
            const localVarPath = `/accounts/{account_id}/entitlements/{feature_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to get the entitlements for a account
         * @summary Get entitlements for a account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlements: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getEntitlements', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/entitlements`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to get the feature credits balance
         * @summary Get Feature credits balance
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureCredits: async (accountId: string, featureId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getFeatureCredits', 'accountId', accountId)
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('getFeatureCredits', 'featureId', featureId)
            const localVarPath = `/accounts/{account_id}/features/{feature_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to ingest an event if a user is entitled to a feature
         * @summary Ingest event if a user is entitled to a feature
         * @param {IngestEventRequest} [ingestEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestEntitledEvent: async (ingestEventRequest?: IngestEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/entitled`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingestEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to list the feature credits entries of a feature for an account
         * @summary List feature credits entries of a feature for an account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeatureCreditEntries: async (accountId: string, featureId: string, pageSize?: number, nextToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listFeatureCreditEntries', 'accountId', accountId)
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('listFeatureCreditEntries', 'featureId', featureId)
            const localVarPath = `/accounts/{account_id}/features/{feature_id}/entries`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * #### This API let\'s you to update the following attributes: `effectiveUntil` and `granted`  - **effectiveUntil**: must be in future - **granted**: must be greater than the existing usage (previous granted - current balance) 
         * @summary Update a feature credits entry
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {string} entryId &#x60;entryId&#x60; corresponding to a particular entitlement/overage grant entry  Formats: 1. If source of entry is an entitlement grant rate card in price plan: &#x60;schedule_id#pricing_cycle_start_date$PRICE_PLAN&#x60; 2. If source of entry is an entitlement overage rate card in price plan: &#x60;schedule_id#pricing_cycle_start_date$OVERAGE&#x60; 3. If source of entry is a purchase: &#x60;purchase_id#int_index$PURCHASE&#x60; 
         * @param {UpdateFeatureCreditsRequest} [updateFeatureCreditsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeatureCreditEntry: async (accountId: string, featureId: string, entryId: string, updateFeatureCreditsRequest?: UpdateFeatureCreditsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateFeatureCreditEntry', 'accountId', accountId)
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('updateFeatureCreditEntry', 'featureId', featureId)
            // verify required parameter 'entryId' is not null or undefined
            assertParamExists('updateFeatureCreditEntry', 'entryId', entryId)
            const localVarPath = `/accounts/{account_id}/features/{feature_id}/entries/{entry_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)))
                .replace(`{${"entry_id"}}`, encodeURIComponent(String(entryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFeatureCreditsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to validate the entitlement value for a account
         * @summary Check entitlement value for a account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {ValidateEntitlementValueRequest} [validateEntitlementValueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEntitlementValue: async (accountId: string, featureId: string, validateEntitlementValueRequest?: ValidateEntitlementValueRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('validateEntitlementValue', 'accountId', accountId)
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('validateEntitlementValue', 'featureId', featureId)
            const localVarPath = `/accounts/{account_id}/entitlements/{feature_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validateEntitlementValueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to void the feature credits entries of a feature for an account
         * @summary Void a feature credits entry of a feature for an account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {string} entryId &#x60;entryId&#x60; corresponding to a particular entitlement/overage grant entry  Formats: 1. If source of entry is an entitlement grant rate card in price plan: &#x60;schedule_id#pricing_cycle_start_date$PRICE_PLAN&#x60; 2. If source of entry is an entitlement overage rate card in price plan: &#x60;schedule_id#pricing_cycle_start_date$OVERAGE&#x60; 3. If source of entry is a purchase: &#x60;purchase_id#int_index$PURCHASE&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidFeatureCreditEntry: async (accountId: string, featureId: string, entryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('voidFeatureCreditEntry', 'accountId', accountId)
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('voidFeatureCreditEntry', 'featureId', featureId)
            // verify required parameter 'entryId' is not null or undefined
            assertParamExists('voidFeatureCreditEntry', 'entryId', entryId)
            const localVarPath = `/accounts/{account_id}/features/{feature_id}/entries/{entry_id}/void`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)))
                .replace(`{${"entry_id"}}`, encodeURIComponent(String(entryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntitlementsApi - functional programming interface
 * @export
 */
export const EntitlementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntitlementsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API let’s you to get the entitlement value for a account
         * @summary Get entitlement value for a account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitlementValue(accountId: string, featureId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEntitlementValuesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitlementValue(accountId, featureId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to get the entitlements for a account
         * @summary Get entitlements for a account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitlements(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEntitlementValuesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitlements(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to get the feature credits balance
         * @summary Get Feature credits balance
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureCredits(accountId: string, featureId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFeatureCreditsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureCredits(accountId, featureId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to ingest an event if a user is entitled to a feature
         * @summary Ingest event if a user is entitled to a feature
         * @param {IngestEventRequest} [ingestEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingestEntitledEvent(ingestEventRequest?: IngestEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingestEntitledEvent(ingestEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to list the feature credits entries of a feature for an account
         * @summary List feature credits entries of a feature for an account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFeatureCreditEntries(accountId: string, featureId: string, pageSize?: number, nextToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFeatureCreditEntriesPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFeatureCreditEntries(accountId, featureId, pageSize, nextToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * #### This API let\'s you to update the following attributes: `effectiveUntil` and `granted`  - **effectiveUntil**: must be in future - **granted**: must be greater than the existing usage (previous granted - current balance) 
         * @summary Update a feature credits entry
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {string} entryId &#x60;entryId&#x60; corresponding to a particular entitlement/overage grant entry  Formats: 1. If source of entry is an entitlement grant rate card in price plan: &#x60;schedule_id#pricing_cycle_start_date$PRICE_PLAN&#x60; 2. If source of entry is an entitlement overage rate card in price plan: &#x60;schedule_id#pricing_cycle_start_date$OVERAGE&#x60; 3. If source of entry is a purchase: &#x60;purchase_id#int_index$PURCHASE&#x60; 
         * @param {UpdateFeatureCreditsRequest} [updateFeatureCreditsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeatureCreditEntry(accountId: string, featureId: string, entryId: string, updateFeatureCreditsRequest?: UpdateFeatureCreditsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureCreditEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeatureCreditEntry(accountId, featureId, entryId, updateFeatureCreditsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to validate the entitlement value for a account
         * @summary Check entitlement value for a account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {ValidateEntitlementValueRequest} [validateEntitlementValueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateEntitlementValue(accountId: string, featureId: string, validateEntitlementValueRequest?: ValidateEntitlementValueRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateEntitlementValue(accountId, featureId, validateEntitlementValueRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to void the feature credits entries of a feature for an account
         * @summary Void a feature credits entry of a feature for an account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {string} entryId &#x60;entryId&#x60; corresponding to a particular entitlement/overage grant entry  Formats: 1. If source of entry is an entitlement grant rate card in price plan: &#x60;schedule_id#pricing_cycle_start_date$PRICE_PLAN&#x60; 2. If source of entry is an entitlement overage rate card in price plan: &#x60;schedule_id#pricing_cycle_start_date$OVERAGE&#x60; 3. If source of entry is a purchase: &#x60;purchase_id#int_index$PURCHASE&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voidFeatureCreditEntry(accountId: string, featureId: string, entryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voidFeatureCreditEntry(accountId, featureId, entryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EntitlementsApi - factory interface
 * @export
 */
export const EntitlementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntitlementsApiFp(configuration)
    return {
        /**
         * This API let’s you to get the entitlement value for a account
         * @summary Get entitlement value for a account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlementValue(accountId: string, featureId: string, options?: any): AxiosPromise<GetEntitlementValuesResponse> {
            return localVarFp.getEntitlementValue(accountId, featureId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to get the entitlements for a account
         * @summary Get entitlements for a account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlements(accountId: string, options?: any): AxiosPromise<GetEntitlementValuesResponse> {
            return localVarFp.getEntitlements(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to get the feature credits balance
         * @summary Get Feature credits balance
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureCredits(accountId: string, featureId: string, options?: any): AxiosPromise<GetFeatureCreditsResponse> {
            return localVarFp.getFeatureCredits(accountId, featureId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to ingest an event if a user is entitled to a feature
         * @summary Ingest event if a user is entitled to a feature
         * @param {IngestEventRequest} [ingestEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestEntitledEvent(ingestEventRequest?: IngestEventRequest, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.ingestEntitledEvent(ingestEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to list the feature credits entries of a feature for an account
         * @summary List feature credits entries of a feature for an account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeatureCreditEntries(accountId: string, featureId: string, pageSize?: number, nextToken?: string, options?: any): AxiosPromise<GetFeatureCreditEntriesPaginatedResponse> {
            return localVarFp.listFeatureCreditEntries(accountId, featureId, pageSize, nextToken, options).then((request) => request(axios, basePath));
        },
        /**
         * #### This API let\'s you to update the following attributes: `effectiveUntil` and `granted`  - **effectiveUntil**: must be in future - **granted**: must be greater than the existing usage (previous granted - current balance) 
         * @summary Update a feature credits entry
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {string} entryId &#x60;entryId&#x60; corresponding to a particular entitlement/overage grant entry  Formats: 1. If source of entry is an entitlement grant rate card in price plan: &#x60;schedule_id#pricing_cycle_start_date$PRICE_PLAN&#x60; 2. If source of entry is an entitlement overage rate card in price plan: &#x60;schedule_id#pricing_cycle_start_date$OVERAGE&#x60; 3. If source of entry is a purchase: &#x60;purchase_id#int_index$PURCHASE&#x60; 
         * @param {UpdateFeatureCreditsRequest} [updateFeatureCreditsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeatureCreditEntry(accountId: string, featureId: string, entryId: string, updateFeatureCreditsRequest?: UpdateFeatureCreditsRequest, options?: any): AxiosPromise<FeatureCreditEntry> {
            return localVarFp.updateFeatureCreditEntry(accountId, featureId, entryId, updateFeatureCreditsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to validate the entitlement value for a account
         * @summary Check entitlement value for a account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {ValidateEntitlementValueRequest} [validateEntitlementValueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEntitlementValue(accountId: string, featureId: string, validateEntitlementValueRequest?: ValidateEntitlementValueRequest, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.validateEntitlementValue(accountId, featureId, validateEntitlementValueRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to void the feature credits entries of a feature for an account
         * @summary Void a feature credits entry of a feature for an account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {string} entryId &#x60;entryId&#x60; corresponding to a particular entitlement/overage grant entry  Formats: 1. If source of entry is an entitlement grant rate card in price plan: &#x60;schedule_id#pricing_cycle_start_date$PRICE_PLAN&#x60; 2. If source of entry is an entitlement overage rate card in price plan: &#x60;schedule_id#pricing_cycle_start_date$OVERAGE&#x60; 3. If source of entry is a purchase: &#x60;purchase_id#int_index$PURCHASE&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidFeatureCreditEntry(accountId: string, featureId: string, entryId: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.voidFeatureCreditEntry(accountId, featureId, entryId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntitlementsApi - object-oriented interface
 * @export
 * @class EntitlementsApi
 * @extends {BaseAPI}
 */
export class EntitlementsApi extends BaseAPI {
    /**
     * This API let’s you to get the entitlement value for a account
     * @summary Get entitlement value for a account
     * @param {string} accountId account_id corresponding to an account
     * @param {string} featureId feature_id corresponding to a feature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementsApi
     */
    public getEntitlementValue(accountId: string, featureId: string, options?: AxiosRequestConfig) {
        return EntitlementsApiFp(this.configuration).getEntitlementValue(accountId, featureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to get the entitlements for a account
     * @summary Get entitlements for a account
     * @param {string} accountId account_id corresponding to an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementsApi
     */
    public getEntitlements(accountId: string, options?: AxiosRequestConfig) {
        return EntitlementsApiFp(this.configuration).getEntitlements(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to get the feature credits balance
     * @summary Get Feature credits balance
     * @param {string} accountId account_id corresponding to an account
     * @param {string} featureId feature_id corresponding to a feature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementsApi
     */
    public getFeatureCredits(accountId: string, featureId: string, options?: AxiosRequestConfig) {
        return EntitlementsApiFp(this.configuration).getFeatureCredits(accountId, featureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to ingest an event if a user is entitled to a feature
     * @summary Ingest event if a user is entitled to a feature
     * @param {IngestEventRequest} [ingestEventRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementsApi
     */
    public ingestEntitledEvent(ingestEventRequest?: IngestEventRequest, options?: AxiosRequestConfig) {
        return EntitlementsApiFp(this.configuration).ingestEntitledEvent(ingestEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to list the feature credits entries of a feature for an account
     * @summary List feature credits entries of a feature for an account
     * @param {string} accountId account_id corresponding to an account
     * @param {string} featureId feature_id corresponding to a feature
     * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
     * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementsApi
     */
    public listFeatureCreditEntries(accountId: string, featureId: string, pageSize?: number, nextToken?: string, options?: AxiosRequestConfig) {
        return EntitlementsApiFp(this.configuration).listFeatureCreditEntries(accountId, featureId, pageSize, nextToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * #### This API let\'s you to update the following attributes: `effectiveUntil` and `granted`  - **effectiveUntil**: must be in future - **granted**: must be greater than the existing usage (previous granted - current balance) 
     * @summary Update a feature credits entry
     * @param {string} accountId account_id corresponding to an account
     * @param {string} featureId feature_id corresponding to a feature
     * @param {string} entryId &#x60;entryId&#x60; corresponding to a particular entitlement/overage grant entry  Formats: 1. If source of entry is an entitlement grant rate card in price plan: &#x60;schedule_id#pricing_cycle_start_date$PRICE_PLAN&#x60; 2. If source of entry is an entitlement overage rate card in price plan: &#x60;schedule_id#pricing_cycle_start_date$OVERAGE&#x60; 3. If source of entry is a purchase: &#x60;purchase_id#int_index$PURCHASE&#x60; 
     * @param {UpdateFeatureCreditsRequest} [updateFeatureCreditsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementsApi
     */
    public updateFeatureCreditEntry(accountId: string, featureId: string, entryId: string, updateFeatureCreditsRequest?: UpdateFeatureCreditsRequest, options?: AxiosRequestConfig) {
        return EntitlementsApiFp(this.configuration).updateFeatureCreditEntry(accountId, featureId, entryId, updateFeatureCreditsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to validate the entitlement value for a account
     * @summary Check entitlement value for a account
     * @param {string} accountId account_id corresponding to an account
     * @param {string} featureId feature_id corresponding to a feature
     * @param {ValidateEntitlementValueRequest} [validateEntitlementValueRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementsApi
     */
    public validateEntitlementValue(accountId: string, featureId: string, validateEntitlementValueRequest?: ValidateEntitlementValueRequest, options?: AxiosRequestConfig) {
        return EntitlementsApiFp(this.configuration).validateEntitlementValue(accountId, featureId, validateEntitlementValueRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to void the feature credits entries of a feature for an account
     * @summary Void a feature credits entry of a feature for an account
     * @param {string} accountId account_id corresponding to an account
     * @param {string} featureId feature_id corresponding to a feature
     * @param {string} entryId &#x60;entryId&#x60; corresponding to a particular entitlement/overage grant entry  Formats: 1. If source of entry is an entitlement grant rate card in price plan: &#x60;schedule_id#pricing_cycle_start_date$PRICE_PLAN&#x60; 2. If source of entry is an entitlement overage rate card in price plan: &#x60;schedule_id#pricing_cycle_start_date$OVERAGE&#x60; 3. If source of entry is a purchase: &#x60;purchase_id#int_index$PURCHASE&#x60; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementsApi
     */
    public voidFeatureCreditEntry(accountId: string, featureId: string, entryId: string, options?: AxiosRequestConfig) {
        return EntitlementsApiFp(this.configuration).voidFeatureCreditEntry(accountId, featureId, entryId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventIngestionApi - axios parameter creator
 * @export
 */
export const EventIngestionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API let’s you to ingest events to your Togai account. Events ingested using this API will be processed via associated usage meters and further via associated price plans to generate final billable value to invoice the customer Read more about [Event Ingestion](https://docs.togai.com/docs/event-ingestion) 
         * @summary Ingest events to Togai
         * @param {IngestEventRequest} ingestEventRequest Request body to ingest events to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingest: async (ingestEventRequest: IngestEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ingestEventRequest' is not null or undefined
            assertParamExists('ingest', 'ingestEventRequest', ingestEventRequest)
            const localVarPath = `/ingest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingestEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to ingest events in batch upto 500 events. Ingest large amounts of events up to 500 in batches in an array using this API.
         * @summary Ingest events to Togai in batch
         * @param {IngestBatchEventRequest} ingestBatchEventRequest Request body to ingest events in batch to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestBatch: async (ingestBatchEventRequest: IngestBatchEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ingestBatchEventRequest' is not null or undefined
            assertParamExists('ingestBatch', 'ingestBatchEventRequest', ingestBatchEventRequest)
            const localVarPath = `/ingestBatch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingestBatchEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventIngestionApi - functional programming interface
 * @export
 */
export const EventIngestionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventIngestionApiAxiosParamCreator(configuration)
    return {
        /**
         * This API let’s you to ingest events to your Togai account. Events ingested using this API will be processed via associated usage meters and further via associated price plans to generate final billable value to invoice the customer Read more about [Event Ingestion](https://docs.togai.com/docs/event-ingestion) 
         * @summary Ingest events to Togai
         * @param {IngestEventRequest} ingestEventRequest Request body to ingest events to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingest(ingestEventRequest: IngestEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngestEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingest(ingestEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to ingest events in batch upto 500 events. Ingest large amounts of events up to 500 in batches in an array using this API.
         * @summary Ingest events to Togai in batch
         * @param {IngestBatchEventRequest} ingestBatchEventRequest Request body to ingest events in batch to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingestBatch(ingestBatchEventRequest: IngestBatchEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngestEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingestBatch(ingestBatchEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventIngestionApi - factory interface
 * @export
 */
export const EventIngestionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventIngestionApiFp(configuration)
    return {
        /**
         * This API let’s you to ingest events to your Togai account. Events ingested using this API will be processed via associated usage meters and further via associated price plans to generate final billable value to invoice the customer Read more about [Event Ingestion](https://docs.togai.com/docs/event-ingestion) 
         * @summary Ingest events to Togai
         * @param {IngestEventRequest} ingestEventRequest Request body to ingest events to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingest(ingestEventRequest: IngestEventRequest, options?: any): AxiosPromise<IngestEventResponse> {
            return localVarFp.ingest(ingestEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to ingest events in batch upto 500 events. Ingest large amounts of events up to 500 in batches in an array using this API.
         * @summary Ingest events to Togai in batch
         * @param {IngestBatchEventRequest} ingestBatchEventRequest Request body to ingest events in batch to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestBatch(ingestBatchEventRequest: IngestBatchEventRequest, options?: any): AxiosPromise<IngestEventResponse> {
            return localVarFp.ingestBatch(ingestBatchEventRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventIngestionApi - object-oriented interface
 * @export
 * @class EventIngestionApi
 * @extends {BaseAPI}
 */
export class EventIngestionApi extends BaseAPI {
    /**
     * This API let’s you to ingest events to your Togai account. Events ingested using this API will be processed via associated usage meters and further via associated price plans to generate final billable value to invoice the customer Read more about [Event Ingestion](https://docs.togai.com/docs/event-ingestion) 
     * @summary Ingest events to Togai
     * @param {IngestEventRequest} ingestEventRequest Request body to ingest events to Togai usage and billing management service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventIngestionApi
     */
    public ingest(ingestEventRequest: IngestEventRequest, options?: AxiosRequestConfig) {
        return EventIngestionApiFp(this.configuration).ingest(ingestEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to ingest events in batch upto 500 events. Ingest large amounts of events up to 500 in batches in an array using this API.
     * @summary Ingest events to Togai in batch
     * @param {IngestBatchEventRequest} ingestBatchEventRequest Request body to ingest events in batch to Togai usage and billing management service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventIngestionApi
     */
    public ingestBatch(ingestBatchEventRequest: IngestBatchEventRequest, options?: AxiosRequestConfig) {
        return EventIngestionApiFp(this.configuration).ingestBatch(ingestBatchEventRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventManagementApi - axios parameter creator
 * @export
 */
export const EventManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * #### This API lets you to correct events. Available in both synchronous and asynchronous mode - **Usages**: Reduction of all usages associated with this event - **Revenue**: Reduction of all revenues associated with this event - **Entitlements**: Entitlements(Feature Credits) consumed by this event are granted back to the account.  ### Possible Actions: - UNDO: Undo all usages, revenue and entitlements associated with an event - REDO: Performs UNDO and re-ingests the same event - REDO_EVENT: Performs UNDO and re-ingests the correction payload of the event 
         * @summary Correct an ingested event
         * @param {'UNDO' | 'REDO' | 'REDO_EVENT'} action Action to perform in event correction
         * @param {boolean} [requireConfirmation] Specifies whether to start a migration only after a confirmation
         * @param {EventCorrectionRequest} [eventCorrectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventCorrection: async (action: 'UNDO' | 'REDO' | 'REDO_EVENT', requireConfirmation?: boolean, eventCorrectionRequest?: EventCorrectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'action' is not null or undefined
            assertParamExists('eventCorrection', 'action', action)
            const localVarPath = `/events/correction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (requireConfirmation !== undefined) {
                localVarQueryParameter['require_confirmation'] = requireConfirmation;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventCorrectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to fetch a list of events with multiple query parameters
         * @summary Get a list of usage events with multiple query options
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [schemaName] Filter option to filter the events based on schema name.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (nextToken?: string, status?: string, accountId?: string, schemaName?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (schemaName !== undefined) {
                localVarQueryParameter['schema_name'] = schemaName;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch details of a particular event using the event ID.
         * @summary Get an event using event id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleEvent: async (eventId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getSingleEvent', 'eventId', eventId)
            const localVarPath = `/events/{event_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventManagementApi - functional programming interface
 * @export
 */
export const EventManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * #### This API lets you to correct events. Available in both synchronous and asynchronous mode - **Usages**: Reduction of all usages associated with this event - **Revenue**: Reduction of all revenues associated with this event - **Entitlements**: Entitlements(Feature Credits) consumed by this event are granted back to the account.  ### Possible Actions: - UNDO: Undo all usages, revenue and entitlements associated with an event - REDO: Performs UNDO and re-ingests the same event - REDO_EVENT: Performs UNDO and re-ingests the correction payload of the event 
         * @summary Correct an ingested event
         * @param {'UNDO' | 'REDO' | 'REDO_EVENT'} action Action to perform in event correction
         * @param {boolean} [requireConfirmation] Specifies whether to start a migration only after a confirmation
         * @param {EventCorrectionRequest} [eventCorrectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventCorrection(action: 'UNDO' | 'REDO' | 'REDO_EVENT', requireConfirmation?: boolean, eventCorrectionRequest?: EventCorrectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsCorrectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventCorrection(action, requireConfirmation, eventCorrectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to fetch a list of events with multiple query parameters
         * @summary Get a list of usage events with multiple query options
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [schemaName] Filter option to filter the events based on schema name.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(nextToken?: string, status?: string, accountId?: string, schemaName?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(nextToken, status, accountId, schemaName, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch details of a particular event using the event ID.
         * @summary Get an event using event id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleEvent(eventId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleEvent(eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventManagementApi - factory interface
 * @export
 */
export const EventManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventManagementApiFp(configuration)
    return {
        /**
         * #### This API lets you to correct events. Available in both synchronous and asynchronous mode - **Usages**: Reduction of all usages associated with this event - **Revenue**: Reduction of all revenues associated with this event - **Entitlements**: Entitlements(Feature Credits) consumed by this event are granted back to the account.  ### Possible Actions: - UNDO: Undo all usages, revenue and entitlements associated with an event - REDO: Performs UNDO and re-ingests the same event - REDO_EVENT: Performs UNDO and re-ingests the correction payload of the event 
         * @summary Correct an ingested event
         * @param {'UNDO' | 'REDO' | 'REDO_EVENT'} action Action to perform in event correction
         * @param {boolean} [requireConfirmation] Specifies whether to start a migration only after a confirmation
         * @param {EventCorrectionRequest} [eventCorrectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventCorrection(action: 'UNDO' | 'REDO' | 'REDO_EVENT', requireConfirmation?: boolean, eventCorrectionRequest?: EventCorrectionRequest, options?: any): AxiosPromise<EventsCorrectionResponse> {
            return localVarFp.eventCorrection(action, requireConfirmation, eventCorrectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to fetch a list of events with multiple query parameters
         * @summary Get a list of usage events with multiple query options
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [schemaName] Filter option to filter the events based on schema name.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(nextToken?: string, status?: string, accountId?: string, schemaName?: string, pageSize?: number, options?: any): AxiosPromise<GetEventsResponse> {
            return localVarFp.getEvents(nextToken, status, accountId, schemaName, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch details of a particular event using the event ID.
         * @summary Get an event using event id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleEvent(eventId: string, options?: any): AxiosPromise<GetEventResponse> {
            return localVarFp.getSingleEvent(eventId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventManagementApi - object-oriented interface
 * @export
 * @class EventManagementApi
 * @extends {BaseAPI}
 */
export class EventManagementApi extends BaseAPI {
    /**
     * #### This API lets you to correct events. Available in both synchronous and asynchronous mode - **Usages**: Reduction of all usages associated with this event - **Revenue**: Reduction of all revenues associated with this event - **Entitlements**: Entitlements(Feature Credits) consumed by this event are granted back to the account.  ### Possible Actions: - UNDO: Undo all usages, revenue and entitlements associated with an event - REDO: Performs UNDO and re-ingests the same event - REDO_EVENT: Performs UNDO and re-ingests the correction payload of the event 
     * @summary Correct an ingested event
     * @param {'UNDO' | 'REDO' | 'REDO_EVENT'} action Action to perform in event correction
     * @param {boolean} [requireConfirmation] Specifies whether to start a migration only after a confirmation
     * @param {EventCorrectionRequest} [eventCorrectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventManagementApi
     */
    public eventCorrection(action: 'UNDO' | 'REDO' | 'REDO_EVENT', requireConfirmation?: boolean, eventCorrectionRequest?: EventCorrectionRequest, options?: AxiosRequestConfig) {
        return EventManagementApiFp(this.configuration).eventCorrection(action, requireConfirmation, eventCorrectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to fetch a list of events with multiple query parameters
     * @summary Get a list of usage events with multiple query options
     * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
     * @param {string} [status] Filter option to filter by status.
     * @param {string} [accountId] Filter option to filter based on account id.
     * @param {string} [schemaName] Filter option to filter the events based on schema name.
     * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventManagementApi
     */
    public getEvents(nextToken?: string, status?: string, accountId?: string, schemaName?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return EventManagementApiFp(this.configuration).getEvents(nextToken, status, accountId, schemaName, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch details of a particular event using the event ID.
     * @summary Get an event using event id
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventManagementApi
     */
    public getSingleEvent(eventId: string, options?: AxiosRequestConfig) {
        return EventManagementApiFp(this.configuration).getSingleEvent(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventSchemasApi - axios parameter creator
 * @export
 */
export const EventSchemasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate an event schema
         * @summary Activate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateEventSchema: async (eventSchemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('activateEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}/activate`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an event schema with attributes and dimensions to process events.
         * @summary Create an event schema
         * @param {CreateEventSchemaRequest} createEventSchemaRequest Payload to create event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSchema: async (createEventSchemaRequest: CreateEventSchemaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEventSchemaRequest' is not null or undefined
            assertParamExists('createEventSchema', 'createEventSchemaRequest', createEventSchemaRequest)
            const localVarPath = `/event_schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventSchemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can deactivate an event schema using this API. In case you have an activate usage meter associated with the event schema, you will need to deactivate it first and then try deactivating the event schema. 
         * @summary Deactivate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateEventSchema: async (eventSchemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('deactivateEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}/deactivate`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To delete(archive) an event schema, you’re required to archive associated active usage meters if any.
         * @summary Delete an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventSchema: async (eventSchemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('deleteEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an event schema and add new attributes and dimensions  Once an event schema is activated, you cannot update or delete existing attributes and dimensions however you can add new attributes and dimensions and update event schema description.     operationId: updateEventSchema 
         * @summary Update an event schema
         * @param {string} eventSchemaName 
         * @param {UpdateEventSchemaRequest} updateEventSchemaRequest Payload to update event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventSchemaEventSchemaNamePatch: async (eventSchemaName: string, updateEventSchemaRequest: UpdateEventSchemaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('eventSchemaEventSchemaNamePatch', 'eventSchemaName', eventSchemaName)
            // verify required parameter 'updateEventSchemaRequest' is not null or undefined
            assertParamExists('eventSchemaEventSchemaNamePatch', 'updateEventSchemaRequest', updateEventSchemaRequest)
            const localVarPath = `/event_schema/{event_schema_name}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventSchemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an event schema
         * @summary Get an event schema
         * @param {string} eventSchemaName 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSchema: async (eventSchemaName: string, version?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('getEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all the versions of an event schema
         * @summary List all event schema versions
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventSchemaVersions: async (eventSchemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('listEventSchemaVersions', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}/versions`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of event schema with pagination.
         * @summary List event schemas
         * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by provided status
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventSchemas: async (status?: 'ACTIVE' | 'INACTIVE', nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event_schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventSchemasApi - functional programming interface
 * @export
 */
export const EventSchemasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventSchemasApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate an event schema
         * @summary Activate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateEventSchema(eventSchemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateEventSchema(eventSchemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an event schema with attributes and dimensions to process events.
         * @summary Create an event schema
         * @param {CreateEventSchemaRequest} createEventSchemaRequest Payload to create event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventSchema(createEventSchemaRequest: CreateEventSchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventSchema(createEventSchemaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can deactivate an event schema using this API. In case you have an activate usage meter associated with the event schema, you will need to deactivate it first and then try deactivating the event schema. 
         * @summary Deactivate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateEventSchema(eventSchemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateEventSchema(eventSchemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To delete(archive) an event schema, you’re required to archive associated active usage meters if any.
         * @summary Delete an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventSchema(eventSchemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventSchema(eventSchemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an event schema and add new attributes and dimensions  Once an event schema is activated, you cannot update or delete existing attributes and dimensions however you can add new attributes and dimensions and update event schema description.     operationId: updateEventSchema 
         * @summary Update an event schema
         * @param {string} eventSchemaName 
         * @param {UpdateEventSchemaRequest} updateEventSchemaRequest Payload to update event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventSchemaEventSchemaNamePatch(eventSchemaName: string, updateEventSchemaRequest: UpdateEventSchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventSchemaEventSchemaNamePatch(eventSchemaName, updateEventSchemaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an event schema
         * @summary Get an event schema
         * @param {string} eventSchemaName 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventSchema(eventSchemaName: string, version?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventSchema(eventSchemaName, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all the versions of an event schema
         * @summary List all event schema versions
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventSchemaVersions(eventSchemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchemaVersionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventSchemaVersions(eventSchemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of event schema with pagination.
         * @summary List event schemas
         * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by provided status
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventSchemas(status?: 'ACTIVE' | 'INACTIVE', nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchemaListPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventSchemas(status, nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventSchemasApi - factory interface
 * @export
 */
export const EventSchemasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventSchemasApiFp(configuration)
    return {
        /**
         * Activate an event schema
         * @summary Activate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateEventSchema(eventSchemaName: string, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.activateEventSchema(eventSchemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an event schema with attributes and dimensions to process events.
         * @summary Create an event schema
         * @param {CreateEventSchemaRequest} createEventSchemaRequest Payload to create event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSchema(createEventSchemaRequest: CreateEventSchemaRequest, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.createEventSchema(createEventSchemaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * You can deactivate an event schema using this API. In case you have an activate usage meter associated with the event schema, you will need to deactivate it first and then try deactivating the event schema. 
         * @summary Deactivate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateEventSchema(eventSchemaName: string, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.deactivateEventSchema(eventSchemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * To delete(archive) an event schema, you’re required to archive associated active usage meters if any.
         * @summary Delete an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventSchema(eventSchemaName: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteEventSchema(eventSchemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an event schema and add new attributes and dimensions  Once an event schema is activated, you cannot update or delete existing attributes and dimensions however you can add new attributes and dimensions and update event schema description.     operationId: updateEventSchema 
         * @summary Update an event schema
         * @param {string} eventSchemaName 
         * @param {UpdateEventSchemaRequest} updateEventSchemaRequest Payload to update event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventSchemaEventSchemaNamePatch(eventSchemaName: string, updateEventSchemaRequest: UpdateEventSchemaRequest, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.eventSchemaEventSchemaNamePatch(eventSchemaName, updateEventSchemaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an event schema
         * @summary Get an event schema
         * @param {string} eventSchemaName 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSchema(eventSchemaName: string, version?: number, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.getEventSchema(eventSchemaName, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all the versions of an event schema
         * @summary List all event schema versions
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventSchemaVersions(eventSchemaName: string, options?: any): AxiosPromise<EventSchemaVersionsResponse> {
            return localVarFp.listEventSchemaVersions(eventSchemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of event schema with pagination.
         * @summary List event schemas
         * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by provided status
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventSchemas(status?: 'ACTIVE' | 'INACTIVE', nextToken?: string, pageSize?: number, options?: any): AxiosPromise<EventSchemaListPaginatedResponse> {
            return localVarFp.listEventSchemas(status, nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventSchemasApi - object-oriented interface
 * @export
 * @class EventSchemasApi
 * @extends {BaseAPI}
 */
export class EventSchemasApi extends BaseAPI {
    /**
     * Activate an event schema
     * @summary Activate an event schema
     * @param {string} eventSchemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public activateEventSchema(eventSchemaName: string, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).activateEventSchema(eventSchemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an event schema with attributes and dimensions to process events.
     * @summary Create an event schema
     * @param {CreateEventSchemaRequest} createEventSchemaRequest Payload to create event schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public createEventSchema(createEventSchemaRequest: CreateEventSchemaRequest, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).createEventSchema(createEventSchemaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can deactivate an event schema using this API. In case you have an activate usage meter associated with the event schema, you will need to deactivate it first and then try deactivating the event schema. 
     * @summary Deactivate an event schema
     * @param {string} eventSchemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public deactivateEventSchema(eventSchemaName: string, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).deactivateEventSchema(eventSchemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To delete(archive) an event schema, you’re required to archive associated active usage meters if any.
     * @summary Delete an event schema
     * @param {string} eventSchemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public deleteEventSchema(eventSchemaName: string, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).deleteEventSchema(eventSchemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an event schema and add new attributes and dimensions  Once an event schema is activated, you cannot update or delete existing attributes and dimensions however you can add new attributes and dimensions and update event schema description.     operationId: updateEventSchema 
     * @summary Update an event schema
     * @param {string} eventSchemaName 
     * @param {UpdateEventSchemaRequest} updateEventSchemaRequest Payload to update event schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public eventSchemaEventSchemaNamePatch(eventSchemaName: string, updateEventSchemaRequest: UpdateEventSchemaRequest, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).eventSchemaEventSchemaNamePatch(eventSchemaName, updateEventSchemaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an event schema
     * @summary Get an event schema
     * @param {string} eventSchemaName 
     * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public getEventSchema(eventSchemaName: string, version?: number, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).getEventSchema(eventSchemaName, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all the versions of an event schema
     * @summary List all event schema versions
     * @param {string} eventSchemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public listEventSchemaVersions(eventSchemaName: string, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).listEventSchemaVersions(eventSchemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of event schema with pagination.
     * @summary List event schemas
     * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by provided status
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public listEventSchemas(status?: 'ACTIVE' | 'INACTIVE', nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).listEventSchemas(status, nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FeatureApi - axios parameter creator
 * @export
 */
export const FeatureApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Feature optionally associate with one or more event_schemas
         * @summary Create a Feature and optionally associate with one or more event_schemas
         * @param {CreateFeatureRequest} createFeatureRequest Payload to create a Feature along the association with event_schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeature: async (createFeatureRequest: CreateFeatureRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFeatureRequest' is not null or undefined
            assertParamExists('createFeature', 'createFeatureRequest', createFeatureRequest)
            const localVarPath = `/features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFeatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a Feature
         * @summary Get a Feature
         * @param {string} featureId feature_id corresponding to a feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeature: async (featureId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('getFeature', 'featureId', featureId)
            const localVarPath = `/features/{feature_id}`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of features along with its associations
         * @summary List Feature
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatures: async (nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing feature and its eventSchema associations 
         * @summary Update a Feature
         * @param {string} featureId feature_id corresponding to a feature
         * @param {UpdateFeatureRequest} updateFeatureRequest Payload to update a Feature along the associations with event_schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeature: async (featureId: string, updateFeatureRequest: UpdateFeatureRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('updateFeature', 'featureId', featureId)
            // verify required parameter 'updateFeatureRequest' is not null or undefined
            assertParamExists('updateFeature', 'updateFeatureRequest', updateFeatureRequest)
            const localVarPath = `/features/{feature_id}`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFeatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeatureApi - functional programming interface
 * @export
 */
export const FeatureApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeatureApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a Feature optionally associate with one or more event_schemas
         * @summary Create a Feature and optionally associate with one or more event_schemas
         * @param {CreateFeatureRequest} createFeatureRequest Payload to create a Feature along the association with event_schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeature(createFeatureRequest: CreateFeatureRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Feature>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFeature(createFeatureRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a Feature
         * @summary Get a Feature
         * @param {string} featureId feature_id corresponding to a feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeature(featureId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Feature>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeature(featureId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of features along with its associations
         * @summary List Feature
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatures(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeaturePaginatedListData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatures(nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing feature and its eventSchema associations 
         * @summary Update a Feature
         * @param {string} featureId feature_id corresponding to a feature
         * @param {UpdateFeatureRequest} updateFeatureRequest Payload to update a Feature along the associations with event_schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeature(featureId: string, updateFeatureRequest: UpdateFeatureRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Feature>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeature(featureId, updateFeatureRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FeatureApi - factory interface
 * @export
 */
export const FeatureApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeatureApiFp(configuration)
    return {
        /**
         * Create a Feature optionally associate with one or more event_schemas
         * @summary Create a Feature and optionally associate with one or more event_schemas
         * @param {CreateFeatureRequest} createFeatureRequest Payload to create a Feature along the association with event_schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeature(createFeatureRequest: CreateFeatureRequest, options?: any): AxiosPromise<Feature> {
            return localVarFp.createFeature(createFeatureRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a Feature
         * @summary Get a Feature
         * @param {string} featureId feature_id corresponding to a feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeature(featureId: string, options?: any): AxiosPromise<Feature> {
            return localVarFp.getFeature(featureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of features along with its associations
         * @summary List Feature
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatures(nextToken?: string, pageSize?: number, options?: any): AxiosPromise<FeaturePaginatedListData> {
            return localVarFp.getFeatures(nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing feature and its eventSchema associations 
         * @summary Update a Feature
         * @param {string} featureId feature_id corresponding to a feature
         * @param {UpdateFeatureRequest} updateFeatureRequest Payload to update a Feature along the associations with event_schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeature(featureId: string, updateFeatureRequest: UpdateFeatureRequest, options?: any): AxiosPromise<Feature> {
            return localVarFp.updateFeature(featureId, updateFeatureRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeatureApi - object-oriented interface
 * @export
 * @class FeatureApi
 * @extends {BaseAPI}
 */
export class FeatureApi extends BaseAPI {
    /**
     * Create a Feature optionally associate with one or more event_schemas
     * @summary Create a Feature and optionally associate with one or more event_schemas
     * @param {CreateFeatureRequest} createFeatureRequest Payload to create a Feature along the association with event_schemas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public createFeature(createFeatureRequest: CreateFeatureRequest, options?: AxiosRequestConfig) {
        return FeatureApiFp(this.configuration).createFeature(createFeatureRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a Feature
     * @summary Get a Feature
     * @param {string} featureId feature_id corresponding to a feature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public getFeature(featureId: string, options?: AxiosRequestConfig) {
        return FeatureApiFp(this.configuration).getFeature(featureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of features along with its associations
     * @summary List Feature
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public getFeatures(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return FeatureApiFp(this.configuration).getFeatures(nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing feature and its eventSchema associations 
     * @summary Update a Feature
     * @param {string} featureId feature_id corresponding to a feature
     * @param {UpdateFeatureRequest} updateFeatureRequest Payload to update a Feature along the associations with event_schemas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public updateFeature(featureId: string, updateFeatureRequest: UpdateFeatureRequest, options?: AxiosRequestConfig) {
        return FeatureApiFp(this.configuration).updateFeature(featureId, updateFeatureRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FileStorageApi - axios parameter creator
 * @export
 */
export const FileStorageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a download url for a file
         * @summary Get a download url for a file
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadUrl: async (fileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getDownloadUrl', 'fileId', fileId)
            const localVarPath = `/files/{file_id}/download_url`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a file
         * @summary Get a file
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (fileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFile', 'fileId', fileId)
            const localVarPath = `/files/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileStorageApi - functional programming interface
 * @export
 */
export const FileStorageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileStorageApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a download url for a file
         * @summary Get a download url for a file
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDownloadUrl(fileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileDownloadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDownloadUrl(fileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a file
         * @summary Get a file
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(fileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(fileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FileStorageApi - factory interface
 * @export
 */
export const FileStorageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileStorageApiFp(configuration)
    return {
        /**
         * Get a download url for a file
         * @summary Get a download url for a file
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadUrl(fileId: string, options?: any): AxiosPromise<FileDownloadUrlResponse> {
            return localVarFp.getDownloadUrl(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a file
         * @summary Get a file
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(fileId: string, options?: any): AxiosPromise<ErrorResponse> {
            return localVarFp.getFile(fileId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileStorageApi - object-oriented interface
 * @export
 * @class FileStorageApi
 * @extends {BaseAPI}
 */
export class FileStorageApi extends BaseAPI {
    /**
     * Get a download url for a file
     * @summary Get a download url for a file
     * @param {string} fileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileStorageApi
     */
    public getDownloadUrl(fileId: string, options?: AxiosRequestConfig) {
        return FileStorageApiFp(this.configuration).getDownloadUrl(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a file
     * @summary Get a file
     * @param {string} fileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileStorageApi
     */
    public getFile(fileId: string, options?: AxiosRequestConfig) {
        return FileStorageApiFp(this.configuration).getFile(fileId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvoiceGroupsApi - axios parameter creator
 * @export
 */
export const InvoiceGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API let’s you to add accounts to an invoice group
         * @summary Add accounts to an invoice group
         * @param {string} invoiceGroupId 
         * @param {UpdateInvoiceGroupAccounts} updateInvoiceGroupAccounts Payload to add or remove accounts to/from an invoice group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addInvoiceGroupAccounts: async (invoiceGroupId: string, updateInvoiceGroupAccounts: UpdateInvoiceGroupAccounts, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceGroupId' is not null or undefined
            assertParamExists('addInvoiceGroupAccounts', 'invoiceGroupId', invoiceGroupId)
            // verify required parameter 'updateInvoiceGroupAccounts' is not null or undefined
            assertParamExists('addInvoiceGroupAccounts', 'updateInvoiceGroupAccounts', updateInvoiceGroupAccounts)
            const localVarPath = `/invoice_groups/{invoice_group_id}/add_accounts`
                .replace(`{${"invoice_group_id"}}`, encodeURIComponent(String(invoiceGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateInvoiceGroupAccounts, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to create an invoice group
         * @summary Create an invoice group
         * @param {CreateInvoiceGroupRequest} createInvoiceGroupRequest Payload to approve or decline a proposal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceGroup: async (createInvoiceGroupRequest: CreateInvoiceGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createInvoiceGroupRequest' is not null or undefined
            assertParamExists('createInvoiceGroup', 'createInvoiceGroupRequest', createInvoiceGroupRequest)
            const localVarPath = `/invoice_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createInvoiceGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to get information of an invoice group
         * @summary Get information of an invoice group
         * @param {string} invoiceGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceGroup: async (invoiceGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceGroupId' is not null or undefined
            assertParamExists('getInvoiceGroup', 'invoiceGroupId', invoiceGroupId)
            const localVarPath = `/invoice_groups/{invoice_group_id}`
                .replace(`{${"invoice_group_id"}}`, encodeURIComponent(String(invoiceGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to list invoice groups
         * @summary List Invoice Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvoiceGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoice_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to remove accounts from an invoice group. Removing all accounts will also delete the invoice group
         * @summary Remove accounts from an invoice group. Removing all accounts will also delete the invoice group
         * @param {string} invoiceGroupId 
         * @param {UpdateInvoiceGroupAccounts} updateInvoiceGroupAccounts Payload to add or remove accounts to/from an invoice group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeInvoiceGroupAccounts: async (invoiceGroupId: string, updateInvoiceGroupAccounts: UpdateInvoiceGroupAccounts, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceGroupId' is not null or undefined
            assertParamExists('removeInvoiceGroupAccounts', 'invoiceGroupId', invoiceGroupId)
            // verify required parameter 'updateInvoiceGroupAccounts' is not null or undefined
            assertParamExists('removeInvoiceGroupAccounts', 'updateInvoiceGroupAccounts', updateInvoiceGroupAccounts)
            const localVarPath = `/invoice_groups/{invoice_group_id}/remove_accounts`
                .replace(`{${"invoice_group_id"}}`, encodeURIComponent(String(invoiceGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateInvoiceGroupAccounts, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoiceGroupsApi - functional programming interface
 * @export
 */
export const InvoiceGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoiceGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API let’s you to add accounts to an invoice group
         * @summary Add accounts to an invoice group
         * @param {string} invoiceGroupId 
         * @param {UpdateInvoiceGroupAccounts} updateInvoiceGroupAccounts Payload to add or remove accounts to/from an invoice group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addInvoiceGroupAccounts(invoiceGroupId: string, updateInvoiceGroupAccounts: UpdateInvoiceGroupAccounts, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceGroups>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addInvoiceGroupAccounts(invoiceGroupId, updateInvoiceGroupAccounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to create an invoice group
         * @summary Create an invoice group
         * @param {CreateInvoiceGroupRequest} createInvoiceGroupRequest Payload to approve or decline a proposal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoiceGroup(createInvoiceGroupRequest: CreateInvoiceGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceGroups>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvoiceGroup(createInvoiceGroupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to get information of an invoice group
         * @summary Get information of an invoice group
         * @param {string} invoiceGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceGroup(invoiceGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceGroupAccountsPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceGroup(invoiceGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to list invoice groups
         * @summary List Invoice Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInvoiceGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceGroupPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInvoiceGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to remove accounts from an invoice group. Removing all accounts will also delete the invoice group
         * @summary Remove accounts from an invoice group. Removing all accounts will also delete the invoice group
         * @param {string} invoiceGroupId 
         * @param {UpdateInvoiceGroupAccounts} updateInvoiceGroupAccounts Payload to add or remove accounts to/from an invoice group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeInvoiceGroupAccounts(invoiceGroupId: string, updateInvoiceGroupAccounts: UpdateInvoiceGroupAccounts, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeInvoiceGroupAccounts(invoiceGroupId, updateInvoiceGroupAccounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvoiceGroupsApi - factory interface
 * @export
 */
export const InvoiceGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoiceGroupsApiFp(configuration)
    return {
        /**
         * This API let’s you to add accounts to an invoice group
         * @summary Add accounts to an invoice group
         * @param {string} invoiceGroupId 
         * @param {UpdateInvoiceGroupAccounts} updateInvoiceGroupAccounts Payload to add or remove accounts to/from an invoice group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addInvoiceGroupAccounts(invoiceGroupId: string, updateInvoiceGroupAccounts: UpdateInvoiceGroupAccounts, options?: any): AxiosPromise<InvoiceGroups> {
            return localVarFp.addInvoiceGroupAccounts(invoiceGroupId, updateInvoiceGroupAccounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to create an invoice group
         * @summary Create an invoice group
         * @param {CreateInvoiceGroupRequest} createInvoiceGroupRequest Payload to approve or decline a proposal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceGroup(createInvoiceGroupRequest: CreateInvoiceGroupRequest, options?: any): AxiosPromise<InvoiceGroups> {
            return localVarFp.createInvoiceGroup(createInvoiceGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to get information of an invoice group
         * @summary Get information of an invoice group
         * @param {string} invoiceGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceGroup(invoiceGroupId: string, options?: any): AxiosPromise<InvoiceGroupAccountsPaginatedResponse> {
            return localVarFp.getInvoiceGroup(invoiceGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to list invoice groups
         * @summary List Invoice Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvoiceGroups(options?: any): AxiosPromise<InvoiceGroupPaginatedResponse> {
            return localVarFp.listInvoiceGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to remove accounts from an invoice group. Removing all accounts will also delete the invoice group
         * @summary Remove accounts from an invoice group. Removing all accounts will also delete the invoice group
         * @param {string} invoiceGroupId 
         * @param {UpdateInvoiceGroupAccounts} updateInvoiceGroupAccounts Payload to add or remove accounts to/from an invoice group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeInvoiceGroupAccounts(invoiceGroupId: string, updateInvoiceGroupAccounts: UpdateInvoiceGroupAccounts, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.removeInvoiceGroupAccounts(invoiceGroupId, updateInvoiceGroupAccounts, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoiceGroupsApi - object-oriented interface
 * @export
 * @class InvoiceGroupsApi
 * @extends {BaseAPI}
 */
export class InvoiceGroupsApi extends BaseAPI {
    /**
     * This API let’s you to add accounts to an invoice group
     * @summary Add accounts to an invoice group
     * @param {string} invoiceGroupId 
     * @param {UpdateInvoiceGroupAccounts} updateInvoiceGroupAccounts Payload to add or remove accounts to/from an invoice group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceGroupsApi
     */
    public addInvoiceGroupAccounts(invoiceGroupId: string, updateInvoiceGroupAccounts: UpdateInvoiceGroupAccounts, options?: AxiosRequestConfig) {
        return InvoiceGroupsApiFp(this.configuration).addInvoiceGroupAccounts(invoiceGroupId, updateInvoiceGroupAccounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to create an invoice group
     * @summary Create an invoice group
     * @param {CreateInvoiceGroupRequest} createInvoiceGroupRequest Payload to approve or decline a proposal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceGroupsApi
     */
    public createInvoiceGroup(createInvoiceGroupRequest: CreateInvoiceGroupRequest, options?: AxiosRequestConfig) {
        return InvoiceGroupsApiFp(this.configuration).createInvoiceGroup(createInvoiceGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to get information of an invoice group
     * @summary Get information of an invoice group
     * @param {string} invoiceGroupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceGroupsApi
     */
    public getInvoiceGroup(invoiceGroupId: string, options?: AxiosRequestConfig) {
        return InvoiceGroupsApiFp(this.configuration).getInvoiceGroup(invoiceGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to list invoice groups
     * @summary List Invoice Groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceGroupsApi
     */
    public listInvoiceGroups(options?: AxiosRequestConfig) {
        return InvoiceGroupsApiFp(this.configuration).listInvoiceGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to remove accounts from an invoice group. Removing all accounts will also delete the invoice group
     * @summary Remove accounts from an invoice group. Removing all accounts will also delete the invoice group
     * @param {string} invoiceGroupId 
     * @param {UpdateInvoiceGroupAccounts} updateInvoiceGroupAccounts Payload to add or remove accounts to/from an invoice group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceGroupsApi
     */
    public removeInvoiceGroupAccounts(invoiceGroupId: string, updateInvoiceGroupAccounts: UpdateInvoiceGroupAccounts, options?: AxiosRequestConfig) {
        return InvoiceGroupsApiFp(this.configuration).removeInvoiceGroupAccounts(invoiceGroupId, updateInvoiceGroupAccounts, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvoicesApi - axios parameter creator
 * @export
 */
export const InvoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a custom invoice for an account.
         * @summary Create a custom invoice for an account
         * @param {CreateCustomInvoiceRequest} [createCustomInvoiceRequest] Payload to create invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomInvoice: async (createCustomInvoiceRequest?: CreateCustomInvoiceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomInvoiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a bill run job request
         * @summary Create a bill run job request
         * @param {boolean} [requireConfirmation] Specifies whether to start a migration only after a confirmation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceBillRun: async (requireConfirmation?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices/bill_runs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (requireConfirmation !== undefined) {
                localVarQueryParameter['require_confirmation'] = requireConfirmation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a custom invoice in DRAFT state.
         * @summary Delete a custom invoice in DRAFT state
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomInvoice: async (invoiceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('deleteCustomInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/invoices/{invoice_id}`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get invoice
         * @summary Get an invoice
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice: async (invoiceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('getInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/invoices/{invoice_id}`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List invoices
         * @summary List invoices
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [ownerId] Filter option to filter based on owner id.
         * @param {string} [customerId] Filter option to filter based on customer id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {number} [startTime] Start time filter in epoch milli seconds
         * @param {number} [endTime] End time filter in epoch milli seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvoices: async (nextToken?: string, status?: string, ownerId?: string, customerId?: string, pageSize?: number, startTime?: number, endTime?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (ownerId !== undefined) {
                localVarQueryParameter['owner_id'] = ownerId;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customer_id'] = customerId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List invoices eligible for bill run
         * @summary List invoices eligible for bill run
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [ownerId] Filter option to filter based on owner id.
         * @param {string} [customerId] Filter option to filter based on customer id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {number} [startTime] Start time filter in epoch milli seconds
         * @param {number} [endTime] End time filter in epoch milli seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvoicesForBillRun: async (nextToken?: string, status?: string, ownerId?: string, customerId?: string, pageSize?: number, startTime?: number, endTime?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices/bill_runs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (ownerId !== undefined) {
                localVarQueryParameter['owner_id'] = ownerId;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customer_id'] = customerId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List pricing rule logs
         * @summary List pricing rule logs
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPricingRuleLogs: async (invoiceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('listPricingRuleLogs', 'invoiceId', invoiceId)
            const localVarPath = `/invoice/{invoice_id}/pricing_rules_logs`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add or update miscellaneous charges in upcoming Invoice for a account
         * @summary Add or update miscellaneous charges in upcoming Invoice for a account
         * @param {string} accountId account_id corresponding to an account
         * @param {ManageMiscellaneousChargesRequest} [manageMiscellaneousChargesRequest] Payload to update custom line items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageMiscellaneousChargesInAccount: async (accountId: string, manageMiscellaneousChargesRequest?: ManageMiscellaneousChargesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('manageMiscellaneousChargesInAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/miscellaneous_charges`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manageMiscellaneousChargesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add or update miscellaneous charges in Invoice
         * @summary Add or update miscellaneous charges in Invoice
         * @param {string} invoiceId 
         * @param {ManageMiscellaneousChargesRequest} [manageMiscellaneousChargesRequest] Payload to update custom line items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageMiscellaneousChargesInInvoice: async (invoiceId: string, manageMiscellaneousChargesRequest?: ManageMiscellaneousChargesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('manageMiscellaneousChargesInInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/invoices/{invoice_id}/miscellaneous_charges`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manageMiscellaneousChargesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an invoice[Only CUSTOM invoices in DRAFT state support updating of all fields]. Updating status can be done for all invoice.
         * @summary Update an invoice
         * @param {string} invoiceId 
         * @param {UpdateInvoiceRequest} [updateInvoiceRequest] Payload to update an invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice: async (invoiceId: string, updateInvoiceRequest?: UpdateInvoiceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('updateInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/invoices/{invoice_id}`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateInvoiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicesApi - functional programming interface
 * @export
 */
export const InvoicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoicesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a custom invoice for an account.
         * @summary Create a custom invoice for an account
         * @param {CreateCustomInvoiceRequest} [createCustomInvoiceRequest] Payload to create invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomInvoice(createCustomInvoiceRequest?: CreateCustomInvoiceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomInvoice(createCustomInvoiceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a bill run job request
         * @summary Create a bill run job request
         * @param {boolean} [requireConfirmation] Specifies whether to start a migration only after a confirmation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoiceBillRun(requireConfirmation?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvoiceBillRun(requireConfirmation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a custom invoice in DRAFT state.
         * @summary Delete a custom invoice in DRAFT state
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomInvoice(invoiceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomInvoice(invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get invoice
         * @summary Get an invoice
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoice(invoiceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoice(invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List invoices
         * @summary List invoices
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [ownerId] Filter option to filter based on owner id.
         * @param {string} [customerId] Filter option to filter based on customer id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {number} [startTime] Start time filter in epoch milli seconds
         * @param {number} [endTime] End time filter in epoch milli seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInvoices(nextToken?: string, status?: string, ownerId?: string, customerId?: string, pageSize?: number, startTime?: number, endTime?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListInvoicesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInvoices(nextToken, status, ownerId, customerId, pageSize, startTime, endTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List invoices eligible for bill run
         * @summary List invoices eligible for bill run
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [ownerId] Filter option to filter based on owner id.
         * @param {string} [customerId] Filter option to filter based on customer id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {number} [startTime] Start time filter in epoch milli seconds
         * @param {number} [endTime] End time filter in epoch milli seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInvoicesForBillRun(nextToken?: string, status?: string, ownerId?: string, customerId?: string, pageSize?: number, startTime?: number, endTime?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListInvoicesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInvoicesForBillRun(nextToken, status, ownerId, customerId, pageSize, startTime, endTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List pricing rule logs
         * @summary List pricing rule logs
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPricingRuleLogs(invoiceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricingRulesLogsPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPricingRuleLogs(invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add or update miscellaneous charges in upcoming Invoice for a account
         * @summary Add or update miscellaneous charges in upcoming Invoice for a account
         * @param {string} accountId account_id corresponding to an account
         * @param {ManageMiscellaneousChargesRequest} [manageMiscellaneousChargesRequest] Payload to update custom line items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async manageMiscellaneousChargesInAccount(accountId: string, manageMiscellaneousChargesRequest?: ManageMiscellaneousChargesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiscellaneousChargesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.manageMiscellaneousChargesInAccount(accountId, manageMiscellaneousChargesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add or update miscellaneous charges in Invoice
         * @summary Add or update miscellaneous charges in Invoice
         * @param {string} invoiceId 
         * @param {ManageMiscellaneousChargesRequest} [manageMiscellaneousChargesRequest] Payload to update custom line items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async manageMiscellaneousChargesInInvoice(invoiceId: string, manageMiscellaneousChargesRequest?: ManageMiscellaneousChargesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiscellaneousChargesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.manageMiscellaneousChargesInInvoice(invoiceId, manageMiscellaneousChargesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an invoice[Only CUSTOM invoices in DRAFT state support updating of all fields]. Updating status can be done for all invoice.
         * @summary Update an invoice
         * @param {string} invoiceId 
         * @param {UpdateInvoiceRequest} [updateInvoiceRequest] Payload to update an invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInvoice(invoiceId: string, updateInvoiceRequest?: UpdateInvoiceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInvoice(invoiceId, updateInvoiceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvoicesApi - factory interface
 * @export
 */
export const InvoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoicesApiFp(configuration)
    return {
        /**
         * Create a custom invoice for an account.
         * @summary Create a custom invoice for an account
         * @param {CreateCustomInvoiceRequest} [createCustomInvoiceRequest] Payload to create invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomInvoice(createCustomInvoiceRequest?: CreateCustomInvoiceRequest, options?: any): AxiosPromise<Invoice> {
            return localVarFp.createCustomInvoice(createCustomInvoiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a bill run job request
         * @summary Create a bill run job request
         * @param {boolean} [requireConfirmation] Specifies whether to start a migration only after a confirmation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceBillRun(requireConfirmation?: boolean, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.createInvoiceBillRun(requireConfirmation, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a custom invoice in DRAFT state.
         * @summary Delete a custom invoice in DRAFT state
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomInvoice(invoiceId: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteCustomInvoice(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get invoice
         * @summary Get an invoice
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice(invoiceId: string, options?: any): AxiosPromise<Invoice> {
            return localVarFp.getInvoice(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List invoices
         * @summary List invoices
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [ownerId] Filter option to filter based on owner id.
         * @param {string} [customerId] Filter option to filter based on customer id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {number} [startTime] Start time filter in epoch milli seconds
         * @param {number} [endTime] End time filter in epoch milli seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvoices(nextToken?: string, status?: string, ownerId?: string, customerId?: string, pageSize?: number, startTime?: number, endTime?: number, options?: any): AxiosPromise<ListInvoicesResponse> {
            return localVarFp.listInvoices(nextToken, status, ownerId, customerId, pageSize, startTime, endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * List invoices eligible for bill run
         * @summary List invoices eligible for bill run
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [ownerId] Filter option to filter based on owner id.
         * @param {string} [customerId] Filter option to filter based on customer id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {number} [startTime] Start time filter in epoch milli seconds
         * @param {number} [endTime] End time filter in epoch milli seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvoicesForBillRun(nextToken?: string, status?: string, ownerId?: string, customerId?: string, pageSize?: number, startTime?: number, endTime?: number, options?: any): AxiosPromise<ListInvoicesResponse> {
            return localVarFp.listInvoicesForBillRun(nextToken, status, ownerId, customerId, pageSize, startTime, endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * List pricing rule logs
         * @summary List pricing rule logs
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPricingRuleLogs(invoiceId: string, options?: any): AxiosPromise<PricingRulesLogsPaginatedResponse> {
            return localVarFp.listPricingRuleLogs(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add or update miscellaneous charges in upcoming Invoice for a account
         * @summary Add or update miscellaneous charges in upcoming Invoice for a account
         * @param {string} accountId account_id corresponding to an account
         * @param {ManageMiscellaneousChargesRequest} [manageMiscellaneousChargesRequest] Payload to update custom line items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageMiscellaneousChargesInAccount(accountId: string, manageMiscellaneousChargesRequest?: ManageMiscellaneousChargesRequest, options?: any): AxiosPromise<MiscellaneousChargesResponse> {
            return localVarFp.manageMiscellaneousChargesInAccount(accountId, manageMiscellaneousChargesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add or update miscellaneous charges in Invoice
         * @summary Add or update miscellaneous charges in Invoice
         * @param {string} invoiceId 
         * @param {ManageMiscellaneousChargesRequest} [manageMiscellaneousChargesRequest] Payload to update custom line items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageMiscellaneousChargesInInvoice(invoiceId: string, manageMiscellaneousChargesRequest?: ManageMiscellaneousChargesRequest, options?: any): AxiosPromise<MiscellaneousChargesResponse> {
            return localVarFp.manageMiscellaneousChargesInInvoice(invoiceId, manageMiscellaneousChargesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an invoice[Only CUSTOM invoices in DRAFT state support updating of all fields]. Updating status can be done for all invoice.
         * @summary Update an invoice
         * @param {string} invoiceId 
         * @param {UpdateInvoiceRequest} [updateInvoiceRequest] Payload to update an invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice(invoiceId: string, updateInvoiceRequest?: UpdateInvoiceRequest, options?: any): AxiosPromise<Invoice> {
            return localVarFp.updateInvoice(invoiceId, updateInvoiceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
export class InvoicesApi extends BaseAPI {
    /**
     * Create a custom invoice for an account.
     * @summary Create a custom invoice for an account
     * @param {CreateCustomInvoiceRequest} [createCustomInvoiceRequest] Payload to create invoice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public createCustomInvoice(createCustomInvoiceRequest?: CreateCustomInvoiceRequest, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).createCustomInvoice(createCustomInvoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a bill run job request
     * @summary Create a bill run job request
     * @param {boolean} [requireConfirmation] Specifies whether to start a migration only after a confirmation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public createInvoiceBillRun(requireConfirmation?: boolean, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).createInvoiceBillRun(requireConfirmation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a custom invoice in DRAFT state.
     * @summary Delete a custom invoice in DRAFT state
     * @param {string} invoiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public deleteCustomInvoice(invoiceId: string, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).deleteCustomInvoice(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get invoice
     * @summary Get an invoice
     * @param {string} invoiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public getInvoice(invoiceId: string, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).getInvoice(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List invoices
     * @summary List invoices
     * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
     * @param {string} [status] Filter option to filter by status.
     * @param {string} [ownerId] Filter option to filter based on owner id.
     * @param {string} [customerId] Filter option to filter based on customer id.
     * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
     * @param {number} [startTime] Start time filter in epoch milli seconds
     * @param {number} [endTime] End time filter in epoch milli seconds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public listInvoices(nextToken?: string, status?: string, ownerId?: string, customerId?: string, pageSize?: number, startTime?: number, endTime?: number, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).listInvoices(nextToken, status, ownerId, customerId, pageSize, startTime, endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List invoices eligible for bill run
     * @summary List invoices eligible for bill run
     * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
     * @param {string} [status] Filter option to filter by status.
     * @param {string} [ownerId] Filter option to filter based on owner id.
     * @param {string} [customerId] Filter option to filter based on customer id.
     * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
     * @param {number} [startTime] Start time filter in epoch milli seconds
     * @param {number} [endTime] End time filter in epoch milli seconds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public listInvoicesForBillRun(nextToken?: string, status?: string, ownerId?: string, customerId?: string, pageSize?: number, startTime?: number, endTime?: number, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).listInvoicesForBillRun(nextToken, status, ownerId, customerId, pageSize, startTime, endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List pricing rule logs
     * @summary List pricing rule logs
     * @param {string} invoiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public listPricingRuleLogs(invoiceId: string, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).listPricingRuleLogs(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add or update miscellaneous charges in upcoming Invoice for a account
     * @summary Add or update miscellaneous charges in upcoming Invoice for a account
     * @param {string} accountId account_id corresponding to an account
     * @param {ManageMiscellaneousChargesRequest} [manageMiscellaneousChargesRequest] Payload to update custom line items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public manageMiscellaneousChargesInAccount(accountId: string, manageMiscellaneousChargesRequest?: ManageMiscellaneousChargesRequest, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).manageMiscellaneousChargesInAccount(accountId, manageMiscellaneousChargesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add or update miscellaneous charges in Invoice
     * @summary Add or update miscellaneous charges in Invoice
     * @param {string} invoiceId 
     * @param {ManageMiscellaneousChargesRequest} [manageMiscellaneousChargesRequest] Payload to update custom line items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public manageMiscellaneousChargesInInvoice(invoiceId: string, manageMiscellaneousChargesRequest?: ManageMiscellaneousChargesRequest, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).manageMiscellaneousChargesInInvoice(invoiceId, manageMiscellaneousChargesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an invoice[Only CUSTOM invoices in DRAFT state support updating of all fields]. Updating status can be done for all invoice.
     * @summary Update an invoice
     * @param {string} invoiceId 
     * @param {UpdateInvoiceRequest} [updateInvoiceRequest] Payload to update an invoice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public updateInvoice(invoiceId: string, updateInvoiceRequest?: UpdateInvoiceRequest, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).updateInvoice(invoiceId, updateInvoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JobsApi - axios parameter creator
 * @export
 */
export const JobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Confirm a job
         * @summary Confirm a job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmJob: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('confirmJob', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}/confirm`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List individual job entries and current state of processing
         * @summary List job entries
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobEntries: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobEntries', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}/entries`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status of a job
         * @summary Get the status of a job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobStatus: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobStatus', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of jobs with pagination and sort.
         * @summary List jobs
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobs: async (nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reject a job
         * @summary Reject a job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectJob: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('rejectJob', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}/reject`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration)
    return {
        /**
         * Confirm a job
         * @summary Confirm a job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmJob(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmJob(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List individual job entries and current state of processing
         * @summary List job entries
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobEntries(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobEntriesPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobEntries(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the status of a job
         * @summary Get the status of a job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobStatus(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobStatus(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of jobs with pagination and sort.
         * @summary List jobs
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobs(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobsPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobs(nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reject a job
         * @summary Reject a job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectJob(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectJob(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobsApiFp(configuration)
    return {
        /**
         * Confirm a job
         * @summary Confirm a job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmJob(jobId: string, options?: any): AxiosPromise<GetJobResponse> {
            return localVarFp.confirmJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * List individual job entries and current state of processing
         * @summary List job entries
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobEntries(jobId: string, options?: any): AxiosPromise<JobEntriesPaginatedResponse> {
            return localVarFp.getJobEntries(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status of a job
         * @summary Get the status of a job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobStatus(jobId: string, options?: any): AxiosPromise<GetJobResponse> {
            return localVarFp.getJobStatus(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of jobs with pagination and sort.
         * @summary List jobs
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobs(nextToken?: string, pageSize?: number, options?: any): AxiosPromise<JobsPaginatedResponse> {
            return localVarFp.getJobs(nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Reject a job
         * @summary Reject a job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectJob(jobId: string, options?: any): AxiosPromise<GetJobResponse> {
            return localVarFp.rejectJob(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
    /**
     * Confirm a job
     * @summary Confirm a job
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public confirmJob(jobId: string, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).confirmJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List individual job entries and current state of processing
     * @summary List job entries
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobEntries(jobId: string, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).getJobEntries(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the status of a job
     * @summary Get the status of a job
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobStatus(jobId: string, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).getJobStatus(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of jobs with pagination and sort.
     * @summary List jobs
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobs(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).getJobs(nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reject a job
     * @summary Reject a job
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public rejectJob(jobId: string, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).rejectJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LicensesApi - axios parameter creator
 * @export
 */
export const LicensesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API let’s you to add a license entry
         * @summary Update a license entry
         * @param {LicenseUpdateRequest} [licenseUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLicenseUpdateEntry: async (licenseUpdateRequest?: LicenseUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/license_updates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(licenseUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to fetch a list of licenses updates with multiple query parameters
         * @summary Get a list of licenses updates
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {string} [licenseId] License Id to filter
         * @param {string} [effectiveFrom] effectiveFrom to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseUpdates: async (nextToken?: string, accountId?: string, pageSize?: number, licenseId?: string, effectiveFrom?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/license_updates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (licenseId !== undefined) {
                localVarQueryParameter['licenseId'] = licenseId;
            }

            if (effectiveFrom !== undefined) {
                localVarQueryParameter['effectiveFrom'] = (effectiveFrom as any instanceof Date) ?
                    (effectiveFrom as any).toISOString() :
                    effectiveFrom;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to fetch a list of named licenses updates with multiple query parameters
         * @summary Get a list of named licenses updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamedLicenseUpdates: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/named_license_updates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to update metadata of a license entry
         * @summary Update a license entry details
         * @param {string} [licenseId] License Id to filter
         * @param {LicenseEntryDetailsUpdateRequest} [licenseEntryDetailsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLicenseEntryDetails: async (licenseId?: string, licenseEntryDetailsUpdateRequest?: LicenseEntryDetailsUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/license_updates/{license_id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (licenseId !== undefined) {
                localVarQueryParameter['licenseId'] = licenseId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(licenseEntryDetailsUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LicensesApi - functional programming interface
 * @export
 */
export const LicensesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LicensesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API let’s you to add a license entry
         * @summary Update a license entry
         * @param {LicenseUpdateRequest} [licenseUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addLicenseUpdateEntry(licenseUpdateRequest?: LicenseUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicenseUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addLicenseUpdateEntry(licenseUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to fetch a list of licenses updates with multiple query parameters
         * @summary Get a list of licenses updates
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {string} [licenseId] License Id to filter
         * @param {string} [effectiveFrom] effectiveFrom to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicenseUpdates(nextToken?: string, accountId?: string, pageSize?: number, licenseId?: string, effectiveFrom?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLicenseUpdatesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicenseUpdates(nextToken, accountId, pageSize, licenseId, effectiveFrom, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to fetch a list of named licenses updates with multiple query parameters
         * @summary Get a list of named licenses updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamedLicenseUpdates(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NamedLicenseUpdatesPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamedLicenseUpdates(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to update metadata of a license entry
         * @summary Update a license entry details
         * @param {string} [licenseId] License Id to filter
         * @param {LicenseEntryDetailsUpdateRequest} [licenseEntryDetailsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLicenseEntryDetails(licenseId?: string, licenseEntryDetailsUpdateRequest?: LicenseEntryDetailsUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicenseUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLicenseEntryDetails(licenseId, licenseEntryDetailsUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LicensesApi - factory interface
 * @export
 */
export const LicensesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LicensesApiFp(configuration)
    return {
        /**
         * This API let’s you to add a license entry
         * @summary Update a license entry
         * @param {LicenseUpdateRequest} [licenseUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLicenseUpdateEntry(licenseUpdateRequest?: LicenseUpdateRequest, options?: any): AxiosPromise<LicenseUpdateResponse> {
            return localVarFp.addLicenseUpdateEntry(licenseUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to fetch a list of licenses updates with multiple query parameters
         * @summary Get a list of licenses updates
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {string} [licenseId] License Id to filter
         * @param {string} [effectiveFrom] effectiveFrom to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseUpdates(nextToken?: string, accountId?: string, pageSize?: number, licenseId?: string, effectiveFrom?: string, options?: any): AxiosPromise<GetLicenseUpdatesResponse> {
            return localVarFp.getLicenseUpdates(nextToken, accountId, pageSize, licenseId, effectiveFrom, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to fetch a list of named licenses updates with multiple query parameters
         * @summary Get a list of named licenses updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamedLicenseUpdates(options?: any): AxiosPromise<NamedLicenseUpdatesPaginatedResponse> {
            return localVarFp.getNamedLicenseUpdates(options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to update metadata of a license entry
         * @summary Update a license entry details
         * @param {string} [licenseId] License Id to filter
         * @param {LicenseEntryDetailsUpdateRequest} [licenseEntryDetailsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLicenseEntryDetails(licenseId?: string, licenseEntryDetailsUpdateRequest?: LicenseEntryDetailsUpdateRequest, options?: any): AxiosPromise<LicenseUpdateResponse> {
            return localVarFp.updateLicenseEntryDetails(licenseId, licenseEntryDetailsUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LicensesApi - object-oriented interface
 * @export
 * @class LicensesApi
 * @extends {BaseAPI}
 */
export class LicensesApi extends BaseAPI {
    /**
     * This API let’s you to add a license entry
     * @summary Update a license entry
     * @param {LicenseUpdateRequest} [licenseUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicensesApi
     */
    public addLicenseUpdateEntry(licenseUpdateRequest?: LicenseUpdateRequest, options?: AxiosRequestConfig) {
        return LicensesApiFp(this.configuration).addLicenseUpdateEntry(licenseUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to fetch a list of licenses updates with multiple query parameters
     * @summary Get a list of licenses updates
     * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
     * @param {string} [accountId] Filter option to filter based on account id.
     * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
     * @param {string} [licenseId] License Id to filter
     * @param {string} [effectiveFrom] effectiveFrom to filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicensesApi
     */
    public getLicenseUpdates(nextToken?: string, accountId?: string, pageSize?: number, licenseId?: string, effectiveFrom?: string, options?: AxiosRequestConfig) {
        return LicensesApiFp(this.configuration).getLicenseUpdates(nextToken, accountId, pageSize, licenseId, effectiveFrom, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to fetch a list of named licenses updates with multiple query parameters
     * @summary Get a list of named licenses updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicensesApi
     */
    public getNamedLicenseUpdates(options?: AxiosRequestConfig) {
        return LicensesApiFp(this.configuration).getNamedLicenseUpdates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to update metadata of a license entry
     * @summary Update a license entry details
     * @param {string} [licenseId] License Id to filter
     * @param {LicenseEntryDetailsUpdateRequest} [licenseEntryDetailsUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicensesApi
     */
    public updateLicenseEntryDetails(licenseId?: string, licenseEntryDetailsUpdateRequest?: LicenseEntryDetailsUpdateRequest, options?: AxiosRequestConfig) {
        return LicensesApiFp(this.configuration).updateLicenseEntryDetails(licenseId, licenseEntryDetailsUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Togai Metrics API allows you to fetch different metrics from Events, Usage Meters and PricePlans with multiple queryable options. A single request can query up to five metrics.  Single response can contain a maximum of 300 data points. 
         * @summary Get Togai Metrics
         * @param {GetMetricsRequest} [getMetricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics: async (getMetricsRequest?: GetMetricsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getMetricsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * Togai Metrics API allows you to fetch different metrics from Events, Usage Meters and PricePlans with multiple queryable options. A single request can query up to five metrics.  Single response can contain a maximum of 300 data points. 
         * @summary Get Togai Metrics
         * @param {GetMetricsRequest} [getMetricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetrics(getMetricsRequest?: GetMetricsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetrics(getMetricsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * Togai Metrics API allows you to fetch different metrics from Events, Usage Meters and PricePlans with multiple queryable options. A single request can query up to five metrics.  Single response can contain a maximum of 300 data points. 
         * @summary Get Togai Metrics
         * @param {GetMetricsRequest} [getMetricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(getMetricsRequest?: GetMetricsRequest, options?: any): AxiosPromise<GetMetricsResponse> {
            return localVarFp.getMetrics(getMetricsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * Togai Metrics API allows you to fetch different metrics from Events, Usage Meters and PricePlans with multiple queryable options. A single request can query up to five metrics.  Single response can contain a maximum of 300 data points. 
     * @summary Get Togai Metrics
     * @param {GetMetricsRequest} [getMetricsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetrics(getMetricsRequest?: GetMetricsRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getMetrics(getMetricsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * create payments
         * @summary create payments
         * @param {CreatePaymentRequest} [createPaymentRequest] Payload to create a payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayments: async (createPaymentRequest?: CreatePaymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get payment
         * @summary Get a payment
         * @param {string} paymentId 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment: async (paymentId: string, version?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getPayment', 'paymentId', paymentId)
            const localVarPath = `/payments/{payment_id}`
                .replace(`{${"payment_id"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all payments
         * @summary List all payments
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments: async (nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * create payments
         * @summary create payments
         * @param {CreatePaymentRequest} [createPaymentRequest] Payload to create a payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPayments(createPaymentRequest?: CreatePaymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayments(createPaymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get payment
         * @summary Get a payment
         * @param {string} paymentId 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayment(paymentId: string, version?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayment(paymentId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all payments
         * @summary List all payments
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPayments(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPayments(nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * create payments
         * @summary create payments
         * @param {CreatePaymentRequest} [createPaymentRequest] Payload to create a payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayments(createPaymentRequest?: CreatePaymentRequest, options?: any): AxiosPromise<Payment> {
            return localVarFp.createPayments(createPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get payment
         * @summary Get a payment
         * @param {string} paymentId 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(paymentId: string, version?: number, options?: any): AxiosPromise<Payment> {
            return localVarFp.getPayment(paymentId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * List all payments
         * @summary List all payments
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments(nextToken?: string, pageSize?: number, options?: any): AxiosPromise<ListPaymentResponse> {
            return localVarFp.listPayments(nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * create payments
     * @summary create payments
     * @param {CreatePaymentRequest} [createPaymentRequest] Payload to create a payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public createPayments(createPaymentRequest?: CreatePaymentRequest, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).createPayments(createPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get payment
     * @summary Get a payment
     * @param {string} paymentId 
     * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getPayment(paymentId: string, version?: number, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).getPayment(paymentId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all payments
     * @summary List all payments
     * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
     * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public listPayments(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).listPayments(nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PriceExperimentationApi - axios parameter creator
 * @export
 */
export const PriceExperimentationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calculate and return the revenue for a existing or new price plan
         * @summary Calculate and return the revenue for a existing or new price plan
         * @param {CalculateRevenueRequest} calculateRevenueRequest Request payload for calculateRevenueAPI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateRevenue: async (calculateRevenueRequest: CalculateRevenueRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'calculateRevenueRequest' is not null or undefined
            assertParamExists('calculateRevenue', 'calculateRevenueRequest', calculateRevenueRequest)
            const localVarPath = `/revenue_calculator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(calculateRevenueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PriceExperimentationApi - functional programming interface
 * @export
 */
export const PriceExperimentationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PriceExperimentationApiAxiosParamCreator(configuration)
    return {
        /**
         * Calculate and return the revenue for a existing or new price plan
         * @summary Calculate and return the revenue for a existing or new price plan
         * @param {CalculateRevenueRequest} calculateRevenueRequest Request payload for calculateRevenueAPI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calculateRevenue(calculateRevenueRequest: CalculateRevenueRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CalculateRevenueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calculateRevenue(calculateRevenueRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PriceExperimentationApi - factory interface
 * @export
 */
export const PriceExperimentationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PriceExperimentationApiFp(configuration)
    return {
        /**
         * Calculate and return the revenue for a existing or new price plan
         * @summary Calculate and return the revenue for a existing or new price plan
         * @param {CalculateRevenueRequest} calculateRevenueRequest Request payload for calculateRevenueAPI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateRevenue(calculateRevenueRequest: CalculateRevenueRequest, options?: any): AxiosPromise<CalculateRevenueResponse> {
            return localVarFp.calculateRevenue(calculateRevenueRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PriceExperimentationApi - object-oriented interface
 * @export
 * @class PriceExperimentationApi
 * @extends {BaseAPI}
 */
export class PriceExperimentationApi extends BaseAPI {
    /**
     * Calculate and return the revenue for a existing or new price plan
     * @summary Calculate and return the revenue for a existing or new price plan
     * @param {CalculateRevenueRequest} calculateRevenueRequest Request payload for calculateRevenueAPI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceExperimentationApi
     */
    public calculateRevenue(calculateRevenueRequest: CalculateRevenueRequest, options?: AxiosRequestConfig) {
        return PriceExperimentationApiFp(this.configuration).calculateRevenue(calculateRevenueRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PricePlansApi - axios parameter creator
 * @export
 */
export const PricePlansApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate a price plan details using price plan id
         * @summary Activate a price plan
         * @param {string} pricePlanId 
         * @param {ActivatePricePlanRequest} activatePricePlanRequest Payload to activate price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePricePlan: async (pricePlanId: string, activatePricePlanRequest: ActivatePricePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('activatePricePlan', 'pricePlanId', pricePlanId)
            // verify required parameter 'activatePricePlanRequest' is not null or undefined
            assertParamExists('activatePricePlan', 'activatePricePlanRequest', activatePricePlanRequest)
            const localVarPath = `/price_plans/{price_plan_id}/activate`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activatePricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add currencies to a price plan
         * @summary Add currencies to a price plan
         * @param {string} pricePlanId 
         * @param {AddCurrencyToPricePlanRequest} addCurrencyToPricePlanRequest Payload to add currency to price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCurrencyToPricePlan: async (pricePlanId: string, addCurrencyToPricePlanRequest: AddCurrencyToPricePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('addCurrencyToPricePlan', 'pricePlanId', pricePlanId)
            // verify required parameter 'addCurrencyToPricePlanRequest' is not null or undefined
            assertParamExists('addCurrencyToPricePlan', 'addCurrencyToPricePlanRequest', addCurrencyToPricePlanRequest)
            const localVarPath = `/price_plans/{price_plan_id}/currencies`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addCurrencyToPricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archive a price plan
         * @summary Archive a price plan
         * @param {string} pricePlanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archivePricePlan: async (pricePlanId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('archivePricePlan', 'pricePlanId', pricePlanId)
            const localVarPath = `/price_plans/{price_plan_id}`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let\'s you create and price plan Learn more about [Price Plans](https://docs.togai.com/docs/priceplan) 
         * @summary Create a price plan
         * @param {CreatePricePlanRequest} createPricePlanRequest Payload to create price plan
         * @param {boolean} [dryRun] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPricePlan: async (createPricePlanRequest: CreatePricePlanRequest, dryRun?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPricePlanRequest' is not null or undefined
            assertParamExists('createPricePlan', 'createPricePlanRequest', createPricePlanRequest)
            const localVarPath = `/price_plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a price plan details using price plan id
         * @summary Get a price plan
         * @param {string} pricePlanId 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricePlan: async (pricePlanId: string, version?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('getPricePlan', 'pricePlanId', pricePlanId)
            const localVarPath = `/price_plans/{price_plan_id}`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of price plans
         * @summary List price plans
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricePlans: async (nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/price_plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Migrates accounts across price plans. This is an asynchronous process functioning on top of Togai\'s Jobs  framework. Status of the created migrations can be obtained using the [Jobs APIs](https://docs.togai.com/api-reference/jobs/get-the-status-of-a-job) 
         * @summary Create a price plan migration
         * @param {CreatePricePlanMigrationRequest} createPricePlanMigrationRequest Payload to create price plan migration request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricePlanMigration: async (createPricePlanMigrationRequest: CreatePricePlanMigrationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPricePlanMigrationRequest' is not null or undefined
            assertParamExists('pricePlanMigration', 'createPricePlanMigrationRequest', createPricePlanMigrationRequest)
            const localVarPath = `/price_plans/migration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPricePlanMigrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a draft currency from a price plan
         * @summary Remove a draft currency from a price plan
         * @param {string} pricePlanId 
         * @param {string} currencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCurrencyFromPricePlan: async (pricePlanId: string, currencyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('removeCurrencyFromPricePlan', 'pricePlanId', pricePlanId)
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('removeCurrencyFromPricePlan', 'currencyId', currencyId)
            const localVarPath = `/price_plans/{price_plan_id}/currencies/{currency_id}`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)))
                .replace(`{${"currency_id"}}`, encodeURIComponent(String(currencyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing price plan Price Plans with status as DRAFT alone can be updated . Learn more about [Price plans](https://docs.togai.com/docs/priceplan) from our Guides 
         * @summary Update a price plan
         * @param {string} pricePlanId 
         * @param {UpdatePricePlanRequest} updatePricePlanRequest Payload to update price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricePlan: async (pricePlanId: string, updatePricePlanRequest: UpdatePricePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('updatePricePlan', 'pricePlanId', pricePlanId)
            // verify required parameter 'updatePricePlanRequest' is not null or undefined
            assertParamExists('updatePricePlan', 'updatePricePlanRequest', updatePricePlanRequest)
            const localVarPath = `/price_plans/{price_plan_id}`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PricePlansApi - functional programming interface
 * @export
 */
export const PricePlansApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PricePlansApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate a price plan details using price plan id
         * @summary Activate a price plan
         * @param {string} pricePlanId 
         * @param {ActivatePricePlanRequest} activatePricePlanRequest Payload to activate price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activatePricePlan(pricePlanId: string, activatePricePlanRequest: ActivatePricePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activatePricePlan(pricePlanId, activatePricePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add currencies to a price plan
         * @summary Add currencies to a price plan
         * @param {string} pricePlanId 
         * @param {AddCurrencyToPricePlanRequest} addCurrencyToPricePlanRequest Payload to add currency to price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCurrencyToPricePlan(pricePlanId: string, addCurrencyToPricePlanRequest: AddCurrencyToPricePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCurrencyToPricePlan(pricePlanId, addCurrencyToPricePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Archive a price plan
         * @summary Archive a price plan
         * @param {string} pricePlanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archivePricePlan(pricePlanId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archivePricePlan(pricePlanId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let\'s you create and price plan Learn more about [Price Plans](https://docs.togai.com/docs/priceplan) 
         * @summary Create a price plan
         * @param {CreatePricePlanRequest} createPricePlanRequest Payload to create price plan
         * @param {boolean} [dryRun] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPricePlan(createPricePlanRequest: CreatePricePlanRequest, dryRun?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPricePlan(createPricePlanRequest, dryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a price plan details using price plan id
         * @summary Get a price plan
         * @param {string} pricePlanId 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricePlan(pricePlanId: string, version?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricePlan(pricePlanId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of price plans
         * @summary List price plans
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricePlans(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlanPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricePlans(nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Migrates accounts across price plans. This is an asynchronous process functioning on top of Togai\'s Jobs  framework. Status of the created migrations can be obtained using the [Jobs APIs](https://docs.togai.com/api-reference/jobs/get-the-status-of-a-job) 
         * @summary Create a price plan migration
         * @param {CreatePricePlanMigrationRequest} createPricePlanMigrationRequest Payload to create price plan migration request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pricePlanMigration(createPricePlanMigrationRequest: CreatePricePlanMigrationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pricePlanMigration(createPricePlanMigrationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a draft currency from a price plan
         * @summary Remove a draft currency from a price plan
         * @param {string} pricePlanId 
         * @param {string} currencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeCurrencyFromPricePlan(pricePlanId: string, currencyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeCurrencyFromPricePlan(pricePlanId, currencyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing price plan Price Plans with status as DRAFT alone can be updated . Learn more about [Price plans](https://docs.togai.com/docs/priceplan) from our Guides 
         * @summary Update a price plan
         * @param {string} pricePlanId 
         * @param {UpdatePricePlanRequest} updatePricePlanRequest Payload to update price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePricePlan(pricePlanId: string, updatePricePlanRequest: UpdatePricePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePricePlan(pricePlanId, updatePricePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PricePlansApi - factory interface
 * @export
 */
export const PricePlansApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PricePlansApiFp(configuration)
    return {
        /**
         * Activate a price plan details using price plan id
         * @summary Activate a price plan
         * @param {string} pricePlanId 
         * @param {ActivatePricePlanRequest} activatePricePlanRequest Payload to activate price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePricePlan(pricePlanId: string, activatePricePlanRequest: ActivatePricePlanRequest, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.activatePricePlan(pricePlanId, activatePricePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add currencies to a price plan
         * @summary Add currencies to a price plan
         * @param {string} pricePlanId 
         * @param {AddCurrencyToPricePlanRequest} addCurrencyToPricePlanRequest Payload to add currency to price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCurrencyToPricePlan(pricePlanId: string, addCurrencyToPricePlanRequest: AddCurrencyToPricePlanRequest, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.addCurrencyToPricePlan(pricePlanId, addCurrencyToPricePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Archive a price plan
         * @summary Archive a price plan
         * @param {string} pricePlanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archivePricePlan(pricePlanId: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.archivePricePlan(pricePlanId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let\'s you create and price plan Learn more about [Price Plans](https://docs.togai.com/docs/priceplan) 
         * @summary Create a price plan
         * @param {CreatePricePlanRequest} createPricePlanRequest Payload to create price plan
         * @param {boolean} [dryRun] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPricePlan(createPricePlanRequest: CreatePricePlanRequest, dryRun?: boolean, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.createPricePlan(createPricePlanRequest, dryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a price plan details using price plan id
         * @summary Get a price plan
         * @param {string} pricePlanId 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricePlan(pricePlanId: string, version?: number, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.getPricePlan(pricePlanId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of price plans
         * @summary List price plans
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricePlans(nextToken?: string, pageSize?: number, options?: any): AxiosPromise<PricePlanPaginatedResponse> {
            return localVarFp.getPricePlans(nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Migrates accounts across price plans. This is an asynchronous process functioning on top of Togai\'s Jobs  framework. Status of the created migrations can be obtained using the [Jobs APIs](https://docs.togai.com/api-reference/jobs/get-the-status-of-a-job) 
         * @summary Create a price plan migration
         * @param {CreatePricePlanMigrationRequest} createPricePlanMigrationRequest Payload to create price plan migration request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricePlanMigration(createPricePlanMigrationRequest: CreatePricePlanMigrationRequest, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.pricePlanMigration(createPricePlanMigrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a draft currency from a price plan
         * @summary Remove a draft currency from a price plan
         * @param {string} pricePlanId 
         * @param {string} currencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCurrencyFromPricePlan(pricePlanId: string, currencyId: string, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.removeCurrencyFromPricePlan(pricePlanId, currencyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing price plan Price Plans with status as DRAFT alone can be updated . Learn more about [Price plans](https://docs.togai.com/docs/priceplan) from our Guides 
         * @summary Update a price plan
         * @param {string} pricePlanId 
         * @param {UpdatePricePlanRequest} updatePricePlanRequest Payload to update price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricePlan(pricePlanId: string, updatePricePlanRequest: UpdatePricePlanRequest, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.updatePricePlan(pricePlanId, updatePricePlanRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PricePlansApi - object-oriented interface
 * @export
 * @class PricePlansApi
 * @extends {BaseAPI}
 */
export class PricePlansApi extends BaseAPI {
    /**
     * Activate a price plan details using price plan id
     * @summary Activate a price plan
     * @param {string} pricePlanId 
     * @param {ActivatePricePlanRequest} activatePricePlanRequest Payload to activate price plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public activatePricePlan(pricePlanId: string, activatePricePlanRequest: ActivatePricePlanRequest, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).activatePricePlan(pricePlanId, activatePricePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add currencies to a price plan
     * @summary Add currencies to a price plan
     * @param {string} pricePlanId 
     * @param {AddCurrencyToPricePlanRequest} addCurrencyToPricePlanRequest Payload to add currency to price plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public addCurrencyToPricePlan(pricePlanId: string, addCurrencyToPricePlanRequest: AddCurrencyToPricePlanRequest, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).addCurrencyToPricePlan(pricePlanId, addCurrencyToPricePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archive a price plan
     * @summary Archive a price plan
     * @param {string} pricePlanId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public archivePricePlan(pricePlanId: string, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).archivePricePlan(pricePlanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let\'s you create and price plan Learn more about [Price Plans](https://docs.togai.com/docs/priceplan) 
     * @summary Create a price plan
     * @param {CreatePricePlanRequest} createPricePlanRequest Payload to create price plan
     * @param {boolean} [dryRun] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public createPricePlan(createPricePlanRequest: CreatePricePlanRequest, dryRun?: boolean, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).createPricePlan(createPricePlanRequest, dryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a price plan details using price plan id
     * @summary Get a price plan
     * @param {string} pricePlanId 
     * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public getPricePlan(pricePlanId: string, version?: number, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).getPricePlan(pricePlanId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of price plans
     * @summary List price plans
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public getPricePlans(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).getPricePlans(nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Migrates accounts across price plans. This is an asynchronous process functioning on top of Togai\'s Jobs  framework. Status of the created migrations can be obtained using the [Jobs APIs](https://docs.togai.com/api-reference/jobs/get-the-status-of-a-job) 
     * @summary Create a price plan migration
     * @param {CreatePricePlanMigrationRequest} createPricePlanMigrationRequest Payload to create price plan migration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public pricePlanMigration(createPricePlanMigrationRequest: CreatePricePlanMigrationRequest, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).pricePlanMigration(createPricePlanMigrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a draft currency from a price plan
     * @summary Remove a draft currency from a price plan
     * @param {string} pricePlanId 
     * @param {string} currencyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public removeCurrencyFromPricePlan(pricePlanId: string, currencyId: string, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).removeCurrencyFromPricePlan(pricePlanId, currencyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing price plan Price Plans with status as DRAFT alone can be updated . Learn more about [Price plans](https://docs.togai.com/docs/priceplan) from our Guides 
     * @summary Update a price plan
     * @param {string} pricePlanId 
     * @param {UpdatePricePlanRequest} updatePricePlanRequest Payload to update price plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public updatePricePlan(pricePlanId: string, updatePricePlanRequest: UpdatePricePlanRequest, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).updatePricePlan(pricePlanId, updatePricePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PricingRulesApi - axios parameter creator
 * @export
 */
export const PricingRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of pricing rules using price plan id and pricing schedule id
         * @summary List pricing rules by price plan id and pricing schedule id
         * @param {string} pricePlanId 
         * @param {string} pricingScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPricingRulesByScheduleId: async (pricePlanId: string, pricingScheduleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('listPricingRulesByScheduleId', 'pricePlanId', pricePlanId)
            // verify required parameter 'pricingScheduleId' is not null or undefined
            assertParamExists('listPricingRulesByScheduleId', 'pricingScheduleId', pricingScheduleId)
            const localVarPath = `/price_plans/{price_plan_id}/pricing_schedules/{pricing_schedule_id}/pricing_rules`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)))
                .replace(`{${"pricing_schedule_id"}}`, encodeURIComponent(String(pricingScheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PricingRulesApi - functional programming interface
 * @export
 */
export const PricingRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PricingRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of pricing rules using price plan id and pricing schedule id
         * @summary List pricing rules by price plan id and pricing schedule id
         * @param {string} pricePlanId 
         * @param {string} pricingScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPricingRulesByScheduleId(pricePlanId: string, pricingScheduleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricingRulesPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPricingRulesByScheduleId(pricePlanId, pricingScheduleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PricingRulesApi - factory interface
 * @export
 */
export const PricingRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PricingRulesApiFp(configuration)
    return {
        /**
         * Get a list of pricing rules using price plan id and pricing schedule id
         * @summary List pricing rules by price plan id and pricing schedule id
         * @param {string} pricePlanId 
         * @param {string} pricingScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPricingRulesByScheduleId(pricePlanId: string, pricingScheduleId: string, options?: any): AxiosPromise<PricingRulesPaginatedResponse> {
            return localVarFp.listPricingRulesByScheduleId(pricePlanId, pricingScheduleId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PricingRulesApi - object-oriented interface
 * @export
 * @class PricingRulesApi
 * @extends {BaseAPI}
 */
export class PricingRulesApi extends BaseAPI {
    /**
     * Get a list of pricing rules using price plan id and pricing schedule id
     * @summary List pricing rules by price plan id and pricing schedule id
     * @param {string} pricePlanId 
     * @param {string} pricingScheduleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricingRulesApi
     */
    public listPricingRulesByScheduleId(pricePlanId: string, pricingScheduleId: string, options?: AxiosRequestConfig) {
        return PricingRulesApiFp(this.configuration).listPricingRulesByScheduleId(pricePlanId, pricingScheduleId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a setting
         * @summary Get a setting
         * @param {string} settingIdStr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetting: async (settingIdStr: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'settingIdStr' is not null or undefined
            assertParamExists('getSetting', 'settingIdStr', settingIdStr)
            const localVarPath = `/settings/{setting_id_str}`
                .replace(`{${"setting_id_str"}}`, encodeURIComponent(String(settingIdStr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a setting
         * @summary Create a setting
         * @param {Setting} setting Payload to insert setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertSetting: async (setting: Setting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setting' is not null or undefined
            assertParamExists('insertSetting', 'setting', setting)
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List settings
         * @summary Lists settings
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {string} [entityType] 
         * @param {string} [entityId] 
         * @param {string} [settingId] 
         * @param {string} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSetting: async (nextToken?: string, pageSize?: number, entityType?: string, entityId?: string, settingId?: string, namespace?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (entityType !== undefined) {
                localVarQueryParameter['entity_type'] = entityType;
            }

            if (entityId !== undefined) {
                localVarQueryParameter['entity_id'] = entityId;
            }

            if (settingId !== undefined) {
                localVarQueryParameter['setting_id'] = settingId;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a setting
         * @summary Update a setting
         * @param {string} settingIdStr 
         * @param {UpdateSettingRequest} updateSettingRequest Payload to update setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting: async (settingIdStr: string, updateSettingRequest: UpdateSettingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'settingIdStr' is not null or undefined
            assertParamExists('updateSetting', 'settingIdStr', settingIdStr)
            // verify required parameter 'updateSettingRequest' is not null or undefined
            assertParamExists('updateSetting', 'updateSettingRequest', updateSettingRequest)
            const localVarPath = `/settings/{setting_id_str}`
                .replace(`{${"setting_id_str"}}`, encodeURIComponent(String(settingIdStr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSettingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a setting
         * @summary Get a setting
         * @param {string} settingIdStr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSetting(settingIdStr: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSetting(settingIdStr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a setting
         * @summary Create a setting
         * @param {Setting} setting Payload to insert setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertSetting(setting: Setting, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertSetting(setting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List settings
         * @summary Lists settings
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {string} [entityType] 
         * @param {string} [entityId] 
         * @param {string} [settingId] 
         * @param {string} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSetting(nextToken?: string, pageSize?: number, entityType?: string, entityId?: string, settingId?: string, namespace?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSetting(nextToken, pageSize, entityType, entityId, settingId, namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a setting
         * @summary Update a setting
         * @param {string} settingIdStr 
         * @param {UpdateSettingRequest} updateSettingRequest Payload to update setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSetting(settingIdStr: string, updateSettingRequest: UpdateSettingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSetting(settingIdStr, updateSettingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         * Get a setting
         * @summary Get a setting
         * @param {string} settingIdStr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetting(settingIdStr: string, options?: any): AxiosPromise<Setting> {
            return localVarFp.getSetting(settingIdStr, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a setting
         * @summary Create a setting
         * @param {Setting} setting Payload to insert setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertSetting(setting: Setting, options?: any): AxiosPromise<Setting> {
            return localVarFp.insertSetting(setting, options).then((request) => request(axios, basePath));
        },
        /**
         * List settings
         * @summary Lists settings
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {string} [entityType] 
         * @param {string} [entityId] 
         * @param {string} [settingId] 
         * @param {string} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSetting(nextToken?: string, pageSize?: number, entityType?: string, entityId?: string, settingId?: string, namespace?: string, options?: any): AxiosPromise<SettingPaginatedResponse> {
            return localVarFp.listSetting(nextToken, pageSize, entityType, entityId, settingId, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a setting
         * @summary Update a setting
         * @param {string} settingIdStr 
         * @param {UpdateSettingRequest} updateSettingRequest Payload to update setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting(settingIdStr: string, updateSettingRequest: UpdateSettingRequest, options?: any): AxiosPromise<Setting> {
            return localVarFp.updateSetting(settingIdStr, updateSettingRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * Get a setting
     * @summary Get a setting
     * @param {string} settingIdStr 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getSetting(settingIdStr: string, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).getSetting(settingIdStr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a setting
     * @summary Create a setting
     * @param {Setting} setting Payload to insert setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public insertSetting(setting: Setting, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).insertSetting(setting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List settings
     * @summary Lists settings
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {string} [entityType] 
     * @param {string} [entityId] 
     * @param {string} [settingId] 
     * @param {string} [namespace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public listSetting(nextToken?: string, pageSize?: number, entityType?: string, entityId?: string, settingId?: string, namespace?: string, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).listSetting(nextToken, pageSize, entityType, entityId, settingId, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a setting
     * @summary Update a setting
     * @param {string} settingIdStr 
     * @param {UpdateSettingRequest} updateSettingRequest Payload to update setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public updateSetting(settingIdStr: string, updateSettingRequest: UpdateSettingRequest, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).updateSetting(settingIdStr, updateSettingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsageMetersApi - axios parameter creator
 * @export
 */
export const UsageMetersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate usage meter
         * @summary Activate usage meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUsageMeter: async (usageMeterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usageMeterId' is not null or undefined
            assertParamExists('activateUsageMeter', 'usageMeterId', usageMeterId)
            const localVarPath = `/usage_meters/{usage_meter_id}/activate`
                .replace(`{${"usage_meter_id"}}`, encodeURIComponent(String(usageMeterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an usage meter and associate with an event schema
         * @summary Create an usage meter
         * @param {CreateUsageMeterRequest} createUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsageMeter: async (createUsageMeterRequest: CreateUsageMeterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUsageMeterRequest' is not null or undefined
            assertParamExists('createUsageMeter', 'createUsageMeterRequest', createUsageMeterRequest)
            const localVarPath = `/usage_meters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUsageMeterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make an existing active usage meter to be inactive Active Usage Meters with active Pricing Plan attached can also be deactivated. 
         * @summary Deactivate usage meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUsageMeter: async (usageMeterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usageMeterId' is not null or undefined
            assertParamExists('deactivateUsageMeter', 'usageMeterId', usageMeterId)
            const localVarPath = `/usage_meters/{usage_meter_id}/deactivate`
                .replace(`{${"usage_meter_id"}}`, encodeURIComponent(String(usageMeterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an Usage Meter
         * @summary Delete an Usage Meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsageMeter: async (usageMeterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usageMeterId' is not null or undefined
            assertParamExists('deleteUsageMeter', 'usageMeterId', usageMeterId)
            const localVarPath = `/usage_meters/{usage_meter_id}`
                .replace(`{${"usage_meter_id"}}`, encodeURIComponent(String(usageMeterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an usage meter using event schema name and usage meter id.
         * @summary Get usage meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMeter: async (usageMeterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usageMeterId' is not null or undefined
            assertParamExists('getUsageMeter', 'usageMeterId', usageMeterId)
            const localVarPath = `/usage_meters/{usage_meter_id}`
                .replace(`{${"usage_meter_id"}}`, encodeURIComponent(String(usageMeterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of usage meters associated with an event schema
         * @summary List usage meters for event schema
         * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by status 
         * @param {'COUNT' | 'SUM'} [aggregations] Filter by aggregations 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMetersForEventSchema: async (status?: 'ACTIVE' | 'INACTIVE', aggregations?: 'COUNT' | 'SUM', nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/usage_meters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (aggregations !== undefined) {
                localVarQueryParameter['aggregations'] = aggregations;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API lets you update an existing usage meter.
         * @summary Update an usage meter
         * @param {string} usageMeterId 
         * @param {UpdateUsageMeterRequest} updateUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsageMeter: async (usageMeterId: string, updateUsageMeterRequest: UpdateUsageMeterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usageMeterId' is not null or undefined
            assertParamExists('updateUsageMeter', 'usageMeterId', usageMeterId)
            // verify required parameter 'updateUsageMeterRequest' is not null or undefined
            assertParamExists('updateUsageMeter', 'updateUsageMeterRequest', updateUsageMeterRequest)
            const localVarPath = `/usage_meters/{usage_meter_id}`
                .replace(`{${"usage_meter_id"}}`, encodeURIComponent(String(usageMeterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUsageMeterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsageMetersApi - functional programming interface
 * @export
 */
export const UsageMetersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsageMetersApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate usage meter
         * @summary Activate usage meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateUsageMeter(usageMeterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateUsageMeter(usageMeterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an usage meter and associate with an event schema
         * @summary Create an usage meter
         * @param {CreateUsageMeterRequest} createUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUsageMeter(createUsageMeterRequest: CreateUsageMeterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUsageMeter(createUsageMeterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Make an existing active usage meter to be inactive Active Usage Meters with active Pricing Plan attached can also be deactivated. 
         * @summary Deactivate usage meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateUsageMeter(usageMeterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateUsageMeter(usageMeterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an Usage Meter
         * @summary Delete an Usage Meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsageMeter(usageMeterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUsageMeter(usageMeterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an usage meter using event schema name and usage meter id.
         * @summary Get usage meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsageMeter(usageMeterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageMeter(usageMeterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of usage meters associated with an event schema
         * @summary List usage meters for event schema
         * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by status 
         * @param {'COUNT' | 'SUM'} [aggregations] Filter by aggregations 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsageMetersForEventSchema(status?: 'ACTIVE' | 'INACTIVE', aggregations?: 'COUNT' | 'SUM', nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeterPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageMetersForEventSchema(status, aggregations, nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API lets you update an existing usage meter.
         * @summary Update an usage meter
         * @param {string} usageMeterId 
         * @param {UpdateUsageMeterRequest} updateUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUsageMeter(usageMeterId: string, updateUsageMeterRequest: UpdateUsageMeterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUsageMeter(usageMeterId, updateUsageMeterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsageMetersApi - factory interface
 * @export
 */
export const UsageMetersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsageMetersApiFp(configuration)
    return {
        /**
         * Activate usage meter
         * @summary Activate usage meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUsageMeter(usageMeterId: string, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.activateUsageMeter(usageMeterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an usage meter and associate with an event schema
         * @summary Create an usage meter
         * @param {CreateUsageMeterRequest} createUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsageMeter(createUsageMeterRequest: CreateUsageMeterRequest, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.createUsageMeter(createUsageMeterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Make an existing active usage meter to be inactive Active Usage Meters with active Pricing Plan attached can also be deactivated. 
         * @summary Deactivate usage meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUsageMeter(usageMeterId: string, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.deactivateUsageMeter(usageMeterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an Usage Meter
         * @summary Delete an Usage Meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsageMeter(usageMeterId: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteUsageMeter(usageMeterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an usage meter using event schema name and usage meter id.
         * @summary Get usage meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMeter(usageMeterId: string, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.getUsageMeter(usageMeterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of usage meters associated with an event schema
         * @summary List usage meters for event schema
         * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by status 
         * @param {'COUNT' | 'SUM'} [aggregations] Filter by aggregations 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMetersForEventSchema(status?: 'ACTIVE' | 'INACTIVE', aggregations?: 'COUNT' | 'SUM', nextToken?: string, pageSize?: number, options?: any): AxiosPromise<UsageMeterPaginatedResponse> {
            return localVarFp.getUsageMetersForEventSchema(status, aggregations, nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * This API lets you update an existing usage meter.
         * @summary Update an usage meter
         * @param {string} usageMeterId 
         * @param {UpdateUsageMeterRequest} updateUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsageMeter(usageMeterId: string, updateUsageMeterRequest: UpdateUsageMeterRequest, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.updateUsageMeter(usageMeterId, updateUsageMeterRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsageMetersApi - object-oriented interface
 * @export
 * @class UsageMetersApi
 * @extends {BaseAPI}
 */
export class UsageMetersApi extends BaseAPI {
    /**
     * Activate usage meter
     * @summary Activate usage meter
     * @param {string} usageMeterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public activateUsageMeter(usageMeterId: string, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).activateUsageMeter(usageMeterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an usage meter and associate with an event schema
     * @summary Create an usage meter
     * @param {CreateUsageMeterRequest} createUsageMeterRequest Payload to create usage meter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public createUsageMeter(createUsageMeterRequest: CreateUsageMeterRequest, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).createUsageMeter(createUsageMeterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Make an existing active usage meter to be inactive Active Usage Meters with active Pricing Plan attached can also be deactivated. 
     * @summary Deactivate usage meter
     * @param {string} usageMeterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public deactivateUsageMeter(usageMeterId: string, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).deactivateUsageMeter(usageMeterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an Usage Meter
     * @summary Delete an Usage Meter
     * @param {string} usageMeterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public deleteUsageMeter(usageMeterId: string, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).deleteUsageMeter(usageMeterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an usage meter using event schema name and usage meter id.
     * @summary Get usage meter
     * @param {string} usageMeterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public getUsageMeter(usageMeterId: string, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).getUsageMeter(usageMeterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of usage meters associated with an event schema
     * @summary List usage meters for event schema
     * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by status 
     * @param {'COUNT' | 'SUM'} [aggregations] Filter by aggregations 
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public getUsageMetersForEventSchema(status?: 'ACTIVE' | 'INACTIVE', aggregations?: 'COUNT' | 'SUM', nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).getUsageMetersForEventSchema(status, aggregations, nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API lets you update an existing usage meter.
     * @summary Update an usage meter
     * @param {string} usageMeterId 
     * @param {UpdateUsageMeterRequest} updateUsageMeterRequest Payload to create usage meter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public updateUsageMeter(usageMeterId: string, updateUsageMeterRequest: UpdateUsageMeterRequest, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).updateUsageMeter(usageMeterId, updateUsageMeterRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WalletApi - axios parameter creator
 * @export
 */
export const WalletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Top-up wallet for an account
         * @summary Top-up wallet for an account
         * @param {string} accountId account_id corresponding to an account
         * @param {TopupWalletRequest} [topupWalletRequest] Payload to topup wallet of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topUpWalletForAccount: async (accountId: string, topupWalletRequest?: TopupWalletRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('topUpWalletForAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/wallet_topup`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(topupWalletRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update wallet details for an account
         * @summary Update wallet details for an account
         * @param {string} accountId account_id corresponding to an account
         * @param {UpdateWalletRequest} [updateWalletRequest] Payload to update wallet of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWalletForAccount: async (accountId: string, updateWalletRequest?: UpdateWalletRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateWalletForAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/wallet`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWalletRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Wallet balance for Account
         * @summary Wallet balance for Account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletBalanceForAccount: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('walletBalanceForAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/wallet`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Wallet entries for Account
         * @summary Wallet entries for Account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletEntriesForAccount: async (accountId: string, nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('walletEntriesForAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/wallet/entries`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletApi - functional programming interface
 * @export
 */
export const WalletApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletApiAxiosParamCreator(configuration)
    return {
        /**
         * Top-up wallet for an account
         * @summary Top-up wallet for an account
         * @param {string} accountId account_id corresponding to an account
         * @param {TopupWalletRequest} [topupWalletRequest] Payload to topup wallet of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topUpWalletForAccount(accountId: string, topupWalletRequest?: TopupWalletRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topUpWalletForAccount(accountId, topupWalletRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update wallet details for an account
         * @summary Update wallet details for an account
         * @param {string} accountId account_id corresponding to an account
         * @param {UpdateWalletRequest} [updateWalletRequest] Payload to update wallet of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWalletForAccount(accountId: string, updateWalletRequest?: UpdateWalletRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWalletForAccount(accountId, updateWalletRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Wallet balance for Account
         * @summary Wallet balance for Account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletBalanceForAccount(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletBalanceForAccount(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Wallet entries for Account
         * @summary Wallet entries for Account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletEntriesForAccount(accountId: string, nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletEntriesPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletEntriesForAccount(accountId, nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WalletApi - factory interface
 * @export
 */
export const WalletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletApiFp(configuration)
    return {
        /**
         * Top-up wallet for an account
         * @summary Top-up wallet for an account
         * @param {string} accountId account_id corresponding to an account
         * @param {TopupWalletRequest} [topupWalletRequest] Payload to topup wallet of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topUpWalletForAccount(accountId: string, topupWalletRequest?: TopupWalletRequest, options?: any): AxiosPromise<WalletBalanceResponse> {
            return localVarFp.topUpWalletForAccount(accountId, topupWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update wallet details for an account
         * @summary Update wallet details for an account
         * @param {string} accountId account_id corresponding to an account
         * @param {UpdateWalletRequest} [updateWalletRequest] Payload to update wallet of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWalletForAccount(accountId: string, updateWalletRequest?: UpdateWalletRequest, options?: any): AxiosPromise<WalletBalanceResponse> {
            return localVarFp.updateWalletForAccount(accountId, updateWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Wallet balance for Account
         * @summary Wallet balance for Account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletBalanceForAccount(accountId: string, options?: any): AxiosPromise<WalletBalanceResponse> {
            return localVarFp.walletBalanceForAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Wallet entries for Account
         * @summary Wallet entries for Account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletEntriesForAccount(accountId: string, nextToken?: string, pageSize?: number, options?: any): AxiosPromise<WalletEntriesPaginatedResponse> {
            return localVarFp.walletEntriesForAccount(accountId, nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
export class WalletApi extends BaseAPI {
    /**
     * Top-up wallet for an account
     * @summary Top-up wallet for an account
     * @param {string} accountId account_id corresponding to an account
     * @param {TopupWalletRequest} [topupWalletRequest] Payload to topup wallet of an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public topUpWalletForAccount(accountId: string, topupWalletRequest?: TopupWalletRequest, options?: AxiosRequestConfig) {
        return WalletApiFp(this.configuration).topUpWalletForAccount(accountId, topupWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update wallet details for an account
     * @summary Update wallet details for an account
     * @param {string} accountId account_id corresponding to an account
     * @param {UpdateWalletRequest} [updateWalletRequest] Payload to update wallet of an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public updateWalletForAccount(accountId: string, updateWalletRequest?: UpdateWalletRequest, options?: AxiosRequestConfig) {
        return WalletApiFp(this.configuration).updateWalletForAccount(accountId, updateWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Wallet balance for Account
     * @summary Wallet balance for Account
     * @param {string} accountId account_id corresponding to an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public walletBalanceForAccount(accountId: string, options?: AxiosRequestConfig) {
        return WalletApiFp(this.configuration).walletBalanceForAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Wallet entries for Account
     * @summary Wallet entries for Account
     * @param {string} accountId account_id corresponding to an account
     * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
     * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public walletEntriesForAccount(accountId: string, nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return WalletApiFp(this.configuration).walletEntriesForAccount(accountId, nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


