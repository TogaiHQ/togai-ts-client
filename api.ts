/* tslint:disable */
/* eslint-disable */
/**
 * Togai Apis
 * APIs for Togai App
 *
 * The version of the OpenAPI document: 1.0
 * Contact: engg@togai.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Structure of an account
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * Identifier of the account
     * @type {string}
     * @memberof Account
     */
    'id': string;
    /**
     * Name of the Account
     * @type {string}
     * @memberof Account
     */
    'name': string;
    /**
     * [ISO_4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency in which the account must be invoiced Defaults to Base currency. 
     * @type {string}
     * @memberof Account
     */
    'invoiceCurrency': string;
    /**
     * list of aliases of the account
     * @type {Array<AccountAliases>}
     * @memberof Account
     */
    'aliases'?: Array<AccountAliases>;
    /**
     * Status of the account
     * @type {string}
     * @memberof Account
     */
    'status': AccountStatusEnum;
}

export const AccountStatusEnum = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type AccountStatusEnum = typeof AccountStatusEnum[keyof typeof AccountStatusEnum];

/**
 * 
 * @export
 * @interface AccountAliases
 */
export interface AccountAliases {
    /**
     * 
     * @type {string}
     * @memberof AccountAliases
     */
    'alias'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountAliases
     */
    'status'?: AccountAliasesStatusEnum;
}

export const AccountAliasesStatusEnum = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type AccountAliasesStatusEnum = typeof AccountAliasesStatusEnum[keyof typeof AccountAliasesStatusEnum];

/**
 * 
 * @export
 * @interface AccountPaginatedResponse
 */
export interface AccountPaginatedResponse {
    /**
     * 
     * @type {Array<Account>}
     * @memberof AccountPaginatedResponse
     */
    'data'?: Array<Account>;
    /**
     * 
     * @type {string}
     * @memberof AccountPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof AccountPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * Request to activate currencies of a price plan
 * @export
 * @interface ActivatePricePlanRequest
 */
export interface ActivatePricePlanRequest {
    /**
     * List of currencies to activate
     * @type {Array<string>}
     * @memberof ActivatePricePlanRequest
     */
    'currencies': Array<string>;
}
/**
 * Payload to add aliases from account
 * @export
 * @interface AddAccountAliasesRequest
 */
export interface AddAccountAliasesRequest {
    /**
     * List of aliases to add
     * @type {Array<string>}
     * @memberof AddAccountAliasesRequest
     */
    'aliases'?: Array<string>;
}
/**
 * Request to adding currency to a price plan
 * @export
 * @interface AddCurrencyToPricePlanRequest
 */
export interface AddCurrencyToPricePlanRequest {
    /**
     * Currency to be added
     * @type {string}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'currency': string;
    /**
     * List of usage rates
     * @type {Array<UsageRate>}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'usageRates': Array<UsageRate>;
    /**
     * Rates for fixed fee rate cards
     * @type {Array<FixedFeeRate>}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'fixedFeeRates'?: Array<FixedFeeRate>;
    /**
     * Rates for minimum commitment.
     * @type {number}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'minimumCommitmentRate'?: number;
}
/**
 * 
 * @export
 * @interface AddOn
 */
export interface AddOn {
    /**
     * Name of addon
     * @type {string}
     * @memberof AddOn
     */
    'name': string;
    /**
     * Type of addon
     * @type {string}
     * @memberof AddOn
     */
    'type': AddOnTypeEnum;
    /**
     * Id of addon
     * @type {string}
     * @memberof AddOn
     */
    'id': string;
    /**
     * Created Time of addon
     * @type {string}
     * @memberof AddOn
     */
    'createdAt': string;
}

export const AddOnTypeEnum = {
    OneTime: 'ONE_TIME',
    Recurring: 'RECURRING'
} as const;

export type AddOnTypeEnum = typeof AddOnTypeEnum[keyof typeof AddOnTypeEnum];

/**
 * 
 * @export
 * @interface AddOnAllOf
 */
export interface AddOnAllOf {
    /**
     * Id of addon
     * @type {string}
     * @memberof AddOnAllOf
     */
    'id': string;
    /**
     * Created Time of addon
     * @type {string}
     * @memberof AddOnAllOf
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface AddOnPaginatedResponse
 */
export interface AddOnPaginatedResponse {
    /**
     * 
     * @type {Array<AddOn>}
     * @memberof AddOnPaginatedResponse
     */
    'data': Array<AddOn>;
    /**
     * 
     * @type {string}
     * @memberof AddOnPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof AddOnPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * Request to associate a price plan to an account
 * @export
 * @interface AssociatePricePlanRequest
 */
export interface AssociatePricePlanRequest {
    /**
     * Id of the price plan
     * @type {string}
     * @memberof AssociatePricePlanRequest
     */
    'pricePlanId': string;
    /**
     * Date of effectiveness of the association. - Expected only if the account already has a price plan associated with it. 
     * @type {string}
     * @memberof AssociatePricePlanRequest
     */
    'effectiveFrom': string;
    /**
     * Date until which the association must be effective. - Expected only if effectiveFrom is present. 
     * @type {string}
     * @memberof AssociatePricePlanRequest
     */
    'effectiveUntil': string;
    /**
     * 
     * @type {CreatePricePlanDetailsOverride}
     * @memberof AssociatePricePlanRequest
     */
    'pricePlanDetailsOverride'?: CreatePricePlanDetailsOverride;
}
/**
 * 
 * @export
 * @interface AssociatePricePlanResponse
 */
export interface AssociatePricePlanResponse {
    /**
     * Identifier of the account
     * @type {string}
     * @memberof AssociatePricePlanResponse
     */
    'accountId': string;
    /**
     * Name of the Account
     * @type {string}
     * @memberof AssociatePricePlanResponse
     */
    'accountName': string;
    /**
     * 
     * @type {Array<PlanOverride>}
     * @memberof AssociatePricePlanResponse
     */
    'pricingSchedules': Array<PlanOverride>;
}
/**
 * Metric to be recorded
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * Name of the event attribute
     * @type {string}
     * @memberof Attribute
     */
    'name': string;
    /**
     * Value of the event attribute
     * @type {string}
     * @memberof Attribute
     */
    'value': string;
    /**
     * Unit with which the attribute value was measured. Natively supported units - \"Meters, Miles, Kilometers, Grams, Kilograms, ounces, Pounds, Minutes, Hours, Seconds, Milliseconds, Microseconds, None\". Clients are free to add any other custom units.
     * @type {string}
     * @memberof Attribute
     */
    'unit'?: string;
}
/**
 * 
 * @export
 * @interface BaseSuccessResponse
 */
export interface BaseSuccessResponse {
    /**
     * 
     * @type {boolean}
     * @memberof BaseSuccessResponse
     */
    'success': boolean;
}
/**
 * Request to get revenue details
 * @export
 * @interface CalculateRevenueRequest
 */
export interface CalculateRevenueRequest {
    /**
     * 
     * @type {CurrencyConfig}
     * @memberof CalculateRevenueRequest
     */
    'currencyConfig': CurrencyConfig;
    /**
     * 
     * @type {PricePlanDetailsConfig}
     * @memberof CalculateRevenueRequest
     */
    'pricePlanDetailsConfig': PricePlanDetailsConfig;
    /**
     * 
     * @type {UsageConfig}
     * @memberof CalculateRevenueRequest
     */
    'usageConfig': UsageConfig;
}
/**
 * 
 * @export
 * @interface CalculateRevenueResponse
 */
export interface CalculateRevenueResponse {
    /**
     * 
     * @type {string}
     * @memberof CalculateRevenueResponse
     */
    'currency': string;
    /**
     * 
     * @type {PricePlanDetails}
     * @memberof CalculateRevenueResponse
     */
    'pricePlanDetails': PricePlanDetails;
    /**
     * 
     * @type {Array<RevenueInfo>}
     * @memberof CalculateRevenueResponse
     */
    'revenueInfo': Array<RevenueInfo>;
}
/**
 * 
 * @export
 * @interface Computation
 */
export interface Computation {
    /**
     * Optional identifier describing the matcher and computation pair
     * @type {string}
     * @memberof Computation
     */
    'id'?: string;
    /**
     * Condition to be applied on event. Upon matching it the corresponding computation will be considered for usage_meter unit calculation. The result of the matcher needs to be [truthy](https://jsonlogic.com/truthy.html) in order to be considered as a match. 
     * @type {string}
     * @memberof Computation
     */
    'matcher'?: string;
    /**
     * Computation to be applied on an event if it matches the matcher. In case of a COUNT aggregation type, computation should be passed as \'1\' 
     * @type {string}
     * @memberof Computation
     */
    'computation': string;
}
/**
 * 
 * @export
 * @interface ComputeRevenueSummaryRequest
 */
export interface ComputeRevenueSummaryRequest {
    /**
     * 
     * @type {Array<RevenueSummaryQuery>}
     * @memberof ComputeRevenueSummaryRequest
     */
    'revenueSummaryQueries': Array<RevenueSummaryQuery>;
}
/**
 * 
 * @export
 * @interface ComputeRevenueSummaryResponse
 */
export interface ComputeRevenueSummaryResponse {
    /**
     * 
     * @type {Array<RevenueSummaryResponse>}
     * @memberof ComputeRevenueSummaryResponse
     */
    'revenueSummaryResponses': Array<RevenueSummaryResponse>;
}
/**
 * Payload to create account
 * @export
 * @interface CreateAccountRequest
 */
export interface CreateAccountRequest {
    /**
     * Identifier of the account
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'id': string;
    /**
     * Name of the Account
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'name': string;
    /**
     * Use [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code in which the account must be invoiced.   For example: AED is the currency code for United Arab Emirates dirham. 
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'invoiceCurrency'?: string;
    /**
     * Aliases are tags that are associated with an account. Multiple aliases are allowed for a single account.
     * @type {Array<string>}
     * @memberof CreateAccountRequest
     */
    'aliases'?: Array<string>;
}
/**
 * Request to create an addon
 * @export
 * @interface CreateAddOnRequest
 */
export interface CreateAddOnRequest {
    /**
     * Name of addon
     * @type {string}
     * @memberof CreateAddOnRequest
     */
    'name': string;
    /**
     * Type of addon
     * @type {string}
     * @memberof CreateAddOnRequest
     */
    'type': CreateAddOnRequestTypeEnum;
}

export const CreateAddOnRequestTypeEnum = {
    OneTime: 'ONE_TIME',
    Recurring: 'RECURRING'
} as const;

export type CreateAddOnRequestTypeEnum = typeof CreateAddOnRequestTypeEnum[keyof typeof CreateAddOnRequestTypeEnum];

/**
 * Payload to grant Credits
 * @export
 * @interface CreateCreditRequest
 */
export interface CreateCreditRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCreditRequest
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCreditRequest
     */
    'purpose': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCreditRequest
     */
    'effectiveFrom': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCreditRequest
     */
    'effectiveUntil'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateCreditRequest
     */
    'creditAmount': number;
    /**
     * 
     * @type {number}
     * @memberof CreateCreditRequest
     */
    'priority'?: number;
}
/**
 * Payload to create customer
 * @export
 * @interface CreateCustomerRequest
 */
export interface CreateCustomerRequest {
    /**
     * Customer identifier
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'id': string;
    /**
     * Name of the Customer
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'name': string;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'primaryEmail': string;
    /**
     * billing address of the customer
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'billingAddress': string;
    /**
     * 
     * @type {CreateAccountRequest}
     * @memberof CreateCustomerRequest
     */
    'account'?: CreateAccountRequest;
}
/**
 * 
 * @export
 * @interface CreateCustomerResponse
 */
export interface CreateCustomerResponse {
    /**
     * Identifier of customer
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'id': string;
    /**
     * Name of the Customer
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'name': string;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'primaryEmail': string;
    /**
     * billing address of the customer
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'billingAddress': string;
    /**
     * 
     * @type {Account}
     * @memberof CreateCustomerResponse
     */
    'account'?: Account;
}
/**
 * Request to create event schema
 * @export
 * @interface CreateEventSchemaRequest
 */
export interface CreateEventSchemaRequest {
    /**
     * Name of the event. Must be unique for an organization.
     * @type {string}
     * @memberof CreateEventSchemaRequest
     */
    'name': string;
    /**
     * Description of the event
     * @type {string}
     * @memberof CreateEventSchemaRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<EventAttributeSchema>}
     * @memberof CreateEventSchemaRequest
     */
    'attributes': Array<EventAttributeSchema>;
    /**
     * 
     * @type {Array<DimensionsSchema>}
     * @memberof CreateEventSchemaRequest
     */
    'dimensions': Array<DimensionsSchema>;
}
/**
 * 
 * @export
 * @interface CreatePricePlanDetails
 */
export interface CreatePricePlanDetails {
    /**
     * 
     * @type {PricingCycleConfig}
     * @memberof CreatePricePlanDetails
     */
    'pricingCycleConfig': PricingCycleConfig;
    /**
     * List of currencies supported by the price plan
     * @type {Array<string>}
     * @memberof CreatePricePlanDetails
     */
    'supportedCurrencies': Array<string>;
    /**
     * List of usage rate cards
     * @type {Array<UsageRateCard>}
     * @memberof CreatePricePlanDetails
     */
    'usageRateCards'?: Array<UsageRateCard>;
    /**
     * 
     * @type {Array<FixedFeeRateCard>}
     * @memberof CreatePricePlanDetails
     */
    'fixedFeeRateCards'?: Array<FixedFeeRateCard>;
    /**
     * 
     * @type {MinimumCommitment}
     * @memberof CreatePricePlanDetails
     */
    'minimumCommitment'?: MinimumCommitment;
}
/**
 * 
 * @export
 * @interface CreatePricePlanDetailsOverride
 */
export interface CreatePricePlanDetailsOverride {
    /**
     * 
     * @type {PricingCycleConfig}
     * @memberof CreatePricePlanDetailsOverride
     */
    'pricingCycleConfig'?: PricingCycleConfig;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreatePricePlanDetailsOverride
     */
    'supportedCurrencies'?: Array<string>;
    /**
     * 
     * @type {Array<UsageRateCard>}
     * @memberof CreatePricePlanDetailsOverride
     */
    'usageRateCards'?: Array<UsageRateCard>;
    /**
     * 
     * @type {Array<FixedFeeRateCard>}
     * @memberof CreatePricePlanDetailsOverride
     */
    'fixedFeeRateCards'?: Array<FixedFeeRateCard>;
    /**
     * 
     * @type {MinimumCommitment}
     * @memberof CreatePricePlanDetailsOverride
     */
    'minimumCommitment'?: MinimumCommitment;
}
/**
 * Request to create a price plan
 * @export
 * @interface CreatePricePlanRequest
 */
export interface CreatePricePlanRequest {
    /**
     * Name of the price plan
     * @type {string}
     * @memberof CreatePricePlanRequest
     */
    'name': string;
    /**
     * Description of price plan
     * @type {string}
     * @memberof CreatePricePlanRequest
     */
    'description'?: string;
    /**
     * 
     * @type {CreatePricePlanDetails}
     * @memberof CreatePricePlanRequest
     */
    'pricePlanDetails': CreatePricePlanDetails;
}
/**
 * Request to create usage meter
 * @export
 * @interface CreateUsageMeterRequest
 */
export interface CreateUsageMeterRequest {
    /**
     * Name of the event. Must be unique for an organization.
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'name': string;
    /**
     * Description of the event
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'description'?: string;
    /**
     * Type of usage meter
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'type': CreateUsageMeterRequestTypeEnum;
    /**
     * Aggregation to be applied on usage meter result
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'aggregation': CreateUsageMeterRequestAggregationEnum;
    /**
     * 
     * @type {Array<Computation>}
     * @memberof CreateUsageMeterRequest
     */
    'computations'?: Array<Computation>;
}

export const CreateUsageMeterRequestTypeEnum = {
    Counter: 'COUNTER'
} as const;

export type CreateUsageMeterRequestTypeEnum = typeof CreateUsageMeterRequestTypeEnum[keyof typeof CreateUsageMeterRequestTypeEnum];
export const CreateUsageMeterRequestAggregationEnum = {
    Count: 'COUNT',
    Sum: 'SUM'
} as const;

export type CreateUsageMeterRequestAggregationEnum = typeof CreateUsageMeterRequestAggregationEnum[keyof typeof CreateUsageMeterRequestAggregationEnum];

/**
 * 
 * @export
 * @interface Credit
 */
export interface Credit {
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'purpose': string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'effectiveFrom': string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'effectiveUntil'?: string;
    /**
     * 
     * @type {number}
     * @memberof Credit
     */
    'creditAmount': number;
    /**
     * 
     * @type {number}
     * @memberof Credit
     */
    'priority'?: number;
    /**
     * Identifier of credits
     * @type {string}
     * @memberof Credit
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'customerId': string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'status': CreditStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'creditUnit'?: string;
    /**
     * 
     * @type {number}
     * @memberof Credit
     */
    'holdAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Credit
     */
    'consumedAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'updatedAt'?: string;
}

export const CreditStatusEnum = {
    Active: 'ACTIVE',
    Consumed: 'CONSUMED',
    Expired: 'EXPIRED',
    Voided: 'VOIDED'
} as const;

export type CreditStatusEnum = typeof CreditStatusEnum[keyof typeof CreditStatusEnum];

/**
 * 
 * @export
 * @interface CreditAllOf
 */
export interface CreditAllOf {
    /**
     * Identifier of credits
     * @type {string}
     * @memberof CreditAllOf
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreditAllOf
     */
    'customerId': string;
    /**
     * 
     * @type {string}
     * @memberof CreditAllOf
     */
    'status': CreditAllOfStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CreditAllOf
     */
    'creditUnit'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditAllOf
     */
    'holdAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreditAllOf
     */
    'consumedAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreditAllOf
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CreditAllOf
     */
    'updatedAt'?: string;
}

export const CreditAllOfStatusEnum = {
    Active: 'ACTIVE',
    Consumed: 'CONSUMED',
    Expired: 'EXPIRED',
    Voided: 'VOIDED'
} as const;

export type CreditAllOfStatusEnum = typeof CreditAllOfStatusEnum[keyof typeof CreditAllOfStatusEnum];

/**
 * Credit Balance response
 * @export
 * @interface CreditBalanceResponse
 */
export interface CreditBalanceResponse {
    /**
     * 
     * @type {number}
     * @memberof CreditBalanceResponse
     */
    'activeCredits': number;
    /**
     * 
     * @type {number}
     * @memberof CreditBalanceResponse
     */
    'availableBalance': number;
    /**
     * 
     * @type {number}
     * @memberof CreditBalanceResponse
     */
    'runningBalance': number;
    /**
     * 
     * @type {number}
     * @memberof CreditBalanceResponse
     */
    'inapplicableCredits': number;
    /**
     * 
     * @type {string}
     * @memberof CreditBalanceResponse
     */
    'unit': string;
}
/**
 * 
 * @export
 * @interface CreditDetailsResponse
 */
export interface CreditDetailsResponse {
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'purpose': string;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'effectiveFrom': string;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'effectiveUntil'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditDetailsResponse
     */
    'creditAmount': number;
    /**
     * 
     * @type {number}
     * @memberof CreditDetailsResponse
     */
    'priority'?: number;
    /**
     * Identifier of credits
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'customerId': string;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'status': CreditDetailsResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'creditUnit'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditDetailsResponse
     */
    'holdAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreditDetailsResponse
     */
    'consumedAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {Array<CreditTransaction>}
     * @memberof CreditDetailsResponse
     */
    'transactions': Array<CreditTransaction>;
}

export const CreditDetailsResponseStatusEnum = {
    Active: 'ACTIVE',
    Consumed: 'CONSUMED',
    Expired: 'EXPIRED',
    Voided: 'VOIDED'
} as const;

export type CreditDetailsResponseStatusEnum = typeof CreditDetailsResponseStatusEnum[keyof typeof CreditDetailsResponseStatusEnum];

/**
 * 
 * @export
 * @interface CreditDetailsResponseAllOf
 */
export interface CreditDetailsResponseAllOf {
    /**
     * 
     * @type {Array<CreditTransaction>}
     * @memberof CreditDetailsResponseAllOf
     */
    'transactions': Array<CreditTransaction>;
}
/**
 * 
 * @export
 * @interface CreditTransaction
 */
export interface CreditTransaction {
    /**
     * Identifier of credit transactions
     * @type {string}
     * @memberof CreditTransaction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreditTransaction
     */
    'creditId': string;
    /**
     * 
     * @type {string}
     * @memberof CreditTransaction
     */
    'transactionType': CreditTransactionTransactionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreditTransaction
     */
    'invoiceId'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditTransaction
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreditTransaction
     */
    'createdAt': string;
}

export const CreditTransactionTransactionTypeEnum = {
    Credited: 'CREDITED',
    Debited: 'DEBITED',
    Expired: 'EXPIRED',
    Voided: 'VOIDED'
} as const;

export type CreditTransactionTransactionTypeEnum = typeof CreditTransactionTransactionTypeEnum[keyof typeof CreditTransactionTransactionTypeEnum];

/**
 * Configuration for getting the currency
 * @export
 * @interface CurrencyConfig
 */
export interface CurrencyConfig {
    /**
     * Mode to get the currency - CUSTOM: Use the currency provided in the request - ACCOUNT_INVOICE: Use the invoice currency of the given account 
     * @type {string}
     * @memberof CurrencyConfig
     */
    'mode': CurrencyConfigModeEnum;
    /**
     * Currency to be used, this will be considered if mode is CUSTOM
     * @type {string}
     * @memberof CurrencyConfig
     */
    'currency'?: string;
    /**
     * Id of the account of which invoice currency will be used, this will be considered if mode is ACCOUNT_INVOICE
     * @type {string}
     * @memberof CurrencyConfig
     */
    'accountId'?: string;
}

export const CurrencyConfigModeEnum = {
    Custom: 'CUSTOM',
    AccountInvoice: 'ACCOUNT_INVOICE'
} as const;

export type CurrencyConfigModeEnum = typeof CurrencyConfigModeEnum[keyof typeof CurrencyConfigModeEnum];

/**
 * 
 * @export
 * @interface CurrencyRateValue
 */
export interface CurrencyRateValue {
    /**
     * 
     * @type {string}
     * @memberof CurrencyRateValue
     */
    'currency': string;
    /**
     * 
     * @type {number}
     * @memberof CurrencyRateValue
     */
    'rate': number;
}
/**
 * Structure of customer
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * Identifier of customer
     * @type {string}
     * @memberof Customer
     */
    'id': string;
    /**
     * Name of the Customer
     * @type {string}
     * @memberof Customer
     */
    'name': string;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof Customer
     */
    'primaryEmail': string;
    /**
     * billing address of the customer
     * @type {string}
     * @memberof Customer
     */
    'billingAddress': string;
    /**
     * Status of the customer
     * @type {string}
     * @memberof Customer
     */
    'status': CustomerStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'updatedAt': string;
}

export const CustomerStatusEnum = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type CustomerStatusEnum = typeof CustomerStatusEnum[keyof typeof CustomerStatusEnum];

/**
 * 
 * @export
 * @interface CustomerPaginatedResponse
 */
export interface CustomerPaginatedResponse {
    /**
     * 
     * @type {Array<Customer>}
     * @memberof CustomerPaginatedResponse
     */
    'data'?: Array<Customer>;
    /**
     * 
     * @type {string}
     * @memberof CustomerPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof CustomerPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * Structure of dimensions
 * @export
 * @interface DimensionsSchema
 */
export interface DimensionsSchema {
    /**
     * Name of the event dimension
     * @type {string}
     * @memberof DimensionsSchema
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * error description
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
}
/**
 * Contents of the event
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * Name of the Event Schema.  Know more about [event schema](https://docs.togai.com/docs/event-schemas) 
     * @type {string}
     * @memberof Event
     */
    'schemaName': string;
    /**
     * A unique value to identify the event instance. This unique value should be generated by the client and it acts as the **idempotency key**. Togai server will use this key to recognize subsequent retries of the same request and avoid metering multiple times for that same request. This id can be created in any format but we recommend using UUIDv4 to reduce collision occurance.    NOTE1: Expiry time for idempotency validation will be until the end of the billing cycle. Any request which comes after the billing cycle with the same id will be treated as new request and ingested for metering.   NOTE2: If the billing cycle is not configured for the idempotency validation will be until **10 days** of the event ingestion.
     * @type {string}
     * @memberof Event
     */
    'id': string;
    /**
     * Source time stamp of the event. This timestamp must be in ISO 8601 format.
     * @type {string}
     * @memberof Event
     */
    'timestamp': string;
    /**
     * The event will be associated with the provided account
     * @type {string}
     * @memberof Event
     */
    'accountId': string;
    /**
     * Attributes are numeric values. It can be usage metric which you push to Togai
     * @type {Array<Attribute>}
     * @memberof Event
     */
    'attributes': Array<Attribute>;
    /**
     * Dimensions are tags/labels associated with the events.
     * @type {{ [key: string]: string; }}
     * @memberof Event
     */
    'dimensions': { [key: string]: string; };
}
/**
 * Structure of an event attribute
 * @export
 * @interface EventAttributeSchema
 */
export interface EventAttributeSchema {
    /**
     * Name of the event attribute.
     * @type {string}
     * @memberof EventAttributeSchema
     */
    'name': string;
    /**
     * Unit for the attribute
     * @type {string}
     * @memberof EventAttributeSchema
     */
    'defaultUnit'?: string;
}
/**
 * Information related to ingestion of an event
 * @export
 * @interface EventPipelineInfo
 */
export interface EventPipelineInfo {
    /**
     * 
     * @type {EventPipelineInfoEventSchema}
     * @memberof EventPipelineInfo
     */
    'eventSchema'?: EventPipelineInfoEventSchema;
    /**
     * 
     * @type {Array<EventPipelineInfoUsageMeters>}
     * @memberof EventPipelineInfo
     */
    'usageMeters'?: Array<EventPipelineInfoUsageMeters>;
    /**
     * 
     * @type {Array<EventPipelineInfoPricePlans>}
     * @memberof EventPipelineInfo
     */
    'pricePlans'?: Array<EventPipelineInfoPricePlans>;
    /**
     * 
     * @type {EventPipelineInfoAccount}
     * @memberof EventPipelineInfo
     */
    'account'?: EventPipelineInfoAccount;
    /**
     * 
     * @type {EventPipelineInfoCustomer}
     * @memberof EventPipelineInfo
     */
    'customer'?: EventPipelineInfoCustomer;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoAccount
 */
export interface EventPipelineInfoAccount {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoAccount
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoAccount
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoCustomer
 */
export interface EventPipelineInfoCustomer {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoCustomer
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoCustomer
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoEventSchema
 */
export interface EventPipelineInfoEventSchema {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoEventSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof EventPipelineInfoEventSchema
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoPricePlans
 */
export interface EventPipelineInfoPricePlans {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlans
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlans
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlans
     */
    'scheduleId': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlans
     */
    'cycleStart': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlans
     */
    'cycleEnd': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventPipelineInfoPricePlans
     */
    'usageMeters'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoUsageMeters
 */
export interface EventPipelineInfoUsageMeters {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoUsageMeters
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoUsageMeters
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof EventPipelineInfoUsageMeters
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoUsageMeters
     */
    'status': EventPipelineInfoUsageMetersStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof EventPipelineInfoUsageMeters
     */
    'units'?: number;
}

export const EventPipelineInfoUsageMetersStatusEnum = {
    FilteredOut: 'PROCESSED_FILTERED_OUT',
    UnitsComputed: 'PROCESSED_UNITS_COMPUTED'
} as const;

export type EventPipelineInfoUsageMetersStatusEnum = typeof EventPipelineInfoUsageMetersStatusEnum[keyof typeof EventPipelineInfoUsageMetersStatusEnum];

/**
 * Structure of an event schema
 * @export
 * @interface EventSchema
 */
export interface EventSchema {
    /**
     * Name of the event. Must be unique for an organization.
     * @type {string}
     * @memberof EventSchema
     */
    'name': string;
    /**
     * Description of the event
     * @type {string}
     * @memberof EventSchema
     */
    'description'?: string;
    /**
     * Version of event schema
     * @type {number}
     * @memberof EventSchema
     */
    'version': number;
    /**
     * Status of event schema * DRAFT - Schema is in draft state  * ACTIVE - Schema is currently active  * INACTIVE - Schema is currently inactive * ARCHIVED - Older version of event schema 
     * @type {string}
     * @memberof EventSchema
     */
    'status'?: EventSchemaStatusEnum;
    /**
     * 
     * @type {Array<EventAttributeSchema>}
     * @memberof EventSchema
     */
    'attributes': Array<EventAttributeSchema>;
    /**
     * 
     * @type {Array<DimensionsSchema>}
     * @memberof EventSchema
     */
    'dimensions'?: Array<DimensionsSchema>;
    /**
     * 
     * @type {string}
     * @memberof EventSchema
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSchema
     */
    'updatedAt'?: string;
}

export const EventSchemaStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type EventSchemaStatusEnum = typeof EventSchemaStatusEnum[keyof typeof EventSchemaStatusEnum];

/**
 * 
 * @export
 * @interface EventSchemaListData
 */
export interface EventSchemaListData {
    /**
     * Name of the event. Must be unique for an organization.
     * @type {string}
     * @memberof EventSchemaListData
     */
    'name': string;
    /**
     * Description of the event
     * @type {string}
     * @memberof EventSchemaListData
     */
    'description'?: string;
    /**
     * Version of event schema
     * @type {number}
     * @memberof EventSchemaListData
     */
    'version': number;
    /**
     * Status of event schema * DRAFT - Schema is in draft state  * ACTIVE - Schema is currently active  * INACTIVE - Schema is currently inactive * ARCHIVED - Older version of event schema 
     * @type {string}
     * @memberof EventSchemaListData
     */
    'status'?: EventSchemaListDataStatusEnum;
    /**
     * 
     * @type {Array<EventAttributeSchema>}
     * @memberof EventSchemaListData
     */
    'attributes': Array<EventAttributeSchema>;
    /**
     * 
     * @type {Array<DimensionsSchema>}
     * @memberof EventSchemaListData
     */
    'dimensions'?: Array<DimensionsSchema>;
    /**
     * 
     * @type {string}
     * @memberof EventSchemaListData
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSchemaListData
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventSchemaListData
     */
    'usageMetersCount'?: number;
}

export const EventSchemaListDataStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type EventSchemaListDataStatusEnum = typeof EventSchemaListDataStatusEnum[keyof typeof EventSchemaListDataStatusEnum];

/**
 * 
 * @export
 * @interface EventSchemaListDataAllOf
 */
export interface EventSchemaListDataAllOf {
    /**
     * 
     * @type {number}
     * @memberof EventSchemaListDataAllOf
     */
    'usageMetersCount'?: number;
}
/**
 * 
 * @export
 * @interface EventSchemaListPaginatedResponse
 */
export interface EventSchemaListPaginatedResponse {
    /**
     * 
     * @type {Array<EventSchemaListData>}
     * @memberof EventSchemaListPaginatedResponse
     */
    'data'?: Array<EventSchemaListData>;
    /**
     * 
     * @type {string}
     * @memberof EventSchemaListPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof EventSchemaListPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * Response for event schema versions
 * @export
 * @interface EventSchemaVersionsResponse
 */
export interface EventSchemaVersionsResponse {
    /**
     * 
     * @type {Array<EventSchema>}
     * @memberof EventSchemaVersionsResponse
     */
    'data': Array<EventSchema>;
}
/**
 * Raw usage event ingested by the business team and the status of the event ingestion.
 * @export
 * @interface EventWithStatus
 */
export interface EventWithStatus {
    /**
     * 
     * @type {Event}
     * @memberof EventWithStatus
     */
    'eventPayload': Event;
    /**
     * 
     * @type {IngestionStatus}
     * @memberof EventWithStatus
     */
    'ingestionStatus': IngestionStatus;
    /**
     * The associated account belongs to this customer
     * @type {string}
     * @memberof EventWithStatus
     */
    'customerId'?: string;
}
/**
 * 
 * @export
 * @interface EventWithStatusAndEventPipelineInfo
 */
export interface EventWithStatusAndEventPipelineInfo {
    /**
     * 
     * @type {Event}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'eventPayload': Event;
    /**
     * 
     * @type {IngestionStatus}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'ingestionStatus': IngestionStatus;
    /**
     * The associated account belongs to this customer
     * @type {string}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'customerId'?: string;
    /**
     * 
     * @type {EventPipelineInfo}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'EventPipelineInfo'?: EventPipelineInfo;
}
/**
 * 
 * @export
 * @interface EventWithStatusAndEventPipelineInfoAllOf
 */
export interface EventWithStatusAndEventPipelineInfoAllOf {
    /**
     * 
     * @type {EventPipelineInfo}
     * @memberof EventWithStatusAndEventPipelineInfoAllOf
     */
    'EventPipelineInfo'?: EventPipelineInfo;
}
/**
 * 
 * @export
 * @interface FixedFeeRate
 */
export interface FixedFeeRate {
    /**
     * 
     * @type {string}
     * @memberof FixedFeeRate
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof FixedFeeRate
     */
    'rate': number;
}
/**
 * 
 * @export
 * @interface FixedFeeRateCard
 */
export interface FixedFeeRateCard {
    /**
     * Auto generated unique identifier for fixed fees.
     * @type {string}
     * @memberof FixedFeeRateCard
     */
    'id': string;
    /**
     * Name of the fixed fee.
     * @type {string}
     * @memberof FixedFeeRateCard
     */
    'displayName'?: string;
    /**
     * 
     * @type {Array<CurrencyRateValue>}
     * @memberof FixedFeeRateCard
     */
    'rateValues': Array<CurrencyRateValue>;
}
/**
 * Get single event response
 * @export
 * @interface GetEventResponse
 */
export interface GetEventResponse {
    /**
     * 
     * @type {Array<EventWithStatusAndEventPipelineInfo>}
     * @memberof GetEventResponse
     */
    'events': Array<EventWithStatusAndEventPipelineInfo>;
}
/**
 * Get batch events response
 * @export
 * @interface GetEventsResponse
 */
export interface GetEventsResponse {
    /**
     * 
     * @type {Array<EventWithStatus>}
     * @memberof GetEventsResponse
     */
    'events': Array<EventWithStatus>;
    /**
     * 
     * @type {string}
     * @memberof GetEventsResponse
     */
    'nextToken'?: string;
}
/**
 * Request to get metrics from togai
 * @export
 * @interface GetMetricsRequest
 */
export interface GetMetricsRequest {
    /**
     * 
     * @type {string}
     * @memberof GetMetricsRequest
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof GetMetricsRequest
     */
    'endTime': string;
    /**
     * 
     * @type {Array<MetricQuery>}
     * @memberof GetMetricsRequest
     */
    'metricQueries': Array<MetricQuery>;
}
/**
 * Response to GetMetrics Request
 * @export
 * @interface GetMetricsResponse
 */
export interface GetMetricsResponse {
    /**
     * 
     * @type {Array<MetricQueryResponse>}
     * @memberof GetMetricsResponse
     */
    'results': Array<MetricQueryResponse>;
}
/**
 * Payload for ingesting batch events
 * @export
 * @interface IngestBatchEventRequest
 */
export interface IngestBatchEventRequest {
    /**
     * 
     * @type {Array<Event>}
     * @memberof IngestBatchEventRequest
     */
    'events': Array<Event>;
}
/**
 * 
 * @export
 * @interface IngestBatchEventResponse
 */
export interface IngestBatchEventResponse {
    /**
     * 
     * @type {Array<IngestError>}
     * @memberof IngestBatchEventResponse
     */
    'errors': Array<IngestError>;
}
/**
 * 
 * @export
 * @interface IngestError
 */
export interface IngestError {
    /**
     * 
     * @type {string}
     * @memberof IngestError
     */
    'message'?: string;
    /**
     * 
     * @type {Event}
     * @memberof IngestError
     */
    'eventPayload'?: Event;
}
/**
 * Payload for ingesting events
 * @export
 * @interface IngestEventRequest
 */
export interface IngestEventRequest {
    /**
     * 
     * @type {Event}
     * @memberof IngestEventRequest
     */
    'event'?: Event;
}
/**
 * 
 * @export
 * @interface IngestEventResponse
 */
export interface IngestEventResponse {
    /**
     * On successful ingestion acceptance request, ingestion request id will be returned. This ingestion id can be used by clients to query the status of ingestion (IN_PROGRESS, COMPLETED).
     * @type {string}
     * @memberof IngestEventResponse
     */
    'ingestionRequestId': string;
}
/**
 * Status about the event ingestion.
 * @export
 * @interface IngestionStatus
 */
export interface IngestionStatus {
    /**
     * Ingestion status
     * @type {string}
     * @memberof IngestionStatus
     */
    'status': IngestionStatusStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof IngestionStatus
     */
    'statusDescription'?: string;
}

export const IngestionStatusStatusEnum = {
    IngestionInProgress: 'INGESTION_IN_PROGRESS',
    IngestionFailed: 'INGESTION_FAILED',
    IngestionFailedSchemaNotDefined: 'INGESTION_FAILED_SCHEMA_NOT_DEFINED',
    IngestionFailedUnitsInvalid: 'INGESTION_FAILED_UNITS_INVALID',
    IngestionFailedEventInvalid: 'INGESTION_FAILED_EVENT_INVALID',
    IngestionCompletedNoMatchingMeters: 'INGESTION_COMPLETED_NO_MATCHING_METERS',
    IngestionCompletedEventMetered: 'INGESTION_COMPLETED_EVENT_METERED',
    IngestionCompletedEventNotMetered: 'INGESTION_COMPLETED_EVENT_NOT_METERED',
    Unknown: 'UNKNOWN'
} as const;

export type IngestionStatusStatusEnum = typeof IngestionStatusStatusEnum[keyof typeof IngestionStatusStatusEnum];

/**
 * 
 * @export
 * @interface InternalFixedFeeRateCard
 */
export interface InternalFixedFeeRateCard {
    /**
     * 
     * @type {string}
     * @memberof InternalFixedFeeRateCard
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InternalFixedFeeRateCard
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof InternalFixedFeeRateCard
     */
    'currency': string;
    /**
     * 
     * @type {number}
     * @memberof InternalFixedFeeRateCard
     */
    'rate': number;
}
/**
 * 
 * @export
 * @interface InternalSlab
 */
export interface InternalSlab {
    /**
     * 
     * @type {number}
     * @memberof InternalSlab
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof InternalSlab
     */
    'startAfter': number;
    /**
     * 
     * @type {PriceType}
     * @memberof InternalSlab
     */
    'priceType': PriceType;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InternalSlab
     */
    'slabConfig'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof InternalSlab
     */
    'rate': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InternalSlab
     */
    'slabRateConfig'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof InternalSlab
     */
    'endAt'?: number;
}
/**
 * 
 * @export
 * @interface InternalSlabAllOf
 */
export interface InternalSlabAllOf {
    /**
     * 
     * @type {number}
     * @memberof InternalSlabAllOf
     */
    'endAt'?: number;
}
/**
 * 
 * @export
 * @interface InternalUsageRateCard
 */
export interface InternalUsageRateCard {
    /**
     * 
     * @type {string}
     * @memberof InternalUsageRateCard
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InternalUsageRateCard
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof InternalUsageRateCard
     */
    'usageMeterId': string;
    /**
     * 
     * @type {PricingModel}
     * @memberof InternalUsageRateCard
     */
    'pricingModel': PricingModel;
    /**
     * 
     * @type {string}
     * @memberof InternalUsageRateCard
     */
    'currency': string;
    /**
     * 
     * @type {Array<InternalSlab>}
     * @memberof InternalUsageRateCard
     */
    'internalSlabs': Array<InternalSlab>;
}
/**
 * Structure of invoice
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * Identifier of customer
     * @type {string}
     * @memberof Invoice
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'customerId': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'pricePlanId': string;
    /**
     * 
     * @type {Array<InvoiceLineItem>}
     * @memberof Invoice
     */
    'usageInfo'?: Array<InvoiceLineItem>;
    /**
     * 
     * @type {InvoiceLineItem}
     * @memberof Invoice
     */
    'revenueInfo'?: InvoiceLineItem;
    /**
     * 
     * @type {InvoiceDetails}
     * @memberof Invoice
     */
    'invoiceDetails'?: InvoiceDetails;
    /**
     * Status of the invoice
     * @type {string}
     * @memberof Invoice
     */
    'status': InvoiceStatusEnum;
    /**
     * Start date of the invoice
     * @type {string}
     * @memberof Invoice
     */
    'startDate': string;
    /**
     * End date of the invoice
     * @type {string}
     * @memberof Invoice
     */
    'endDate': string;
    /**
     * Invoice date of the invoice
     * @type {string}
     * @memberof Invoice
     */
    'invoiceDate': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'generatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'updatedAt': string;
}

export const InvoiceStatusEnum = {
    Ongoing: 'ONGOING',
    GracePeriod: 'GRACE_PERIOD',
    Generated: 'GENERATED',
    Published: 'PUBLISHED'
} as const;

export type InvoiceStatusEnum = typeof InvoiceStatusEnum[keyof typeof InvoiceStatusEnum];

/**
 * 
 * @export
 * @interface InvoiceDetails
 */
export interface InvoiceDetails {
    /**
     * 
     * @type {InvoiceDetailsCustomer}
     * @memberof InvoiceDetails
     */
    'customer': InvoiceDetailsCustomer;
    /**
     * 
     * @type {InvoiceDetailsAccount}
     * @memberof InvoiceDetails
     */
    'account': InvoiceDetailsAccount;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetails
     */
    'pricePlanName': string;
}
/**
 * 
 * @export
 * @interface InvoiceDetailsAccount
 */
export interface InvoiceDetailsAccount {
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsAccount
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsAccount
     */
    'invoiceCurrency': string;
}
/**
 * 
 * @export
 * @interface InvoiceDetailsCustomer
 */
export interface InvoiceDetailsCustomer {
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsCustomer
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsCustomer
     */
    'primaryEmail': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsCustomer
     */
    'billingAddress': string;
}
/**
 * 
 * @export
 * @interface InvoiceLineItem
 */
export interface InvoiceLineItem {
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineItem
     */
    'description': string;
    /**
     * Type of the line item - TOTAL_USAGE: List of all the usage meter usages - USAGE_METER_USAGE: A single usage meter usage - NET_REVENUE: Net revenue of the invoice ( Gross revenue - Discounts ) - GROSS_REVENUE: Gross revenue of the invoice  - USAGE_RATE_CARD_REVENUE: Revenue generated from usage rate card - USAGE_RATE_CARD_SLAB_REVENUE: Revenue generated from usage rate card slab 
     * @type {string}
     * @memberof InvoiceLineItem
     */
    'type': string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLineItem
     */
    'valuePerQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLineItem
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineItem
     */
    'units'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLineItem
     */
    'value'?: number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof InvoiceLineItem
     */
    'metadata'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<InvoiceLineItem>}
     * @memberof InvoiceLineItem
     */
    'lineItems': Array<InvoiceLineItem>;
}
/**
 * List credits response
 * @export
 * @interface ListCreditsResponse
 */
export interface ListCreditsResponse {
    /**
     * 
     * @type {Array<Credit>}
     * @memberof ListCreditsResponse
     */
    'data': Array<Credit>;
    /**
     * 
     * @type {string}
     * @memberof ListCreditsResponse
     */
    'nextToken'?: string;
}
/**
 * List invoices response
 * @export
 * @interface ListInvoicesResponse
 */
export interface ListInvoicesResponse {
    /**
     * 
     * @type {Array<Invoice>}
     * @memberof ListInvoicesResponse
     */
    'data': Array<Invoice>;
    /**
     * 
     * @type {string}
     * @memberof ListInvoicesResponse
     */
    'nextToken'?: string;
}
/**
 * 
 * @export
 * @interface MetricDataPoints
 */
export interface MetricDataPoints {
    /**
     * 
     * @type {MetricDataPointsGroupedBy}
     * @memberof MetricDataPoints
     */
    'groupedBy'?: MetricDataPointsGroupedBy;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetricDataPoints
     */
    'timestamps': Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof MetricDataPoints
     */
    'metricValues': Array<number>;
}
/**
 * 
 * @export
 * @interface MetricDataPointsGroupedBy
 */
export interface MetricDataPointsGroupedBy {
    /**
     * 
     * @type {string}
     * @memberof MetricDataPointsGroupedBy
     */
    'fieldName': string;
    /**
     * 
     * @type {string}
     * @memberof MetricDataPointsGroupedBy
     */
    'fieldValue': string;
}
/**
 * Define the metric you would like to get - allowed options are EVENTS - Aggregation of raw events, USAGE - Aggregated usage value from Usage meters, REVENUE - Aggregated of revenue value from Pricing Plans 
 * @export
 * @enum {string}
 */

export const MetricName = {
    Events: 'EVENTS',
    Usage: 'USAGE',
    Revenue: 'REVENUE'
} as const;

export type MetricName = typeof MetricName[keyof typeof MetricName];


/**
 * Object representing a single metrics query
 * @export
 * @interface MetricQuery
 */
export interface MetricQuery {
    /**
     * Mandatory  for all request.  User defined ID for identifying the request for your internal reference 
     * @type {string}
     * @memberof MetricQuery
     */
    'id': string;
    /**
     * 
     * @type {MetricName}
     * @memberof MetricQuery
     */
    'name': MetricName;
    /**
     * Set the aggregation period. Allowed periods are DAY, WEEK, MONTH
     * @type {string}
     * @memberof MetricQuery
     */
    'aggregationPeriod': MetricQueryAggregationPeriodEnum;
    /**
     * Group your metric with a groupBy field.  Allowed fields are  ACCOUNT_ID EVENT_STATUS  SCHEMA_NAME  USAGE_METER_ID  Please refer the table above for the list of combinations allowed in the groupBy 
     * @type {string}
     * @memberof MetricQuery
     */
    'groupBy'?: string;
    /**
     * Configurations. | Metric Name | Config Key | Allowed Values  | Default value |              Description          | |-------------|------------|-----------------|---------------|-----------------------------------| | REVENUE     | CURRENCY   | BASE or INVOICE | BASE          | currency to return the revenue in | 
     * @type {{ [key: string]: string; }}
     * @memberof MetricQuery
     */
    'configs'?: { [key: string]: string; };
    /**
     * Filter on specific fields.  Refer possible fieldNames and fieldValues from the table above. 
     * @type {Array<MetricQueryFilterEntry>}
     * @memberof MetricQuery
     */
    'filters'?: Array<MetricQueryFilterEntry>;
}

export const MetricQueryAggregationPeriodEnum = {
    Day: 'DAY',
    Week: 'WEEK',
    Month: 'MONTH'
} as const;

export type MetricQueryAggregationPeriodEnum = typeof MetricQueryAggregationPeriodEnum[keyof typeof MetricQueryAggregationPeriodEnum];

/**
 *  | Metric Name | FilterEntry Name |    Allowed groupBy fields                 |      Default Values      |                 Allowed Values                  | |-------------|------------------|-------------------------------------------|--------------------------|-------------------------------------------------| | EVENTS      | ACCOUNT_ID       | ACCOUNT_ID, EVENT_STATUS, SCHEMA_NAME,    | None                     | *\\<one or more valid account IDs>               |                                    CUSTOMER_ID                                                                                                            | | EVENTS      | CUSTOMER_ID      | ACCOUNT_ID, EVENT_STATUS, SCHEMA_NAME,    | None                     | *\\<one or more valid customer IDs>              |                                    CUSTOMER_ID                                                                                                            | | EVENTS      | SCHEMA_NAME      | ACCOUNT_ID, EVENT_STATUS, SCHEMA_NAME,    | None                     | *\\<at most one valid schema names>              |                                    CUSTOMER_ID                                                                                                            | | EVENTS      | EVENT_STATUS     | ACCOUNT_ID, EVENT_STATUS, SCHEMA_NAME,    | [PROCESSED, UNPROCESSED] | oneOrMoreOf PROCESSED, UNPROCESSED, IN_PROGRESS |                                    CUSTOMER_ID                                                                                                            | | USAGE       | ACCOUNT_ID       | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | None                     | *\\<one or more valid account IDs>               | | USAGE       | CUSTOMER_ID      | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | None                     | *\\<one or more valid customer IDs>              | | USAGE       | USAGE_METER_ID   | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | None                     | *\\<one or more valid usage meter name>          | | REVENUE     | ACCOUNT_ID       | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | None                     | *\\<one or more valid account IDs>               | | REVENUE     | CUSTOMER_ID      | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | None                     | *\\<one or more valid customer IDs>              | | REVENUE     | USAGE_METER_ID   | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | None                     | *\\<one or more valid usage meter name>          | | EVENTS      | ORGANIZATION_ID  | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | <From auth token>        |                                                 | | USAGE       | ORGANIZATION_ID  | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | <From auth token>        |                                                 | | REVENUE     | ORGANIZATION_ID  | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | <From auth token>        |                                                 | 
 * @export
 * @interface MetricQueryFilterEntry
 */
export interface MetricQueryFilterEntry {
    /**
     * 
     * @type {string}
     * @memberof MetricQueryFilterEntry
     */
    'fieldName': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetricQueryFilterEntry
     */
    'fieldValues': Array<string>;
}
/**
 * Response to GetMetrics Request
 * @export
 * @interface MetricQueryResponse
 */
export interface MetricQueryResponse {
    /**
     * 
     * @type {string}
     * @memberof MetricQueryResponse
     */
    'id': string;
    /**
     * 
     * @type {MetricName}
     * @memberof MetricQueryResponse
     */
    'name': MetricName;
    /**
     * 
     * @type {Array<MetricDataPoints>}
     * @memberof MetricQueryResponse
     */
    'data': Array<MetricDataPoints>;
}
/**
 * 
 * @export
 * @interface MinimumCommitment
 */
export interface MinimumCommitment {
    /**
     * 
     * @type {string}
     * @memberof MinimumCommitment
     */
    'displayName': string;
    /**
     * 
     * @type {Array<CurrencyRateValue>}
     * @memberof MinimumCommitment
     */
    'rateValues': Array<CurrencyRateValue>;
}
/**
 * 
 * @export
 * @interface OrganizationSetting
 */
export interface OrganizationSetting {
    /**
     * Base currency of the organization
     * @type {string}
     * @memberof OrganizationSetting
     */
    'baseCurrency'?: string;
}
/**
 * 
 * @export
 * @interface PaginationOptions
 */
export interface PaginationOptions {
    /**
     * 
     * @type {number}
     * @memberof PaginationOptions
     */
    'pageSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginationOptions
     */
    'sortOrder'?: PaginationOptionsSortOrderEnum;
}

export const PaginationOptionsSortOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type PaginationOptionsSortOrderEnum = typeof PaginationOptionsSortOrderEnum[keyof typeof PaginationOptionsSortOrderEnum];

/**
 * Represents effectiveness period and config of a price plan. i.e, price plan bound by time.
 * @export
 * @interface PlanOverride
 */
export interface PlanOverride {
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'pricePlanId': string;
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'pricePlanName': string;
    /**
     * 
     * @type {PricePlanDetailsOverride}
     * @memberof PlanOverride
     */
    'pricePlanDetailsOverride'?: PricePlanDetailsOverride;
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'endDate': string;
}
/**
 * Price plan entity
 * @export
 * @interface PricePlan
 */
export interface PricePlan {
    /**
     * Price plan id
     * @type {string}
     * @memberof PricePlan
     */
    'id': string;
    /**
     * Name of the price plan
     * @type {string}
     * @memberof PricePlan
     */
    'name': string;
    /**
     * Description of price plan
     * @type {string}
     * @memberof PricePlan
     */
    'description'?: string;
    /**
     * Status of Price plan
     * @type {string}
     * @memberof PricePlan
     */
    'status': PricePlanStatusEnum;
    /**
     * 
     * @type {Array<PricingSchedule>}
     * @memberof PricePlan
     */
    'pricingSchedule': Array<PricingSchedule>;
}

export const PricePlanStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type PricePlanStatusEnum = typeof PricePlanStatusEnum[keyof typeof PricePlanStatusEnum];

/**
 * 
 * @export
 * @interface PricePlanDetails
 */
export interface PricePlanDetails {
    /**
     * 
     * @type {Array<string>}
     * @memberof PricePlanDetails
     */
    'supportedCurrencies': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PricePlanDetails
     */
    'activeCurrencies': Array<string>;
    /**
     * 
     * @type {PricingCycleConfig}
     * @memberof PricePlanDetails
     */
    'pricingCycleConfig': PricingCycleConfig;
    /**
     * 
     * @type {Array<UsageRateCard>}
     * @memberof PricePlanDetails
     */
    'usageRateCards'?: Array<UsageRateCard>;
    /**
     * 
     * @type {Array<FixedFeeRateCard>}
     * @memberof PricePlanDetails
     */
    'fixedFeeRateCards'?: Array<FixedFeeRateCard>;
    /**
     * 
     * @type {MinimumCommitment}
     * @memberof PricePlanDetails
     */
    'minimumCommitment'?: MinimumCommitment;
}
/**
 * Configuration for getting the usage rate card
 * @export
 * @interface PricePlanDetailsConfig
 */
export interface PricePlanDetailsConfig {
    /**
     * Mode to get the usage rate card - CUSTOM: Use the price plan details provided in the request - PRICE_PLAN: Use the usage rate cards of the given price plan - ACCOUNT: Use the usage rate cards of a associated price plan of the given account 
     * @type {string}
     * @memberof PricePlanDetailsConfig
     */
    'mode': PricePlanDetailsConfigModeEnum;
    /**
     * 
     * @type {CreatePricePlanDetails}
     * @memberof PricePlanDetailsConfig
     */
    'pricePlanDetails'?: CreatePricePlanDetails;
    /**
     * Id of the price plan, this will be considered if mode is PRICE_PLAN
     * @type {string}
     * @memberof PricePlanDetailsConfig
     */
    'pricePlanId'?: string;
    /**
     * Id of the account, this will be considered if mode is ACCOUNT
     * @type {string}
     * @memberof PricePlanDetailsConfig
     */
    'accountId'?: string;
    /**
     * Will be used for getting the usage rate card, only used if mode is ACCOUNT or PRICE_PLAN
     * @type {string}
     * @memberof PricePlanDetailsConfig
     */
    'effectiveOn'?: string;
}

export const PricePlanDetailsConfigModeEnum = {
    Custom: 'CUSTOM',
    PricePlan: 'PRICE_PLAN',
    Account: 'ACCOUNT'
} as const;

export type PricePlanDetailsConfigModeEnum = typeof PricePlanDetailsConfigModeEnum[keyof typeof PricePlanDetailsConfigModeEnum];

/**
 * 
 * @export
 * @interface PricePlanDetailsOverride
 */
export interface PricePlanDetailsOverride {
    /**
     * 
     * @type {PricingCycleConfig}
     * @memberof PricePlanDetailsOverride
     */
    'pricingCycleConfig'?: PricingCycleConfig;
    /**
     * 
     * @type {Array<string>}
     * @memberof PricePlanDetailsOverride
     */
    'supportedCurrencies'?: Array<string>;
    /**
     * 
     * @type {Array<UsageRateCard>}
     * @memberof PricePlanDetailsOverride
     */
    'usageRateCards'?: Array<UsageRateCard>;
    /**
     * 
     * @type {Array<FixedFeeRateCard>}
     * @memberof PricePlanDetailsOverride
     */
    'fixedFeeRateCards'?: Array<FixedFeeRateCard>;
    /**
     * 
     * @type {MinimumCommitment}
     * @memberof PricePlanDetailsOverride
     */
    'minimumCommitment'?: MinimumCommitment;
}
/**
 * 
 * @export
 * @interface PricePlanDetailsOverrideAllOf
 */
export interface PricePlanDetailsOverrideAllOf {
    /**
     * 
     * @type {Array<FixedFeeRateCard>}
     * @memberof PricePlanDetailsOverrideAllOf
     */
    'fixedFeeRateCards'?: Array<FixedFeeRateCard>;
}
/**
 * Data of price plan list
 * @export
 * @interface PricePlanListData
 */
export interface PricePlanListData {
    /**
     * Identifier of price plan
     * @type {string}
     * @memberof PricePlanListData
     */
    'id': string;
    /**
     * Name of the price plan
     * @type {string}
     * @memberof PricePlanListData
     */
    'name': string;
    /**
     * Description of price plan
     * @type {string}
     * @memberof PricePlanListData
     */
    'description'?: string;
    /**
     * Status of Price plan
     * @type {string}
     * @memberof PricePlanListData
     */
    'status': PricePlanListDataStatusEnum;
    /**
     * Usage meters id linked to the price plan
     * @type {Array<string>}
     * @memberof PricePlanListData
     */
    'usageMeters': Array<string>;
    /**
     * 
     * @type {PricePlanDetails}
     * @memberof PricePlanListData
     */
    'pricePlanDetails': PricePlanDetails;
    /**
     * 
     * @type {string}
     * @memberof PricePlanListData
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PricePlanListData
     */
    'updatedAt': string;
}

export const PricePlanListDataStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type PricePlanListDataStatusEnum = typeof PricePlanListDataStatusEnum[keyof typeof PricePlanListDataStatusEnum];

/**
 * 
 * @export
 * @interface PricePlanPaginatedResponse
 */
export interface PricePlanPaginatedResponse {
    /**
     * 
     * @type {Array<PricePlanListData>}
     * @memberof PricePlanPaginatedResponse
     */
    'data': Array<PricePlanListData>;
    /**
     * 
     * @type {string}
     * @memberof PricePlanPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof PricePlanPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PriceType = {
    Flat: 'FLAT',
    PerUnit: 'PER_UNIT',
    Package: 'PACKAGE'
} as const;

export type PriceType = typeof PriceType[keyof typeof PriceType];


/**
 * Represents configurations related to pricing cycle
 * @export
 * @interface PricingCycleConfig
 */
export interface PricingCycleConfig {
    /**
     * Interval field allow you to define the billing interval you would like to set
     * @type {string}
     * @memberof PricingCycleConfig
     */
    'interval': PricingCycleConfigIntervalEnum;
    /**
     * 
     * @type {PricingCycleConfigStartOffset}
     * @memberof PricingCycleConfig
     */
    'startOffset': PricingCycleConfigStartOffset;
    /**
     * Togai allows you to ingest past dated events that will be processed by a pricing cycle till the end grace period.  For example: Pricing cycle is Monthly from 1st to 30th and gracePeriod is 5 days which next month 1 to 5th date, you can ingest past dated events during this grace period. 
     * @type {number}
     * @memberof PricingCycleConfig
     */
    'gracePeriod': number;
}

export const PricingCycleConfigIntervalEnum = {
    Monthly: 'MONTHLY',
    Quarterly: 'QUARTERLY',
    HalfYearly: 'HALF_YEARLY',
    Annually: 'ANNUALLY'
} as const;

export type PricingCycleConfigIntervalEnum = typeof PricingCycleConfigIntervalEnum[keyof typeof PricingCycleConfigIntervalEnum];

/**
 * Represents the start of pricing cycle in terms of  - dayOffset - number of days from beginning of month and  - monthOffset - number of months from beginning of interval (quarter, half-year or year) Note: If a day with offset doesn\'t exist for a month, closest previous day is considered Examples: MONTHLY -   - {dayOffset: 1, monthOffset: NIL} - First day of every month   - {dayOffset: 12, monthOffset: NIL} - 12th of every month   - {dayOffset: 28, monthOffset: NIL} - 28th of every month. i.e, 28th of Jan, 28th of Feb, ...   - {dayOffset: 30, monthOffset: NIL} - 30th of every month. i.e, 28th of Jan, 28th of Feb, ...   - {dayOffset: LAST, monthOffset: NIL} - Last day of every month. i.e, 31st of Jan, 28th of Feb, ... QUARTERLY   - {dayOffset: 15, monthOffset: FIRST} - 15th Jan, 15th Apr, 15th Jul and 15th Oct   - {dayOffset: 15, monthOffset: 2} - 15th Feb, 15th May, 15th Aug and 15th Nov   - {dayOffset: 15, monthOffset: LAST} - 15th Mar, 15th Jun, 15th Sep and 15th Dec   - {dayOffset: LAST, monthOffset: FIRST} - 31st Jan, 30th Apr, 30th Jul and 31th Oct HALF_YEARLY   - {dayOffset: 15, monthOffset: FIRST} - 15th Jan and 15th Jul   - {dayOffset: 15, monthOffset: 4} - 15th Apr and 15th Oct   - {dayOffset: 15, monthOffset: LAST} - 15th Jun and 15th Dec ANNUALLY   - {dayOffset: 15, monthOffset: FIRST} - 15th Jan   - {dayOffset: 15, monthOffset: 1} - 15th Jan   - {dayOffset: LAST, monthOffset: 2} - 29th Feb on Leap year, 28th otherwise    - {dayOffset: 15, monthOffset: 8} - 15th Aug   - {dayOffset: 15, monthOffset: LAST} - 15th Dec 
 * @export
 * @interface PricingCycleConfigStartOffset
 */
export interface PricingCycleConfigStartOffset {
    /**
     * min: \"1\" and max: \"31\" as strings. Spl. string allowed: LAST 
     * @type {string}
     * @memberof PricingCycleConfigStartOffset
     */
    'dayOffset': string;
    /**
     * min: \"1\" and max: \"12\". Spl. string allowed: FIRST / LAST. For QUARTERLY only 1 - 3 is allowed and for HALF_YEARLY 1 - 6. This being an optional field, shouldn\'t be passed for MONTHLY. 
     * @type {string}
     * @memberof PricingCycleConfigStartOffset
     */
    'monthOffset': string;
}
/**
 * Togai supports two type of pricing model Tiered and Volume. Tiered pricing model applies respective slab and its rate to the usage value while volume pricing model applies the latest matching slab of the usage value and applies respective rate.  For more understanding read [Rate Cards](https://docs.togai.com/docs/priceplan#setting-up-multiple-rate-cards) 
 * @export
 * @enum {string}
 */

export const PricingModel = {
    Tiered: 'TIERED',
    Volume: 'VOLUME'
} as const;

export type PricingModel = typeof PricingModel[keyof typeof PricingModel];


/**
 * Represents effectiveness period and config of a price plan. i.e, price plan bound by time.
 * @export
 * @interface PricingSchedule
 */
export interface PricingSchedule {
    /**
     * 
     * @type {PricePlanDetails}
     * @memberof PricingSchedule
     */
    'pricePlanDetails'?: PricePlanDetails;
    /**
     * 
     * @type {string}
     * @memberof PricingSchedule
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof PricingSchedule
     */
    'endDate': string;
}
/**
 * Contains all rate related configurations
 * @export
 * @interface RatePlan
 */
export interface RatePlan {
    /**
     * 
     * @type {PricingModel}
     * @memberof RatePlan
     */
    'pricingModel': PricingModel;
    /**
     * Rate cards can have single or multiple slab up to 100.
     * @type {Array<Slab>}
     * @memberof RatePlan
     */
    'slabs': Array<Slab>;
}
/**
 * Represents a rate
 * @export
 * @interface RateValue
 */
export interface RateValue {
    /**
     * 
     * @type {string}
     * @memberof RateValue
     */
    'currency': string;
    /**
     * 
     * @type {Array<SlabRate>}
     * @memberof RateValue
     */
    'slabRates': Array<SlabRate>;
}
/**
 * Payload to remove aliases from account
 * @export
 * @interface RemoveAccountAliasesRequest
 */
export interface RemoveAccountAliasesRequest {
    /**
     * List of aliases to remove
     * @type {Array<string>}
     * @memberof RemoveAccountAliasesRequest
     */
    'aliases'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RevenueInfo
 */
export interface RevenueInfo {
    /**
     * 
     * @type {UsageRateCard}
     * @memberof RevenueInfo
     */
    'usageRateCard'?: UsageRateCard;
    /**
     * 
     * @type {FixedFeeRateCard}
     * @memberof RevenueInfo
     */
    'fixedFeeRateCard'?: FixedFeeRateCard;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof RevenueInfo
     */
    'usages': { [key: string]: number; };
    /**
     * 
     * @type {RevenueInfoFixedFeeRevenueSummary}
     * @memberof RevenueInfo
     */
    'fixedFeeRevenueSummary'?: RevenueInfoFixedFeeRevenueSummary;
    /**
     * 
     * @type {Array<SlabRevenueSummary>}
     * @memberof RevenueInfo
     */
    'slabRevenueSummaries'?: Array<SlabRevenueSummary>;
}
/**
 * 
 * @export
 * @interface RevenueInfoFixedFeeRevenueSummary
 */
export interface RevenueInfoFixedFeeRevenueSummary {
    /**
     * 
     * @type {number}
     * @memberof RevenueInfoFixedFeeRevenueSummary
     */
    'revenue': number;
}
/**
 * 
 * @export
 * @interface RevenueSummaryQuery
 */
export interface RevenueSummaryQuery {
    /**
     * 
     * @type {string}
     * @memberof RevenueSummaryQuery
     */
    'id': string;
    /**
     * 
     * @type {InternalFixedFeeRateCard}
     * @memberof RevenueSummaryQuery
     */
    'fixedFeeRateCard'?: InternalFixedFeeRateCard;
    /**
     * 
     * @type {InternalUsageRateCard}
     * @memberof RevenueSummaryQuery
     */
    'usageRateCard'?: InternalUsageRateCard;
    /**
     * 
     * @type {RevenueSummaryQueryUsages}
     * @memberof RevenueSummaryQuery
     */
    'usages': RevenueSummaryQueryUsages;
}
/**
 * 
 * @export
 * @interface RevenueSummaryQueryUsages
 */
export interface RevenueSummaryQueryUsages {
    /**
     * 
     * @type {string}
     * @memberof RevenueSummaryQueryUsages
     */
    'mode': RevenueSummaryQueryUsagesModeEnum;
    /**
     * 
     * @type {RevenueSummaryQueryUsagesCustomConfig}
     * @memberof RevenueSummaryQueryUsages
     */
    'customConfig'?: RevenueSummaryQueryUsagesCustomConfig;
    /**
     * 
     * @type {RevenueSummaryQueryUsagesLookupConfig}
     * @memberof RevenueSummaryQueryUsages
     */
    'lookupConfig'?: RevenueSummaryQueryUsagesLookupConfig;
}

export const RevenueSummaryQueryUsagesModeEnum = {
    Lookup: 'LOOKUP',
    Custom: 'CUSTOM'
} as const;

export type RevenueSummaryQueryUsagesModeEnum = typeof RevenueSummaryQueryUsagesModeEnum[keyof typeof RevenueSummaryQueryUsagesModeEnum];

/**
 * Usages map with usageMeterId as key and usage units as value. This will be considered if mode is CUSTOM
 * @export
 * @interface RevenueSummaryQueryUsagesCustomConfig
 */
export interface RevenueSummaryQueryUsagesCustomConfig {
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof RevenueSummaryQueryUsagesCustomConfig
     */
    'usageMap': { [key: string]: number; };
}
/**
 * Holder for data required to lookup usages. This will be considered if mode is LOOKUP
 * @export
 * @interface RevenueSummaryQueryUsagesLookupConfig
 */
export interface RevenueSummaryQueryUsagesLookupConfig {
    /**
     * 
     * @type {string}
     * @memberof RevenueSummaryQueryUsagesLookupConfig
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof RevenueSummaryQueryUsagesLookupConfig
     */
    'end': string;
    /**
     * 
     * @type {string}
     * @memberof RevenueSummaryQueryUsagesLookupConfig
     */
    'accountId': string;
}
/**
 * 
 * @export
 * @interface RevenueSummaryResponse
 */
export interface RevenueSummaryResponse {
    /**
     * 
     * @type {string}
     * @memberof RevenueSummaryResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RevenueSummaryResponse
     */
    'currency': string;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof RevenueSummaryResponse
     */
    'usages': { [key: string]: number; };
    /**
     * 
     * @type {RevenueSummaryResponseRevenueSummary}
     * @memberof RevenueSummaryResponse
     */
    'revenueSummary': RevenueSummaryResponseRevenueSummary;
}
/**
 * 
 * @export
 * @interface RevenueSummaryResponseRevenueSummary
 */
export interface RevenueSummaryResponseRevenueSummary {
    /**
     * 
     * @type {Array<SlabRevenue>}
     * @memberof RevenueSummaryResponseRevenueSummary
     */
    'slabRevenues'?: Array<SlabRevenue>;
    /**
     * 
     * @type {number}
     * @memberof RevenueSummaryResponseRevenueSummary
     */
    'fixedFeeRevenue'?: number;
}
/**
 * Represents user_setting
 * @export
 * @interface Setting
 */
export interface Setting {
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'settingName': string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'settingValue': string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'entityType': string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'entityId': string;
}
/**
 * Payload to signup
 * @export
 * @interface SignupRequest
 */
export interface SignupRequest {
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    'description'?: string;
    /**
     * 
     * @type {UserDetails}
     * @memberof SignupRequest
     */
    'userDetails': UserDetails;
}
/**
 * Signup response
 * @export
 * @interface SignupResponse
 */
export interface SignupResponse {
    /**
     * Organization Identifier
     * @type {string}
     * @memberof SignupResponse
     */
    'organizationId': string;
    /**
     * Token which can be used for authentication
     * @type {string}
     * @memberof SignupResponse
     */
    'jwtToken': string;
}
/**
 * Represents a pricing priceType (rates + slabs) for usage price plan
 * @export
 * @interface Slab
 */
export interface Slab {
    /**
     * 
     * @type {number}
     * @memberof Slab
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof Slab
     */
    'startAfter': number;
    /**
     * 
     * @type {PriceType}
     * @memberof Slab
     */
    'priceType': PriceType;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Slab
     */
    'slabConfig'?: { [key: string]: string; };
}
/**
 * Represents a rate for a slab
 * @export
 * @interface SlabRate
 */
export interface SlabRate {
    /**
     * 
     * @type {number}
     * @memberof SlabRate
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof SlabRate
     */
    'rate': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SlabRate
     */
    'slabRateConfig'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface SlabRevenue
 */
export interface SlabRevenue {
    /**
     * 
     * @type {number}
     * @memberof SlabRevenue
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof SlabRevenue
     */
    'usage': number;
    /**
     * 
     * @type {number}
     * @memberof SlabRevenue
     */
    'revenue': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SlabRevenue
     */
    'metadata'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface SlabRevenueMetadata
 */
export interface SlabRevenueMetadata {
    /**
     * 
     * @type {boolean}
     * @memberof SlabRevenueMetadata
     */
    'minimumRateApplied'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SlabRevenueMetadata
     */
    'maximumRateApplied'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SlabRevenueMetadata
     */
    'packageQuantity'?: number;
}
/**
 * 
 * @export
 * @interface SlabRevenueSummary
 */
export interface SlabRevenueSummary {
    /**
     * 
     * @type {number}
     * @memberof SlabRevenueSummary
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof SlabRevenueSummary
     */
    'usage': number;
    /**
     * 
     * @type {number}
     * @memberof SlabRevenueSummary
     */
    'revenue': number;
    /**
     * 
     * @type {SlabRevenueMetadata}
     * @memberof SlabRevenueSummary
     */
    'metadata'?: SlabRevenueMetadata;
}
/**
 * 
 * @export
 * @interface StatusResponse
 */
export interface StatusResponse {
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'greeting'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'url'?: string;
    /**
     * 
     * @type {StatusResponseHeaders}
     * @memberof StatusResponse
     */
    'headers'?: StatusResponseHeaders;
}
/**
 * 
 * @export
 * @interface StatusResponseHeaders
 */
export interface StatusResponseHeaders {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof StatusResponseHeaders
     */
    'Content-Type'?: string;
}
/**
 * Payload to update account
 * @export
 * @interface UpdateAccountRequest
 */
export interface UpdateAccountRequest {
    /**
     * Name of the Account
     * @type {string}
     * @memberof UpdateAccountRequest
     */
    'name'?: string;
}
/**
 * Request to update an addon
 * @export
 * @interface UpdateAddOnRequest
 */
export interface UpdateAddOnRequest {
    /**
     * Name of addon
     * @type {string}
     * @memberof UpdateAddOnRequest
     */
    'name'?: string;
}
/**
 * Payload to update customer
 * @export
 * @interface UpdateCustomerRequest
 */
export interface UpdateCustomerRequest {
    /**
     * Name of the Customer
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'name'?: string;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'primaryEmail'?: string;
    /**
     * billing address of the customer
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'billingAddress'?: string;
}
/**
 * Request to update event schema
 * @export
 * @interface UpdateEventSchemaRequest
 */
export interface UpdateEventSchemaRequest {
    /**
     * Description of the event
     * @type {string}
     * @memberof UpdateEventSchemaRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<EventAttributeSchema>}
     * @memberof UpdateEventSchemaRequest
     */
    'attributes': Array<EventAttributeSchema>;
    /**
     * 
     * @type {Array<DimensionsSchema>}
     * @memberof UpdateEventSchemaRequest
     */
    'dimensions': Array<DimensionsSchema>;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationSettingRequest
 */
export interface UpdateOrganizationSettingRequest {
    /**
     * Base currency of the organization
     * @type {string}
     * @memberof UpdateOrganizationSettingRequest
     */
    'baseCurrency': string;
}
/**
 * Request to update a price plan
 * @export
 * @interface UpdatePricePlanRequest
 */
export interface UpdatePricePlanRequest {
    /**
     * Description of price plan
     * @type {string}
     * @memberof UpdatePricePlanRequest
     */
    'description'?: string;
    /**
     * 
     * @type {CreatePricePlanDetailsOverride}
     * @memberof UpdatePricePlanRequest
     */
    'pricePlanDetails'?: CreatePricePlanDetailsOverride;
}
/**
 * Request to update usage meter
 * @export
 * @interface UpdateUsageMeterRequest
 */
export interface UpdateUsageMeterRequest {
    /**
     * Description of the event
     * @type {string}
     * @memberof UpdateUsageMeterRequest
     */
    'description'?: string;
    /**
     * Type of usage meter * COUNTER - Count usage 
     * @type {string}
     * @memberof UpdateUsageMeterRequest
     */
    'type': UpdateUsageMeterRequestTypeEnum;
    /**
     * Aggregation to be applied on usage meter result * COUNT - Counts number of events matching the usage meter * SUM - Sums up results of computation of all events matching usage meter 
     * @type {string}
     * @memberof UpdateUsageMeterRequest
     */
    'aggregation': UpdateUsageMeterRequestAggregationEnum;
    /**
     * 
     * @type {Array<Computation>}
     * @memberof UpdateUsageMeterRequest
     */
    'computations'?: Array<Computation>;
}

export const UpdateUsageMeterRequestTypeEnum = {
    Counter: 'COUNTER'
} as const;

export type UpdateUsageMeterRequestTypeEnum = typeof UpdateUsageMeterRequestTypeEnum[keyof typeof UpdateUsageMeterRequestTypeEnum];
export const UpdateUsageMeterRequestAggregationEnum = {
    Count: 'COUNT',
    Sum: 'SUM'
} as const;

export type UpdateUsageMeterRequestAggregationEnum = typeof UpdateUsageMeterRequestAggregationEnum[keyof typeof UpdateUsageMeterRequestAggregationEnum];

/**
 * Configuration for getting the usage
 * @export
 * @interface UsageConfig
 */
export interface UsageConfig {
    /**
     * Mode to get the usage for the usage meters - CUSTOM: Use the usages provided in the request - LOOKUP_RANGE: Use the usage of a given account for the specified range - LOOKUP_CYCLE: Use the usage of a given account for the specified cycle 
     * @type {string}
     * @memberof UsageConfig
     */
    'mode': UsageConfigModeEnum;
    /**
     * Map of usage meter id and usage, this will be considered if mode is CUSTOM
     * @type {{ [key: string]: number; }}
     * @memberof UsageConfig
     */
    'usageMap'?: { [key: string]: number; };
    /**
     * 
     * @type {UsageConfigLookupRange}
     * @memberof UsageConfig
     */
    'lookupRange'?: UsageConfigLookupRange;
    /**
     * 
     * @type {UsageConfigLookupCycle}
     * @memberof UsageConfig
     */
    'lookupCycle'?: UsageConfigLookupCycle;
}

export const UsageConfigModeEnum = {
    Custom: 'CUSTOM',
    LookupRange: 'LOOKUP_RANGE',
    LookupCycle: 'LOOKUP_CYCLE'
} as const;

export type UsageConfigModeEnum = typeof UsageConfigModeEnum[keyof typeof UsageConfigModeEnum];

/**
 * Cycle of usage to be looked up, this will be considered if mode is LOOKUP_CYCLE
 * @export
 * @interface UsageConfigLookupCycle
 */
export interface UsageConfigLookupCycle {
    /**
     * 
     * @type {string}
     * @memberof UsageConfigLookupCycle
     */
    'cycleEffectiveOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsageConfigLookupCycle
     */
    'accountId': string;
}
/**
 * Range of usage to be looked up, this will be considered if mode is LOOKUP_RANGE
 * @export
 * @interface UsageConfigLookupRange
 */
export interface UsageConfigLookupRange {
    /**
     * 
     * @type {string}
     * @memberof UsageConfigLookupRange
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof UsageConfigLookupRange
     */
    'end': string;
    /**
     * 
     * @type {string}
     * @memberof UsageConfigLookupRange
     */
    'accountId': string;
}
/**
 * Structure of usage meter
 * @export
 * @interface UsageMeter
 */
export interface UsageMeter {
    /**
     * Identifier of the usage meter
     * @type {string}
     * @memberof UsageMeter
     */
    'id': string;
    /**
     * Name of the usage meter
     * @type {string}
     * @memberof UsageMeter
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UsageMeter
     */
    'description'?: string;
    /**
     * Type of usage meter
     * @type {string}
     * @memberof UsageMeter
     */
    'type': UsageMeterTypeEnum;
    /**
     * Status of usage meter
     * @type {string}
     * @memberof UsageMeter
     */
    'status'?: UsageMeterStatusEnum;
    /**
     * Aggregation to be applied on usage meter result
     * @type {string}
     * @memberof UsageMeter
     */
    'aggregation': UsageMeterAggregationEnum;
    /**
     * 
     * @type {Array<Computation>}
     * @memberof UsageMeter
     */
    'computations'?: Array<Computation>;
    /**
     * 
     * @type {string}
     * @memberof UsageMeter
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsageMeter
     */
    'lastActivatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsageMeter
     */
    'updatedAt'?: string;
}

export const UsageMeterTypeEnum = {
    Counter: 'COUNTER'
} as const;

export type UsageMeterTypeEnum = typeof UsageMeterTypeEnum[keyof typeof UsageMeterTypeEnum];
export const UsageMeterStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type UsageMeterStatusEnum = typeof UsageMeterStatusEnum[keyof typeof UsageMeterStatusEnum];
export const UsageMeterAggregationEnum = {
    Count: 'COUNT',
    Sum: 'SUM'
} as const;

export type UsageMeterAggregationEnum = typeof UsageMeterAggregationEnum[keyof typeof UsageMeterAggregationEnum];

/**
 * 
 * @export
 * @interface UsageMeterPaginatedResponse
 */
export interface UsageMeterPaginatedResponse {
    /**
     * 
     * @type {Array<UsageMeter>}
     * @memberof UsageMeterPaginatedResponse
     */
    'data'?: Array<UsageMeter>;
    /**
     * 
     * @type {string}
     * @memberof UsageMeterPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof UsageMeterPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * 
 * @export
 * @interface UsageRate
 */
export interface UsageRate {
    /**
     * The usage meter will be associated with the rate card to transform the usage value to billable value
     * @type {string}
     * @memberof UsageRate
     */
    'usageMeterId': string;
    /**
     * List of slab rates
     * @type {Array<SlabRate>}
     * @memberof UsageRate
     */
    'slabRates': Array<SlabRate>;
}
/**
 * 
 * @export
 * @interface UsageRateCard
 */
export interface UsageRateCard {
    /**
     * Name your rate card, this will be displayed in the Togai App
     * @type {string}
     * @memberof UsageRateCard
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof UsageRateCard
     */
    'usageMeterId': string;
    /**
     * 
     * @type {RatePlan}
     * @memberof UsageRateCard
     */
    'ratePlan': RatePlan;
    /**
     * 
     * @type {Array<RateValue>}
     * @memberof UsageRateCard
     */
    'rateValues': Array<RateValue>;
}
/**
 * Root user details for the organization
 * @export
 * @interface UserDetails
 */
export interface UserDetails {
    /**
     * 
     * @type {string}
     * @memberof UserDetails
     */
    'preferredUsername'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDetails
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserDetails
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserDetails
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserDetails
     */
    'phone'?: string;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add aliases to an account using customer_id and account_id.
         * @summary Add Aliases to account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {AddAccountAliasesRequest} addAccountAliasesRequest Payload to add aliases to account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAliases: async (customerId: string, accountId: string, addAccountAliasesRequest: AddAccountAliasesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('addAliases', 'customerId', customerId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('addAliases', 'accountId', accountId)
            // verify required parameter 'addAccountAliasesRequest' is not null or undefined
            assertParamExists('addAliases', 'addAccountAliasesRequest', addAccountAliasesRequest)
            const localVarPath = `/customers/{customer_id}/accounts/{account_id}/add_aliases`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAccountAliasesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API lets you to assign a price plan to an existing account
         * @summary Associate a plan to an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {AssociatePricePlanRequest} associatePricePlanRequest Payload to associate a price plan to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        associatePricePlan: async (customerId: string, accountId: string, associatePricePlanRequest: AssociatePricePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('associatePricePlan', 'customerId', customerId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('associatePricePlan', 'accountId', accountId)
            // verify required parameter 'associatePricePlanRequest' is not null or undefined
            assertParamExists('associatePricePlan', 'associatePricePlanRequest', associatePricePlanRequest)
            const localVarPath = `/customers/{customer_id}/accounts/{account_id}/price_plans`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(associatePricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API lets you to create an account for a customer using customer_id.
         * @summary Create an account
         * @param {string} customerId 
         * @param {CreateAccountRequest} createAccountRequest Payload to create account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (customerId: string, createAccountRequest: CreateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('createAccount', 'customerId', customerId)
            // verify required parameter 'createAccountRequest' is not null or undefined
            assertParamExists('createAccount', 'createAccountRequest', createAccountRequest)
            const localVarPath = `/customers/{customer_id}/accounts`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API lets you to delete a customer using customer_id and account_id.
         * @summary Delete an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (customerId: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('deleteAccount', 'customerId', customerId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAccount', 'accountId', accountId)
            const localVarPath = `/customers/{customer_id}/accounts/{account_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account information using customer_id and account_id.
         * @summary Get an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (customerId: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getAccount', 'customerId', customerId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccount', 'accountId', accountId)
            const localVarPath = `/customers/{customer_id}/accounts/{account_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of accounts of a customer with pagination and sort.
         * @summary List accounts of customer
         * @param {string} customerId 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (customerId: string, nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getAccounts', 'customerId', customerId)
            const localVarPath = `/customers/{customer_id}/accounts`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove existing aliases tagged to an account using this API
         * @summary Remove Aliases to account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {RemoveAccountAliasesRequest} removeAccountAliasesRequest Payload to remove aliases from account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAliases: async (customerId: string, accountId: string, removeAccountAliasesRequest: RemoveAccountAliasesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('removeAliases', 'customerId', customerId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('removeAliases', 'accountId', accountId)
            // verify required parameter 'removeAccountAliasesRequest' is not null or undefined
            assertParamExists('removeAliases', 'removeAccountAliasesRequest', removeAccountAliasesRequest)
            const localVarPath = `/customers/{customer_id}/accounts/{account_id}/remove_aliases`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeAccountAliasesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API lets you to update an accounts information using customer_id and account_id.
         * @summary Update an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {UpdateAccountRequest} updateAccountRequest Payload to update account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (customerId: string, accountId: string, updateAccountRequest: UpdateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('updateAccount', 'customerId', customerId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateAccount', 'accountId', accountId)
            // verify required parameter 'updateAccountRequest' is not null or undefined
            assertParamExists('updateAccount', 'updateAccountRequest', updateAccountRequest)
            const localVarPath = `/customers/{customer_id}/accounts/{account_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add aliases to an account using customer_id and account_id.
         * @summary Add Aliases to account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {AddAccountAliasesRequest} addAccountAliasesRequest Payload to add aliases to account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAliases(customerId: string, accountId: string, addAccountAliasesRequest: AddAccountAliasesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAliases(customerId, accountId, addAccountAliasesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API lets you to assign a price plan to an existing account
         * @summary Associate a plan to an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {AssociatePricePlanRequest} associatePricePlanRequest Payload to associate a price plan to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async associatePricePlan(customerId: string, accountId: string, associatePricePlanRequest: AssociatePricePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssociatePricePlanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.associatePricePlan(customerId, accountId, associatePricePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API lets you to create an account for a customer using customer_id.
         * @summary Create an account
         * @param {string} customerId 
         * @param {CreateAccountRequest} createAccountRequest Payload to create account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(customerId: string, createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(customerId, createAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API lets you to delete a customer using customer_id and account_id.
         * @summary Delete an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(customerId: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(customerId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get account information using customer_id and account_id.
         * @summary Get an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(customerId: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(customerId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of accounts of a customer with pagination and sort.
         * @summary List accounts of customer
         * @param {string} customerId 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(customerId: string, nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(customerId, nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove existing aliases tagged to an account using this API
         * @summary Remove Aliases to account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {RemoveAccountAliasesRequest} removeAccountAliasesRequest Payload to remove aliases from account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAliases(customerId: string, accountId: string, removeAccountAliasesRequest: RemoveAccountAliasesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAliases(customerId, accountId, removeAccountAliasesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API lets you to update an accounts information using customer_id and account_id.
         * @summary Update an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {UpdateAccountRequest} updateAccountRequest Payload to update account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(customerId: string, accountId: string, updateAccountRequest: UpdateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(customerId, accountId, updateAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Add aliases to an account using customer_id and account_id.
         * @summary Add Aliases to account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {AddAccountAliasesRequest} addAccountAliasesRequest Payload to add aliases to account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAliases(customerId: string, accountId: string, addAccountAliasesRequest: AddAccountAliasesRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.addAliases(customerId, accountId, addAccountAliasesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API lets you to assign a price plan to an existing account
         * @summary Associate a plan to an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {AssociatePricePlanRequest} associatePricePlanRequest Payload to associate a price plan to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        associatePricePlan(customerId: string, accountId: string, associatePricePlanRequest: AssociatePricePlanRequest, options?: any): AxiosPromise<AssociatePricePlanResponse> {
            return localVarFp.associatePricePlan(customerId, accountId, associatePricePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API lets you to create an account for a customer using customer_id.
         * @summary Create an account
         * @param {string} customerId 
         * @param {CreateAccountRequest} createAccountRequest Payload to create account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(customerId: string, createAccountRequest: CreateAccountRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.createAccount(customerId, createAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API lets you to delete a customer using customer_id and account_id.
         * @summary Delete an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(customerId: string, accountId: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteAccount(customerId, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get account information using customer_id and account_id.
         * @summary Get an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(customerId: string, accountId: string, options?: any): AxiosPromise<Account> {
            return localVarFp.getAccount(customerId, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of accounts of a customer with pagination and sort.
         * @summary List accounts of customer
         * @param {string} customerId 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(customerId: string, nextToken?: string, pageSize?: number, options?: any): AxiosPromise<AccountPaginatedResponse> {
            return localVarFp.getAccounts(customerId, nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove existing aliases tagged to an account using this API
         * @summary Remove Aliases to account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {RemoveAccountAliasesRequest} removeAccountAliasesRequest Payload to remove aliases from account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAliases(customerId: string, accountId: string, removeAccountAliasesRequest: RemoveAccountAliasesRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.removeAliases(customerId, accountId, removeAccountAliasesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API lets you to update an accounts information using customer_id and account_id.
         * @summary Update an account
         * @param {string} customerId 
         * @param {string} accountId 
         * @param {UpdateAccountRequest} updateAccountRequest Payload to update account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(customerId: string, accountId: string, updateAccountRequest: UpdateAccountRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.updateAccount(customerId, accountId, updateAccountRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Add aliases to an account using customer_id and account_id.
     * @summary Add Aliases to account
     * @param {string} customerId 
     * @param {string} accountId 
     * @param {AddAccountAliasesRequest} addAccountAliasesRequest Payload to add aliases to account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public addAliases(customerId: string, accountId: string, addAccountAliasesRequest: AddAccountAliasesRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).addAliases(customerId, accountId, addAccountAliasesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API lets you to assign a price plan to an existing account
     * @summary Associate a plan to an account
     * @param {string} customerId 
     * @param {string} accountId 
     * @param {AssociatePricePlanRequest} associatePricePlanRequest Payload to associate a price plan to an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public associatePricePlan(customerId: string, accountId: string, associatePricePlanRequest: AssociatePricePlanRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).associatePricePlan(customerId, accountId, associatePricePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API lets you to create an account for a customer using customer_id.
     * @summary Create an account
     * @param {string} customerId 
     * @param {CreateAccountRequest} createAccountRequest Payload to create account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccount(customerId: string, createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createAccount(customerId, createAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API lets you to delete a customer using customer_id and account_id.
     * @summary Delete an account
     * @param {string} customerId 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteAccount(customerId: string, accountId: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).deleteAccount(customerId, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get account information using customer_id and account_id.
     * @summary Get an account
     * @param {string} customerId 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(customerId: string, accountId: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(customerId, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of accounts of a customer with pagination and sort.
     * @summary List accounts of customer
     * @param {string} customerId 
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccounts(customerId: string, nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccounts(customerId, nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove existing aliases tagged to an account using this API
     * @summary Remove Aliases to account
     * @param {string} customerId 
     * @param {string} accountId 
     * @param {RemoveAccountAliasesRequest} removeAccountAliasesRequest Payload to remove aliases from account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public removeAliases(customerId: string, accountId: string, removeAccountAliasesRequest: RemoveAccountAliasesRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).removeAliases(customerId, accountId, removeAccountAliasesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API lets you to update an accounts information using customer_id and account_id.
     * @summary Update an account
     * @param {string} customerId 
     * @param {string} accountId 
     * @param {UpdateAccountRequest} updateAccountRequest Payload to update account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateAccount(customerId: string, accountId: string, updateAccountRequest: UpdateAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updateAccount(customerId, accountId, updateAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AddOnsApi - axios parameter creator
 * @export
 */
export const AddOnsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an AddOn
         * @summary Create an AddOn
         * @param {CreateAddOnRequest} createAddOnRequest Payload to create addon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddOn: async (createAddOnRequest: CreateAddOnRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAddOnRequest' is not null or undefined
            assertParamExists('createAddOn', 'createAddOnRequest', createAddOnRequest)
            const localVarPath = `/addons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAddOnRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of an addon
         * @summary Get an addon
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddOn: async (addonId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addonId' is not null or undefined
            assertParamExists('getAddOn', 'addonId', addonId)
            const localVarPath = `/addons/{addon_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of add-ons
         * @summary List addOns
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddOns: async (nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/addons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing addon 
         * @summary Update an addon
         * @param {string} addonId 
         * @param {UpdateAddOnRequest} updateAddOnRequest Payload to update addon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAddOn: async (addonId: string, updateAddOnRequest: UpdateAddOnRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addonId' is not null or undefined
            assertParamExists('updateAddOn', 'addonId', addonId)
            // verify required parameter 'updateAddOnRequest' is not null or undefined
            assertParamExists('updateAddOn', 'updateAddOnRequest', updateAddOnRequest)
            const localVarPath = `/addons/{addon_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAddOnRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddOnsApi - functional programming interface
 * @export
 */
export const AddOnsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddOnsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an AddOn
         * @summary Create an AddOn
         * @param {CreateAddOnRequest} createAddOnRequest Payload to create addon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAddOn(createAddOnRequest: CreateAddOnRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAddOn(createAddOnRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of an addon
         * @summary Get an addon
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddOn(addonId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddOn(addonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of add-ons
         * @summary List addOns
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddOns(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOnPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddOns(nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing addon 
         * @summary Update an addon
         * @param {string} addonId 
         * @param {UpdateAddOnRequest} updateAddOnRequest Payload to update addon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAddOn(addonId: string, updateAddOnRequest: UpdateAddOnRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAddOn(addonId, updateAddOnRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddOnsApi - factory interface
 * @export
 */
export const AddOnsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddOnsApiFp(configuration)
    return {
        /**
         * Create an AddOn
         * @summary Create an AddOn
         * @param {CreateAddOnRequest} createAddOnRequest Payload to create addon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddOn(createAddOnRequest: CreateAddOnRequest, options?: any): AxiosPromise<AddOn> {
            return localVarFp.createAddOn(createAddOnRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of an addon
         * @summary Get an addon
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddOn(addonId: string, options?: any): AxiosPromise<AddOn> {
            return localVarFp.getAddOn(addonId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of add-ons
         * @summary List addOns
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddOns(nextToken?: string, pageSize?: number, options?: any): AxiosPromise<AddOnPaginatedResponse> {
            return localVarFp.getAddOns(nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing addon 
         * @summary Update an addon
         * @param {string} addonId 
         * @param {UpdateAddOnRequest} updateAddOnRequest Payload to update addon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAddOn(addonId: string, updateAddOnRequest: UpdateAddOnRequest, options?: any): AxiosPromise<AddOn> {
            return localVarFp.updateAddOn(addonId, updateAddOnRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddOnsApi - object-oriented interface
 * @export
 * @class AddOnsApi
 * @extends {BaseAPI}
 */
export class AddOnsApi extends BaseAPI {
    /**
     * Create an AddOn
     * @summary Create an AddOn
     * @param {CreateAddOnRequest} createAddOnRequest Payload to create addon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddOnsApi
     */
    public createAddOn(createAddOnRequest: CreateAddOnRequest, options?: AxiosRequestConfig) {
        return AddOnsApiFp(this.configuration).createAddOn(createAddOnRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of an addon
     * @summary Get an addon
     * @param {string} addonId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddOnsApi
     */
    public getAddOn(addonId: string, options?: AxiosRequestConfig) {
        return AddOnsApiFp(this.configuration).getAddOn(addonId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of add-ons
     * @summary List addOns
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddOnsApi
     */
    public getAddOns(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return AddOnsApiFp(this.configuration).getAddOns(nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing addon 
     * @summary Update an addon
     * @param {string} addonId 
     * @param {UpdateAddOnRequest} updateAddOnRequest Payload to update addon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddOnsApi
     */
    public updateAddOn(addonId: string, updateAddOnRequest: UpdateAddOnRequest, options?: AxiosRequestConfig) {
        return AddOnsApiFp(this.configuration).updateAddOn(addonId, updateAddOnRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreditsApi - axios parameter creator
 * @export
 */
export const CreditsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Grant credit
         * @summary Grant credit
         * @param {CreateCreditRequest} [createCreditRequest] Payload to grant credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredit: async (createCreditRequest?: CreateCreditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/credits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCreditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Credit balance for Account
         * @summary Credit balance for Account
         * @param {string} accountId Filter option to filter based on account id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditBalanceForAccount: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('creditBalanceForAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/credit_balance`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get credit details
         * @summary Get credit details
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditDetails: async (creditId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'creditId' is not null or undefined
            assertParamExists('getCreditDetails', 'creditId', creditId)
            const localVarPath = `/credits/{credit_id}`
                .replace(`{${"credit_id"}}`, encodeURIComponent(String(creditId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all credits
         * @summary List credits
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by processed/unprocessed status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [id] Filter option to filter based on credit id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredits: async (nextToken?: string, status?: string, accountId?: string, id?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/credits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Void credit
         * @summary Void credit
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidCredit: async (creditId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'creditId' is not null or undefined
            assertParamExists('voidCredit', 'creditId', creditId)
            const localVarPath = `/credits/{credit_id}/void`
                .replace(`{${"credit_id"}}`, encodeURIComponent(String(creditId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditsApi - functional programming interface
 * @export
 */
export const CreditsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditsApiAxiosParamCreator(configuration)
    return {
        /**
         * Grant credit
         * @summary Grant credit
         * @param {CreateCreditRequest} [createCreditRequest] Payload to grant credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCredit(createCreditRequest?: CreateCreditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCredit(createCreditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Credit balance for Account
         * @summary Credit balance for Account
         * @param {string} accountId Filter option to filter based on account id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditBalanceForAccount(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditBalanceForAccount(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get credit details
         * @summary Get credit details
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCreditDetails(creditId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCreditDetails(creditId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all credits
         * @summary List credits
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by processed/unprocessed status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [id] Filter option to filter based on credit id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCredits(nextToken?: string, status?: string, accountId?: string, id?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCreditsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCredits(nextToken, status, accountId, id, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Void credit
         * @summary Void credit
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voidCredit(creditId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voidCredit(creditId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreditsApi - factory interface
 * @export
 */
export const CreditsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditsApiFp(configuration)
    return {
        /**
         * Grant credit
         * @summary Grant credit
         * @param {CreateCreditRequest} [createCreditRequest] Payload to grant credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredit(createCreditRequest?: CreateCreditRequest, options?: any): AxiosPromise<Credit> {
            return localVarFp.createCredit(createCreditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Credit balance for Account
         * @summary Credit balance for Account
         * @param {string} accountId Filter option to filter based on account id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditBalanceForAccount(accountId: string, options?: any): AxiosPromise<CreditBalanceResponse> {
            return localVarFp.creditBalanceForAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get credit details
         * @summary Get credit details
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditDetails(creditId: string, options?: any): AxiosPromise<CreditDetailsResponse> {
            return localVarFp.getCreditDetails(creditId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all credits
         * @summary List credits
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by processed/unprocessed status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [id] Filter option to filter based on credit id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredits(nextToken?: string, status?: string, accountId?: string, id?: string, pageSize?: number, options?: any): AxiosPromise<ListCreditsResponse> {
            return localVarFp.listCredits(nextToken, status, accountId, id, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Void credit
         * @summary Void credit
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidCredit(creditId: string, options?: any): AxiosPromise<Credit> {
            return localVarFp.voidCredit(creditId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreditsApi - object-oriented interface
 * @export
 * @class CreditsApi
 * @extends {BaseAPI}
 */
export class CreditsApi extends BaseAPI {
    /**
     * Grant credit
     * @summary Grant credit
     * @param {CreateCreditRequest} [createCreditRequest] Payload to grant credits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public createCredit(createCreditRequest?: CreateCreditRequest, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).createCredit(createCreditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Credit balance for Account
     * @summary Credit balance for Account
     * @param {string} accountId Filter option to filter based on account id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditBalanceForAccount(accountId: string, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditBalanceForAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get credit details
     * @summary Get credit details
     * @param {string} creditId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public getCreditDetails(creditId: string, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).getCreditDetails(creditId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all credits
     * @summary List credits
     * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
     * @param {string} [status] Filter option to filter by processed/unprocessed status.
     * @param {string} [accountId] Filter option to filter based on account id.
     * @param {string} [id] Filter option to filter based on credit id.
     * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public listCredits(nextToken?: string, status?: string, accountId?: string, id?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).listCredits(nextToken, status, accountId, id, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Void credit
     * @summary Void credit
     * @param {string} creditId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public voidCredit(creditId: string, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).voidCredit(creditId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomersApi - axios parameter creator
 * @export
 */
export const CustomersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API lets you to create customers and corresponding accounts.
         * @summary Create a customer
         * @param {CreateCustomerRequest} createCustomerRequest Payload to create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer: async (createCustomerRequest: CreateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCustomerRequest' is not null or undefined
            assertParamExists('createCustomer', 'createCustomerRequest', createCustomerRequest)
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API lets you to delete a customer using customer_id.
         * @summary Delete a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer: async (customerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('deleteCustomer', 'customerId', customerId)
            const localVarPath = `/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get customer information using customer_id.
         * @summary Get a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer: async (customerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getCustomer', 'customerId', customerId)
            const localVarPath = `/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of customers with pagination and sort.
         * @summary List customers
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers: async (nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API lets you to update a customers information using customer_id.
         * @summary Update a customer
         * @param {string} customerId 
         * @param {UpdateCustomerRequest} updateCustomerRequest Payload to update customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer: async (customerId: string, updateCustomerRequest: UpdateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('updateCustomer', 'customerId', customerId)
            // verify required parameter 'updateCustomerRequest' is not null or undefined
            assertParamExists('updateCustomer', 'updateCustomerRequest', updateCustomerRequest)
            const localVarPath = `/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomersApi - functional programming interface
 * @export
 */
export const CustomersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomersApiAxiosParamCreator(configuration)
    return {
        /**
         * This API lets you to create customers and corresponding accounts.
         * @summary Create a customer
         * @param {CreateCustomerRequest} createCustomerRequest Payload to create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomer(createCustomerRequest: CreateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomer(createCustomerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API lets you to delete a customer using customer_id.
         * @summary Delete a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomer(customerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomer(customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get customer information using customer_id.
         * @summary Get a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomer(customerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomer(customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of customers with pagination and sort.
         * @summary List customers
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomers(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomers(nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API lets you to update a customers information using customer_id.
         * @summary Update a customer
         * @param {string} customerId 
         * @param {UpdateCustomerRequest} updateCustomerRequest Payload to update customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomer(customerId, updateCustomerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomersApi - factory interface
 * @export
 */
export const CustomersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomersApiFp(configuration)
    return {
        /**
         * This API lets you to create customers and corresponding accounts.
         * @summary Create a customer
         * @param {CreateCustomerRequest} createCustomerRequest Payload to create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(createCustomerRequest: CreateCustomerRequest, options?: any): AxiosPromise<CreateCustomerResponse> {
            return localVarFp.createCustomer(createCustomerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API lets you to delete a customer using customer_id.
         * @summary Delete a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(customerId: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteCustomer(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get customer information using customer_id.
         * @summary Get a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(customerId: string, options?: any): AxiosPromise<Customer> {
            return localVarFp.getCustomer(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of customers with pagination and sort.
         * @summary List customers
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers(nextToken?: string, pageSize?: number, options?: any): AxiosPromise<CustomerPaginatedResponse> {
            return localVarFp.getCustomers(nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * This API lets you to update a customers information using customer_id.
         * @summary Update a customer
         * @param {string} customerId 
         * @param {UpdateCustomerRequest} updateCustomerRequest Payload to update customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: any): AxiosPromise<Customer> {
            return localVarFp.updateCustomer(customerId, updateCustomerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */
export class CustomersApi extends BaseAPI {
    /**
     * This API lets you to create customers and corresponding accounts.
     * @summary Create a customer
     * @param {CreateCustomerRequest} createCustomerRequest Payload to create customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public createCustomer(createCustomerRequest: CreateCustomerRequest, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).createCustomer(createCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API lets you to delete a customer using customer_id.
     * @summary Delete a customer
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public deleteCustomer(customerId: string, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).deleteCustomer(customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get customer information using customer_id.
     * @summary Get a customer
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomer(customerId: string, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getCustomer(customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of customers with pagination and sort.
     * @summary List customers
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomers(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getCustomers(nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API lets you to update a customers information using customer_id.
     * @summary Update a customer
     * @param {string} customerId 
     * @param {UpdateCustomerRequest} updateCustomerRequest Payload to update customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).updateCustomer(customerId, updateCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventIngestionApi - axios parameter creator
 * @export
 */
export const EventIngestionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API lets you to ingest events to your Togai account. Events ingested using this API will be processed via associated usage meters and further via associated price plans to generate final billable value to invoice the customer Read more about [Event Ingestion](https://docs.togai.com/docs/event-ingestion) 
         * @summary Ingest events to Togai
         * @param {IngestEventRequest} ingestEventRequest Request body to ingest events to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingest: async (ingestEventRequest: IngestEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ingestEventRequest' is not null or undefined
            assertParamExists('ingest', 'ingestEventRequest', ingestEventRequest)
            const localVarPath = `/ingest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingestEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API lets you to ingest events in batch upto 1000 events. Ingest large amounts of events up to 1000 in batches in an array using this API.
         * @summary Ingest events to Togai in batch
         * @param {IngestBatchEventRequest} ingestBatchEventRequest Request body to ingest events in batch to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestBatch: async (ingestBatchEventRequest: IngestBatchEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ingestBatchEventRequest' is not null or undefined
            assertParamExists('ingestBatch', 'ingestBatchEventRequest', ingestBatchEventRequest)
            const localVarPath = `/ingestBatch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingestBatchEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventIngestionApi - functional programming interface
 * @export
 */
export const EventIngestionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventIngestionApiAxiosParamCreator(configuration)
    return {
        /**
         * This API lets you to ingest events to your Togai account. Events ingested using this API will be processed via associated usage meters and further via associated price plans to generate final billable value to invoice the customer Read more about [Event Ingestion](https://docs.togai.com/docs/event-ingestion) 
         * @summary Ingest events to Togai
         * @param {IngestEventRequest} ingestEventRequest Request body to ingest events to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingest(ingestEventRequest: IngestEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingest(ingestEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API lets you to ingest events in batch upto 1000 events. Ingest large amounts of events up to 1000 in batches in an array using this API.
         * @summary Ingest events to Togai in batch
         * @param {IngestBatchEventRequest} ingestBatchEventRequest Request body to ingest events in batch to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingestBatch(ingestBatchEventRequest: IngestBatchEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngestBatchEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingestBatch(ingestBatchEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventIngestionApi - factory interface
 * @export
 */
export const EventIngestionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventIngestionApiFp(configuration)
    return {
        /**
         * This API lets you to ingest events to your Togai account. Events ingested using this API will be processed via associated usage meters and further via associated price plans to generate final billable value to invoice the customer Read more about [Event Ingestion](https://docs.togai.com/docs/event-ingestion) 
         * @summary Ingest events to Togai
         * @param {IngestEventRequest} ingestEventRequest Request body to ingest events to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingest(ingestEventRequest: IngestEventRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ingest(ingestEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API lets you to ingest events in batch upto 1000 events. Ingest large amounts of events up to 1000 in batches in an array using this API.
         * @summary Ingest events to Togai in batch
         * @param {IngestBatchEventRequest} ingestBatchEventRequest Request body to ingest events in batch to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestBatch(ingestBatchEventRequest: IngestBatchEventRequest, options?: any): AxiosPromise<IngestBatchEventResponse> {
            return localVarFp.ingestBatch(ingestBatchEventRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventIngestionApi - object-oriented interface
 * @export
 * @class EventIngestionApi
 * @extends {BaseAPI}
 */
export class EventIngestionApi extends BaseAPI {
    /**
     * This API lets you to ingest events to your Togai account. Events ingested using this API will be processed via associated usage meters and further via associated price plans to generate final billable value to invoice the customer Read more about [Event Ingestion](https://docs.togai.com/docs/event-ingestion) 
     * @summary Ingest events to Togai
     * @param {IngestEventRequest} ingestEventRequest Request body to ingest events to Togai usage and billing management service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventIngestionApi
     */
    public ingest(ingestEventRequest: IngestEventRequest, options?: AxiosRequestConfig) {
        return EventIngestionApiFp(this.configuration).ingest(ingestEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API lets you to ingest events in batch upto 1000 events. Ingest large amounts of events up to 1000 in batches in an array using this API.
     * @summary Ingest events to Togai in batch
     * @param {IngestBatchEventRequest} ingestBatchEventRequest Request body to ingest events in batch to Togai usage and billing management service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventIngestionApi
     */
    public ingestBatch(ingestBatchEventRequest: IngestBatchEventRequest, options?: AxiosRequestConfig) {
        return EventIngestionApiFp(this.configuration).ingestBatch(ingestBatchEventRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventManagementApi - axios parameter creator
 * @export
 */
export const EventManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API lets you to fetch a list of events with multiple query parameters
         * @summary Get a list of usage events with multiple query options
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter the events by processed/unprocessed status.
         * @param {string} [accountId] Filter option to filter the events based on account id.
         * @param {string} [schemaName] Filter option to filter the events based on schema name.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (nextToken?: string, status?: string, accountId?: string, schemaName?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (schemaName !== undefined) {
                localVarQueryParameter['schema_name'] = schemaName;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch details of a particular event using the event ID.
         * @summary Get an usage event using event id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleEvent: async (eventId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getSingleEvent', 'eventId', eventId)
            const localVarPath = `/events/{event_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventManagementApi - functional programming interface
 * @export
 */
export const EventManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * This API lets you to fetch a list of events with multiple query parameters
         * @summary Get a list of usage events with multiple query options
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter the events by processed/unprocessed status.
         * @param {string} [accountId] Filter option to filter the events based on account id.
         * @param {string} [schemaName] Filter option to filter the events based on schema name.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(nextToken?: string, status?: string, accountId?: string, schemaName?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(nextToken, status, accountId, schemaName, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch details of a particular event using the event ID.
         * @summary Get an usage event using event id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleEvent(eventId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleEvent(eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventManagementApi - factory interface
 * @export
 */
export const EventManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventManagementApiFp(configuration)
    return {
        /**
         * This API lets you to fetch a list of events with multiple query parameters
         * @summary Get a list of usage events with multiple query options
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter the events by processed/unprocessed status.
         * @param {string} [accountId] Filter option to filter the events based on account id.
         * @param {string} [schemaName] Filter option to filter the events based on schema name.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(nextToken?: string, status?: string, accountId?: string, schemaName?: string, pageSize?: number, options?: any): AxiosPromise<GetEventsResponse> {
            return localVarFp.getEvents(nextToken, status, accountId, schemaName, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch details of a particular event using the event ID.
         * @summary Get an usage event using event id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleEvent(eventId: string, options?: any): AxiosPromise<GetEventResponse> {
            return localVarFp.getSingleEvent(eventId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventManagementApi - object-oriented interface
 * @export
 * @class EventManagementApi
 * @extends {BaseAPI}
 */
export class EventManagementApi extends BaseAPI {
    /**
     * This API lets you to fetch a list of events with multiple query parameters
     * @summary Get a list of usage events with multiple query options
     * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
     * @param {string} [status] Filter option to filter the events by processed/unprocessed status.
     * @param {string} [accountId] Filter option to filter the events based on account id.
     * @param {string} [schemaName] Filter option to filter the events based on schema name.
     * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventManagementApi
     */
    public getEvents(nextToken?: string, status?: string, accountId?: string, schemaName?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return EventManagementApiFp(this.configuration).getEvents(nextToken, status, accountId, schemaName, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch details of a particular event using the event ID.
     * @summary Get an usage event using event id
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventManagementApi
     */
    public getSingleEvent(eventId: string, options?: AxiosRequestConfig) {
        return EventManagementApiFp(this.configuration).getSingleEvent(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventSchemasApi - axios parameter creator
 * @export
 */
export const EventSchemasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate an event schema
         * @summary Activate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateEventSchema: async (eventSchemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('activateEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}/activate`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an event schema with attributes and dimensions to process events.
         * @summary Create an event schema
         * @param {CreateEventSchemaRequest} createEventSchemaRequest Payload to create event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSchema: async (createEventSchemaRequest: CreateEventSchemaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEventSchemaRequest' is not null or undefined
            assertParamExists('createEventSchema', 'createEventSchemaRequest', createEventSchemaRequest)
            const localVarPath = `/event_schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventSchemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can deactivate an event schema using this API. In case you have an activate usage meter associated with the event schema, you will need to deactivate it first and then try deactivating the event schema. 
         * @summary Deactivate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateEventSchema: async (eventSchemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('deactivateEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}/deactivate`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To delete(archive) an event schema, youre required to archive associated active usage meters if any.
         * @summary Delete an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventSchema: async (eventSchemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('deleteEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an event schema and add new attributes and dimensions  Once an event schema is activated, you cannot update or delete existing attributes and dimensions however you can add new attributes and dimensions and update event schema description.     operationId: updateEventSchema 
         * @summary Update an event schema
         * @param {string} eventSchemaName 
         * @param {UpdateEventSchemaRequest} updateEventSchemaRequest Payload to update event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventSchemaEventSchemaNamePatch: async (eventSchemaName: string, updateEventSchemaRequest: UpdateEventSchemaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('eventSchemaEventSchemaNamePatch', 'eventSchemaName', eventSchemaName)
            // verify required parameter 'updateEventSchemaRequest' is not null or undefined
            assertParamExists('eventSchemaEventSchemaNamePatch', 'updateEventSchemaRequest', updateEventSchemaRequest)
            const localVarPath = `/event_schema/{event_schema_name}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventSchemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an event schema
         * @summary Get an event schema
         * @param {string} eventSchemaName 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSchema: async (eventSchemaName: string, version?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('getEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all the versions of an event schema
         * @summary List all event schema versions
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventSchemaVersions: async (eventSchemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('listEventSchemaVersions', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}/versions`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of event schema with pagination.
         * @summary List event schemas
         * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by provided status
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventSchemas: async (status?: 'ACTIVE' | 'INACTIVE', nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event_schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventSchemasApi - functional programming interface
 * @export
 */
export const EventSchemasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventSchemasApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate an event schema
         * @summary Activate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateEventSchema(eventSchemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateEventSchema(eventSchemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an event schema with attributes and dimensions to process events.
         * @summary Create an event schema
         * @param {CreateEventSchemaRequest} createEventSchemaRequest Payload to create event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventSchema(createEventSchemaRequest: CreateEventSchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventSchema(createEventSchemaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can deactivate an event schema using this API. In case you have an activate usage meter associated with the event schema, you will need to deactivate it first and then try deactivating the event schema. 
         * @summary Deactivate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateEventSchema(eventSchemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateEventSchema(eventSchemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To delete(archive) an event schema, youre required to archive associated active usage meters if any.
         * @summary Delete an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventSchema(eventSchemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventSchema(eventSchemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an event schema and add new attributes and dimensions  Once an event schema is activated, you cannot update or delete existing attributes and dimensions however you can add new attributes and dimensions and update event schema description.     operationId: updateEventSchema 
         * @summary Update an event schema
         * @param {string} eventSchemaName 
         * @param {UpdateEventSchemaRequest} updateEventSchemaRequest Payload to update event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventSchemaEventSchemaNamePatch(eventSchemaName: string, updateEventSchemaRequest: UpdateEventSchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventSchemaEventSchemaNamePatch(eventSchemaName, updateEventSchemaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an event schema
         * @summary Get an event schema
         * @param {string} eventSchemaName 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventSchema(eventSchemaName: string, version?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventSchema(eventSchemaName, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all the versions of an event schema
         * @summary List all event schema versions
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventSchemaVersions(eventSchemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchemaVersionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventSchemaVersions(eventSchemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of event schema with pagination.
         * @summary List event schemas
         * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by provided status
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventSchemas(status?: 'ACTIVE' | 'INACTIVE', nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchemaListPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventSchemas(status, nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventSchemasApi - factory interface
 * @export
 */
export const EventSchemasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventSchemasApiFp(configuration)
    return {
        /**
         * Activate an event schema
         * @summary Activate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateEventSchema(eventSchemaName: string, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.activateEventSchema(eventSchemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an event schema with attributes and dimensions to process events.
         * @summary Create an event schema
         * @param {CreateEventSchemaRequest} createEventSchemaRequest Payload to create event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSchema(createEventSchemaRequest: CreateEventSchemaRequest, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.createEventSchema(createEventSchemaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * You can deactivate an event schema using this API. In case you have an activate usage meter associated with the event schema, you will need to deactivate it first and then try deactivating the event schema. 
         * @summary Deactivate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateEventSchema(eventSchemaName: string, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.deactivateEventSchema(eventSchemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * To delete(archive) an event schema, youre required to archive associated active usage meters if any.
         * @summary Delete an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventSchema(eventSchemaName: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteEventSchema(eventSchemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an event schema and add new attributes and dimensions  Once an event schema is activated, you cannot update or delete existing attributes and dimensions however you can add new attributes and dimensions and update event schema description.     operationId: updateEventSchema 
         * @summary Update an event schema
         * @param {string} eventSchemaName 
         * @param {UpdateEventSchemaRequest} updateEventSchemaRequest Payload to update event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventSchemaEventSchemaNamePatch(eventSchemaName: string, updateEventSchemaRequest: UpdateEventSchemaRequest, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.eventSchemaEventSchemaNamePatch(eventSchemaName, updateEventSchemaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an event schema
         * @summary Get an event schema
         * @param {string} eventSchemaName 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSchema(eventSchemaName: string, version?: number, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.getEventSchema(eventSchemaName, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all the versions of an event schema
         * @summary List all event schema versions
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventSchemaVersions(eventSchemaName: string, options?: any): AxiosPromise<EventSchemaVersionsResponse> {
            return localVarFp.listEventSchemaVersions(eventSchemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of event schema with pagination.
         * @summary List event schemas
         * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by provided status
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventSchemas(status?: 'ACTIVE' | 'INACTIVE', nextToken?: string, pageSize?: number, options?: any): AxiosPromise<EventSchemaListPaginatedResponse> {
            return localVarFp.listEventSchemas(status, nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventSchemasApi - object-oriented interface
 * @export
 * @class EventSchemasApi
 * @extends {BaseAPI}
 */
export class EventSchemasApi extends BaseAPI {
    /**
     * Activate an event schema
     * @summary Activate an event schema
     * @param {string} eventSchemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public activateEventSchema(eventSchemaName: string, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).activateEventSchema(eventSchemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an event schema with attributes and dimensions to process events.
     * @summary Create an event schema
     * @param {CreateEventSchemaRequest} createEventSchemaRequest Payload to create event schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public createEventSchema(createEventSchemaRequest: CreateEventSchemaRequest, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).createEventSchema(createEventSchemaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can deactivate an event schema using this API. In case you have an activate usage meter associated with the event schema, you will need to deactivate it first and then try deactivating the event schema. 
     * @summary Deactivate an event schema
     * @param {string} eventSchemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public deactivateEventSchema(eventSchemaName: string, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).deactivateEventSchema(eventSchemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To delete(archive) an event schema, youre required to archive associated active usage meters if any.
     * @summary Delete an event schema
     * @param {string} eventSchemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public deleteEventSchema(eventSchemaName: string, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).deleteEventSchema(eventSchemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an event schema and add new attributes and dimensions  Once an event schema is activated, you cannot update or delete existing attributes and dimensions however you can add new attributes and dimensions and update event schema description.     operationId: updateEventSchema 
     * @summary Update an event schema
     * @param {string} eventSchemaName 
     * @param {UpdateEventSchemaRequest} updateEventSchemaRequest Payload to update event schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public eventSchemaEventSchemaNamePatch(eventSchemaName: string, updateEventSchemaRequest: UpdateEventSchemaRequest, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).eventSchemaEventSchemaNamePatch(eventSchemaName, updateEventSchemaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an event schema
     * @summary Get an event schema
     * @param {string} eventSchemaName 
     * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public getEventSchema(eventSchemaName: string, version?: number, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).getEventSchema(eventSchemaName, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all the versions of an event schema
     * @summary List all event schema versions
     * @param {string} eventSchemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public listEventSchemaVersions(eventSchemaName: string, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).listEventSchemaVersions(eventSchemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of event schema with pagination.
     * @summary List event schemas
     * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by provided status
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public listEventSchemas(status?: 'ACTIVE' | 'INACTIVE', nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).listEventSchemas(status, nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvoicesApi - axios parameter creator
 * @export
 */
export const InvoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get invoice
         * @summary Get an invoice
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice: async (invoiceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('getInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/invoices/{invoice_id}`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List invoices
         * @summary List invoices
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by processed/unprocessed status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [customerId] Filter option to filter based on customer id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {number} [startTime] Start time filter in epoch milli seconds
         * @param {number} [endTime] End time filter in epoch milli seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvoices: async (nextToken?: string, status?: string, accountId?: string, customerId?: string, pageSize?: number, startTime?: number, endTime?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customer_id'] = customerId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicesApi - functional programming interface
 * @export
 */
export const InvoicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoicesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get invoice
         * @summary Get an invoice
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoice(invoiceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoice(invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List invoices
         * @summary List invoices
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by processed/unprocessed status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [customerId] Filter option to filter based on customer id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {number} [startTime] Start time filter in epoch milli seconds
         * @param {number} [endTime] End time filter in epoch milli seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInvoices(nextToken?: string, status?: string, accountId?: string, customerId?: string, pageSize?: number, startTime?: number, endTime?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListInvoicesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInvoices(nextToken, status, accountId, customerId, pageSize, startTime, endTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvoicesApi - factory interface
 * @export
 */
export const InvoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoicesApiFp(configuration)
    return {
        /**
         * Get invoice
         * @summary Get an invoice
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice(invoiceId: string, options?: any): AxiosPromise<Invoice> {
            return localVarFp.getInvoice(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List invoices
         * @summary List invoices
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by processed/unprocessed status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [customerId] Filter option to filter based on customer id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {number} [startTime] Start time filter in epoch milli seconds
         * @param {number} [endTime] End time filter in epoch milli seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvoices(nextToken?: string, status?: string, accountId?: string, customerId?: string, pageSize?: number, startTime?: number, endTime?: number, options?: any): AxiosPromise<ListInvoicesResponse> {
            return localVarFp.listInvoices(nextToken, status, accountId, customerId, pageSize, startTime, endTime, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
export class InvoicesApi extends BaseAPI {
    /**
     * Get invoice
     * @summary Get an invoice
     * @param {string} invoiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public getInvoice(invoiceId: string, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).getInvoice(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List invoices
     * @summary List invoices
     * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
     * @param {string} [status] Filter option to filter by processed/unprocessed status.
     * @param {string} [accountId] Filter option to filter based on account id.
     * @param {string} [customerId] Filter option to filter based on customer id.
     * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
     * @param {number} [startTime] Start time filter in epoch milli seconds
     * @param {number} [endTime] End time filter in epoch milli seconds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public listInvoices(nextToken?: string, status?: string, accountId?: string, customerId?: string, pageSize?: number, startTime?: number, endTime?: number, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).listInvoices(nextToken, status, accountId, customerId, pageSize, startTime, endTime, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Togai Metrics API allows you to fetch different metrics from Events , Usage Meters and PricePlans with multiple queryable options. A single request can query up to five metrics.  Single response can contain a maximum of 100 data points. 
         * @summary Get Togai Metrics
         * @param {GetMetricsRequest} [getMetricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics: async (getMetricsRequest?: GetMetricsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getMetricsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * Togai Metrics API allows you to fetch different metrics from Events , Usage Meters and PricePlans with multiple queryable options. A single request can query up to five metrics.  Single response can contain a maximum of 100 data points. 
         * @summary Get Togai Metrics
         * @param {GetMetricsRequest} [getMetricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetrics(getMetricsRequest?: GetMetricsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetrics(getMetricsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * Togai Metrics API allows you to fetch different metrics from Events , Usage Meters and PricePlans with multiple queryable options. A single request can query up to five metrics.  Single response can contain a maximum of 100 data points. 
         * @summary Get Togai Metrics
         * @param {GetMetricsRequest} [getMetricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(getMetricsRequest?: GetMetricsRequest, options?: any): AxiosPromise<GetMetricsResponse> {
            return localVarFp.getMetrics(getMetricsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * Togai Metrics API allows you to fetch different metrics from Events , Usage Meters and PricePlans with multiple queryable options. A single request can query up to five metrics.  Single response can contain a maximum of 100 data points. 
     * @summary Get Togai Metrics
     * @param {GetMetricsRequest} [getMetricsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetrics(getMetricsRequest?: GetMetricsRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getMetrics(getMetricsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MiscellaneousApi - axios parameter creator
 * @export
 */
export const MiscellaneousApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calculate and return the revenue for a existing or new price plan
         * @summary Calculate and return the revenue for a existing or new price plan
         * @param {CalculateRevenueRequest} calculateRevenueRequest Request payload for calculateRevenueAPI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateRevenue: async (calculateRevenueRequest: CalculateRevenueRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'calculateRevenueRequest' is not null or undefined
            assertParamExists('calculateRevenue', 'calculateRevenueRequest', calculateRevenueRequest)
            const localVarPath = `/revenue_calculator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(calculateRevenueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiscellaneousApi - functional programming interface
 * @export
 */
export const MiscellaneousApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MiscellaneousApiAxiosParamCreator(configuration)
    return {
        /**
         * Calculate and return the revenue for a existing or new price plan
         * @summary Calculate and return the revenue for a existing or new price plan
         * @param {CalculateRevenueRequest} calculateRevenueRequest Request payload for calculateRevenueAPI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calculateRevenue(calculateRevenueRequest: CalculateRevenueRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CalculateRevenueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calculateRevenue(calculateRevenueRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MiscellaneousApi - factory interface
 * @export
 */
export const MiscellaneousApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MiscellaneousApiFp(configuration)
    return {
        /**
         * Calculate and return the revenue for a existing or new price plan
         * @summary Calculate and return the revenue for a existing or new price plan
         * @param {CalculateRevenueRequest} calculateRevenueRequest Request payload for calculateRevenueAPI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateRevenue(calculateRevenueRequest: CalculateRevenueRequest, options?: any): AxiosPromise<CalculateRevenueResponse> {
            return localVarFp.calculateRevenue(calculateRevenueRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MiscellaneousApi - object-oriented interface
 * @export
 * @class MiscellaneousApi
 * @extends {BaseAPI}
 */
export class MiscellaneousApi extends BaseAPI {
    /**
     * Calculate and return the revenue for a existing or new price plan
     * @summary Calculate and return the revenue for a existing or new price plan
     * @param {CalculateRevenueRequest} calculateRevenueRequest Request payload for calculateRevenueAPI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public calculateRevenue(calculateRevenueRequest: CalculateRevenueRequest, options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).calculateRevenue(calculateRevenueRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PricePlansApi - axios parameter creator
 * @export
 */
export const PricePlansApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate a price plan details using price plan id
         * @summary Activate a price plan
         * @param {string} pricePlanId 
         * @param {ActivatePricePlanRequest} activatePricePlanRequest Payload to activate price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePricePlan: async (pricePlanId: string, activatePricePlanRequest: ActivatePricePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('activatePricePlan', 'pricePlanId', pricePlanId)
            // verify required parameter 'activatePricePlanRequest' is not null or undefined
            assertParamExists('activatePricePlan', 'activatePricePlanRequest', activatePricePlanRequest)
            const localVarPath = `/price_plans/{price_plan_id}/activate`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activatePricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add currencies to a price plan
         * @summary Add currencies to a price plan
         * @param {string} pricePlanId 
         * @param {AddCurrencyToPricePlanRequest} addCurrencyToPricePlanRequest Payload to add currency to price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCurrencyToPricePlan: async (pricePlanId: string, addCurrencyToPricePlanRequest: AddCurrencyToPricePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('addCurrencyToPricePlan', 'pricePlanId', pricePlanId)
            // verify required parameter 'addCurrencyToPricePlanRequest' is not null or undefined
            assertParamExists('addCurrencyToPricePlan', 'addCurrencyToPricePlanRequest', addCurrencyToPricePlanRequest)
            const localVarPath = `/price_plans/{price_plan_id}/currencies`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addCurrencyToPricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let\'s you create and price plan Learn more about [Price Plans](https://docs.togai.com/docs/priceplan) 
         * @summary Create a price plan
         * @param {CreatePricePlanRequest} createPricePlanRequest Payload to create price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPricePlan: async (createPricePlanRequest: CreatePricePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPricePlanRequest' is not null or undefined
            assertParamExists('createPricePlan', 'createPricePlanRequest', createPricePlanRequest)
            const localVarPath = `/price_plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a price plan details using price plan id
         * @summary Get a price plan
         * @param {string} pricePlanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricePlan: async (pricePlanId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('getPricePlan', 'pricePlanId', pricePlanId)
            const localVarPath = `/price_plans/{price_plan_id}`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of price plans
         * @summary List price plans
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricePlans: async (nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/price_plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a draft currency from a price plan
         * @summary Remove a draft currency from a price plan
         * @param {string} pricePlanId 
         * @param {string} currencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCurrencyFromPricePlan: async (pricePlanId: string, currencyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('removeCurrencyFromPricePlan', 'pricePlanId', pricePlanId)
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('removeCurrencyFromPricePlan', 'currencyId', currencyId)
            const localVarPath = `/price_plans/{price_plan_id}/currencies/{currency_id}`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)))
                .replace(`{${"currency_id"}}`, encodeURIComponent(String(currencyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing price plan Price Plans with status as DRAFT alone can be updated . Learn more about [Price plans](https://docs.togai.com/docs/priceplan) from our Guides 
         * @summary Update a price plan
         * @param {string} pricePlanId 
         * @param {UpdatePricePlanRequest} updatePricePlanRequest Payload to update price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricePlan: async (pricePlanId: string, updatePricePlanRequest: UpdatePricePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('updatePricePlan', 'pricePlanId', pricePlanId)
            // verify required parameter 'updatePricePlanRequest' is not null or undefined
            assertParamExists('updatePricePlan', 'updatePricePlanRequest', updatePricePlanRequest)
            const localVarPath = `/price_plans/{price_plan_id}`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PricePlansApi - functional programming interface
 * @export
 */
export const PricePlansApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PricePlansApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate a price plan details using price plan id
         * @summary Activate a price plan
         * @param {string} pricePlanId 
         * @param {ActivatePricePlanRequest} activatePricePlanRequest Payload to activate price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activatePricePlan(pricePlanId: string, activatePricePlanRequest: ActivatePricePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activatePricePlan(pricePlanId, activatePricePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add currencies to a price plan
         * @summary Add currencies to a price plan
         * @param {string} pricePlanId 
         * @param {AddCurrencyToPricePlanRequest} addCurrencyToPricePlanRequest Payload to add currency to price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCurrencyToPricePlan(pricePlanId: string, addCurrencyToPricePlanRequest: AddCurrencyToPricePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCurrencyToPricePlan(pricePlanId, addCurrencyToPricePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let\'s you create and price plan Learn more about [Price Plans](https://docs.togai.com/docs/priceplan) 
         * @summary Create a price plan
         * @param {CreatePricePlanRequest} createPricePlanRequest Payload to create price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPricePlan(createPricePlanRequest: CreatePricePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPricePlan(createPricePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a price plan details using price plan id
         * @summary Get a price plan
         * @param {string} pricePlanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricePlan(pricePlanId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricePlan(pricePlanId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of price plans
         * @summary List price plans
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricePlans(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlanPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricePlans(nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a draft currency from a price plan
         * @summary Remove a draft currency from a price plan
         * @param {string} pricePlanId 
         * @param {string} currencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeCurrencyFromPricePlan(pricePlanId: string, currencyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeCurrencyFromPricePlan(pricePlanId, currencyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing price plan Price Plans with status as DRAFT alone can be updated . Learn more about [Price plans](https://docs.togai.com/docs/priceplan) from our Guides 
         * @summary Update a price plan
         * @param {string} pricePlanId 
         * @param {UpdatePricePlanRequest} updatePricePlanRequest Payload to update price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePricePlan(pricePlanId: string, updatePricePlanRequest: UpdatePricePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePricePlan(pricePlanId, updatePricePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PricePlansApi - factory interface
 * @export
 */
export const PricePlansApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PricePlansApiFp(configuration)
    return {
        /**
         * Activate a price plan details using price plan id
         * @summary Activate a price plan
         * @param {string} pricePlanId 
         * @param {ActivatePricePlanRequest} activatePricePlanRequest Payload to activate price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePricePlan(pricePlanId: string, activatePricePlanRequest: ActivatePricePlanRequest, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.activatePricePlan(pricePlanId, activatePricePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add currencies to a price plan
         * @summary Add currencies to a price plan
         * @param {string} pricePlanId 
         * @param {AddCurrencyToPricePlanRequest} addCurrencyToPricePlanRequest Payload to add currency to price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCurrencyToPricePlan(pricePlanId: string, addCurrencyToPricePlanRequest: AddCurrencyToPricePlanRequest, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.addCurrencyToPricePlan(pricePlanId, addCurrencyToPricePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let\'s you create and price plan Learn more about [Price Plans](https://docs.togai.com/docs/priceplan) 
         * @summary Create a price plan
         * @param {CreatePricePlanRequest} createPricePlanRequest Payload to create price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPricePlan(createPricePlanRequest: CreatePricePlanRequest, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.createPricePlan(createPricePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a price plan details using price plan id
         * @summary Get a price plan
         * @param {string} pricePlanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricePlan(pricePlanId: string, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.getPricePlan(pricePlanId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of price plans
         * @summary List price plans
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricePlans(nextToken?: string, pageSize?: number, options?: any): AxiosPromise<PricePlanPaginatedResponse> {
            return localVarFp.getPricePlans(nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a draft currency from a price plan
         * @summary Remove a draft currency from a price plan
         * @param {string} pricePlanId 
         * @param {string} currencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCurrencyFromPricePlan(pricePlanId: string, currencyId: string, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.removeCurrencyFromPricePlan(pricePlanId, currencyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing price plan Price Plans with status as DRAFT alone can be updated . Learn more about [Price plans](https://docs.togai.com/docs/priceplan) from our Guides 
         * @summary Update a price plan
         * @param {string} pricePlanId 
         * @param {UpdatePricePlanRequest} updatePricePlanRequest Payload to update price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricePlan(pricePlanId: string, updatePricePlanRequest: UpdatePricePlanRequest, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.updatePricePlan(pricePlanId, updatePricePlanRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PricePlansApi - object-oriented interface
 * @export
 * @class PricePlansApi
 * @extends {BaseAPI}
 */
export class PricePlansApi extends BaseAPI {
    /**
     * Activate a price plan details using price plan id
     * @summary Activate a price plan
     * @param {string} pricePlanId 
     * @param {ActivatePricePlanRequest} activatePricePlanRequest Payload to activate price plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public activatePricePlan(pricePlanId: string, activatePricePlanRequest: ActivatePricePlanRequest, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).activatePricePlan(pricePlanId, activatePricePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add currencies to a price plan
     * @summary Add currencies to a price plan
     * @param {string} pricePlanId 
     * @param {AddCurrencyToPricePlanRequest} addCurrencyToPricePlanRequest Payload to add currency to price plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public addCurrencyToPricePlan(pricePlanId: string, addCurrencyToPricePlanRequest: AddCurrencyToPricePlanRequest, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).addCurrencyToPricePlan(pricePlanId, addCurrencyToPricePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let\'s you create and price plan Learn more about [Price Plans](https://docs.togai.com/docs/priceplan) 
     * @summary Create a price plan
     * @param {CreatePricePlanRequest} createPricePlanRequest Payload to create price plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public createPricePlan(createPricePlanRequest: CreatePricePlanRequest, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).createPricePlan(createPricePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a price plan details using price plan id
     * @summary Get a price plan
     * @param {string} pricePlanId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public getPricePlan(pricePlanId: string, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).getPricePlan(pricePlanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of price plans
     * @summary List price plans
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public getPricePlans(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).getPricePlans(nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a draft currency from a price plan
     * @summary Remove a draft currency from a price plan
     * @param {string} pricePlanId 
     * @param {string} currencyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public removeCurrencyFromPricePlan(pricePlanId: string, currencyId: string, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).removeCurrencyFromPricePlan(pricePlanId, currencyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing price plan Price Plans with status as DRAFT alone can be updated . Learn more about [Price plans](https://docs.togai.com/docs/priceplan) from our Guides 
     * @summary Update a price plan
     * @param {string} pricePlanId 
     * @param {UpdatePricePlanRequest} updatePricePlanRequest Payload to update price plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public updatePricePlan(pricePlanId: string, updatePricePlanRequest: UpdatePricePlanRequest, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).updatePricePlan(pricePlanId, updatePricePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsageMetersApi - axios parameter creator
 * @export
 */
export const UsageMetersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate usage meter
         * @summary Activate usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUsageMeter: async (eventSchemaName: string, usageMeterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('activateUsageMeter', 'eventSchemaName', eventSchemaName)
            // verify required parameter 'usageMeterId' is not null or undefined
            assertParamExists('activateUsageMeter', 'usageMeterId', usageMeterId)
            const localVarPath = `/event_schema/{event_schema_name}/usage_meters/{usage_meter_id}/activate`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)))
                .replace(`{${"usage_meter_id"}}`, encodeURIComponent(String(usageMeterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an usage meter and associate with an event schema
         * @summary Create an usage meter
         * @param {string} eventSchemaName 
         * @param {CreateUsageMeterRequest} createUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsageMeter: async (eventSchemaName: string, createUsageMeterRequest: CreateUsageMeterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('createUsageMeter', 'eventSchemaName', eventSchemaName)
            // verify required parameter 'createUsageMeterRequest' is not null or undefined
            assertParamExists('createUsageMeter', 'createUsageMeterRequest', createUsageMeterRequest)
            const localVarPath = `/event_schema/{event_schema_name}/usage_meters`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUsageMeterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make an existing active usage meter to be inactive Active Usage Meters with active Pricing Plan attached can also be deactivated. 
         * @summary Deactivate usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUsageMeter: async (eventSchemaName: string, usageMeterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('deactivateUsageMeter', 'eventSchemaName', eventSchemaName)
            // verify required parameter 'usageMeterId' is not null or undefined
            assertParamExists('deactivateUsageMeter', 'usageMeterId', usageMeterId)
            const localVarPath = `/event_schema/{event_schema_name}/usage_meters/{usage_meter_id}/deactivate`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)))
                .replace(`{${"usage_meter_id"}}`, encodeURIComponent(String(usageMeterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an usage meter using event schema name and usage meter id.
         * @summary Get usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMeter: async (eventSchemaName: string, usageMeterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('getUsageMeter', 'eventSchemaName', eventSchemaName)
            // verify required parameter 'usageMeterId' is not null or undefined
            assertParamExists('getUsageMeter', 'usageMeterId', usageMeterId)
            const localVarPath = `/event_schema/{event_schema_name}/usage_meters/{usage_meter_id}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)))
                .replace(`{${"usage_meter_id"}}`, encodeURIComponent(String(usageMeterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of usage meters associated with an event schema
         * @summary List usage meters for event schema
         * @param {string} eventSchemaName 
         * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by status 
         * @param {'COUNT' | 'SUM'} [aggregations] Filter by aggregations 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMetersForEventSchema: async (eventSchemaName: string, status?: 'ACTIVE' | 'INACTIVE', aggregations?: 'COUNT' | 'SUM', nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('getUsageMetersForEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}/usage_meters`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (aggregations !== undefined) {
                localVarQueryParameter['aggregations'] = aggregations;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API lets you update an existing usage meter.
         * @summary Update an usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {UpdateUsageMeterRequest} updateUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsageMeter: async (eventSchemaName: string, usageMeterId: string, updateUsageMeterRequest: UpdateUsageMeterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('updateUsageMeter', 'eventSchemaName', eventSchemaName)
            // verify required parameter 'usageMeterId' is not null or undefined
            assertParamExists('updateUsageMeter', 'usageMeterId', usageMeterId)
            // verify required parameter 'updateUsageMeterRequest' is not null or undefined
            assertParamExists('updateUsageMeter', 'updateUsageMeterRequest', updateUsageMeterRequest)
            const localVarPath = `/event_schema/{event_schema_name}/usage_meters/{usage_meter_id}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)))
                .replace(`{${"usage_meter_id"}}`, encodeURIComponent(String(usageMeterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUsageMeterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsageMetersApi - functional programming interface
 * @export
 */
export const UsageMetersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsageMetersApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate usage meter
         * @summary Activate usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateUsageMeter(eventSchemaName: string, usageMeterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateUsageMeter(eventSchemaName, usageMeterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an usage meter and associate with an event schema
         * @summary Create an usage meter
         * @param {string} eventSchemaName 
         * @param {CreateUsageMeterRequest} createUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUsageMeter(eventSchemaName: string, createUsageMeterRequest: CreateUsageMeterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUsageMeter(eventSchemaName, createUsageMeterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Make an existing active usage meter to be inactive Active Usage Meters with active Pricing Plan attached can also be deactivated. 
         * @summary Deactivate usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateUsageMeter(eventSchemaName: string, usageMeterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateUsageMeter(eventSchemaName, usageMeterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an usage meter using event schema name and usage meter id.
         * @summary Get usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsageMeter(eventSchemaName: string, usageMeterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageMeter(eventSchemaName, usageMeterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of usage meters associated with an event schema
         * @summary List usage meters for event schema
         * @param {string} eventSchemaName 
         * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by status 
         * @param {'COUNT' | 'SUM'} [aggregations] Filter by aggregations 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsageMetersForEventSchema(eventSchemaName: string, status?: 'ACTIVE' | 'INACTIVE', aggregations?: 'COUNT' | 'SUM', nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeterPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageMetersForEventSchema(eventSchemaName, status, aggregations, nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API lets you update an existing usage meter.
         * @summary Update an usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {UpdateUsageMeterRequest} updateUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUsageMeter(eventSchemaName: string, usageMeterId: string, updateUsageMeterRequest: UpdateUsageMeterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUsageMeter(eventSchemaName, usageMeterId, updateUsageMeterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsageMetersApi - factory interface
 * @export
 */
export const UsageMetersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsageMetersApiFp(configuration)
    return {
        /**
         * Activate usage meter
         * @summary Activate usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUsageMeter(eventSchemaName: string, usageMeterId: string, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.activateUsageMeter(eventSchemaName, usageMeterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an usage meter and associate with an event schema
         * @summary Create an usage meter
         * @param {string} eventSchemaName 
         * @param {CreateUsageMeterRequest} createUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsageMeter(eventSchemaName: string, createUsageMeterRequest: CreateUsageMeterRequest, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.createUsageMeter(eventSchemaName, createUsageMeterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Make an existing active usage meter to be inactive Active Usage Meters with active Pricing Plan attached can also be deactivated. 
         * @summary Deactivate usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUsageMeter(eventSchemaName: string, usageMeterId: string, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.deactivateUsageMeter(eventSchemaName, usageMeterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an usage meter using event schema name and usage meter id.
         * @summary Get usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMeter(eventSchemaName: string, usageMeterId: string, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.getUsageMeter(eventSchemaName, usageMeterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of usage meters associated with an event schema
         * @summary List usage meters for event schema
         * @param {string} eventSchemaName 
         * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by status 
         * @param {'COUNT' | 'SUM'} [aggregations] Filter by aggregations 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMetersForEventSchema(eventSchemaName: string, status?: 'ACTIVE' | 'INACTIVE', aggregations?: 'COUNT' | 'SUM', nextToken?: string, pageSize?: number, options?: any): AxiosPromise<UsageMeterPaginatedResponse> {
            return localVarFp.getUsageMetersForEventSchema(eventSchemaName, status, aggregations, nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * This API lets you update an existing usage meter.
         * @summary Update an usage meter
         * @param {string} eventSchemaName 
         * @param {string} usageMeterId 
         * @param {UpdateUsageMeterRequest} updateUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsageMeter(eventSchemaName: string, usageMeterId: string, updateUsageMeterRequest: UpdateUsageMeterRequest, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.updateUsageMeter(eventSchemaName, usageMeterId, updateUsageMeterRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsageMetersApi - object-oriented interface
 * @export
 * @class UsageMetersApi
 * @extends {BaseAPI}
 */
export class UsageMetersApi extends BaseAPI {
    /**
     * Activate usage meter
     * @summary Activate usage meter
     * @param {string} eventSchemaName 
     * @param {string} usageMeterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public activateUsageMeter(eventSchemaName: string, usageMeterId: string, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).activateUsageMeter(eventSchemaName, usageMeterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an usage meter and associate with an event schema
     * @summary Create an usage meter
     * @param {string} eventSchemaName 
     * @param {CreateUsageMeterRequest} createUsageMeterRequest Payload to create usage meter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public createUsageMeter(eventSchemaName: string, createUsageMeterRequest: CreateUsageMeterRequest, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).createUsageMeter(eventSchemaName, createUsageMeterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Make an existing active usage meter to be inactive Active Usage Meters with active Pricing Plan attached can also be deactivated. 
     * @summary Deactivate usage meter
     * @param {string} eventSchemaName 
     * @param {string} usageMeterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public deactivateUsageMeter(eventSchemaName: string, usageMeterId: string, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).deactivateUsageMeter(eventSchemaName, usageMeterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an usage meter using event schema name and usage meter id.
     * @summary Get usage meter
     * @param {string} eventSchemaName 
     * @param {string} usageMeterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public getUsageMeter(eventSchemaName: string, usageMeterId: string, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).getUsageMeter(eventSchemaName, usageMeterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of usage meters associated with an event schema
     * @summary List usage meters for event schema
     * @param {string} eventSchemaName 
     * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by status 
     * @param {'COUNT' | 'SUM'} [aggregations] Filter by aggregations 
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public getUsageMetersForEventSchema(eventSchemaName: string, status?: 'ACTIVE' | 'INACTIVE', aggregations?: 'COUNT' | 'SUM', nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).getUsageMetersForEventSchema(eventSchemaName, status, aggregations, nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API lets you update an existing usage meter.
     * @summary Update an usage meter
     * @param {string} eventSchemaName 
     * @param {string} usageMeterId 
     * @param {UpdateUsageMeterRequest} updateUsageMeterRequest Payload to create usage meter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public updateUsageMeter(eventSchemaName: string, usageMeterId: string, updateUsageMeterRequest: UpdateUsageMeterRequest, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).updateUsageMeter(eventSchemaName, usageMeterId, updateUsageMeterRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


