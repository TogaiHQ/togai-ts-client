/* tslint:disable */
/* eslint-disable */
/**
 * Togai Apis
 * APIs for Togai App
 *
 * The version of the OpenAPI document: 1.0
 * Contact: engg@togai.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * Structure of an account
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * Identifier of the account
     * @type {string}
     * @memberof Account
     */
    'id': string;
    /**
     * Name of the Account
     * @type {string}
     * @memberof Account
     */
    'name': string;
    /**
     * Identifier of the customer
     * @type {string}
     * @memberof Account
     */
    'customerId': string;
    /**
     * [ISO_4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency in which the account must be invoiced Defaults to Base currency. 
     * @type {string}
     * @memberof Account
     */
    'invoiceCurrency': string;
    /**
     * list of aliases of the account
     * @type {Array<AccountAliases>}
     * @memberof Account
     */
    'aliases'?: Array<AccountAliases>;
    /**
     * Status of the account
     * @type {string}
     * @memberof Account
     */
    'status': AccountStatusEnum;
    /**
     * 
     * @type {Array<CreateEntitySetting>}
     * @memberof Account
     */
    'settings'?: Array<CreateEntitySetting>;
}

export const AccountStatusEnum = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type AccountStatusEnum = typeof AccountStatusEnum[keyof typeof AccountStatusEnum];

/**
 * 
 * @export
 * @interface AccountAliases
 */
export interface AccountAliases {
    /**
     * 
     * @type {string}
     * @memberof AccountAliases
     */
    'alias'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountAliases
     */
    'status'?: AccountAliasesStatusEnum;
}

export const AccountAliasesStatusEnum = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type AccountAliasesStatusEnum = typeof AccountAliasesStatusEnum[keyof typeof AccountAliasesStatusEnum];

/**
 * 
 * @export
 * @interface AccountPaginatedResponse
 */
export interface AccountPaginatedResponse {
    /**
     * 
     * @type {Array<Account>}
     * @memberof AccountPaginatedResponse
     */
    'data'?: Array<Account>;
    /**
     * 
     * @type {string}
     * @memberof AccountPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof AccountPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * Request to activate currencies of a price plan
 * @export
 * @interface ActivatePricePlanRequest
 */
export interface ActivatePricePlanRequest {
    /**
     * List of currencies to activate
     * @type {Array<string>}
     * @memberof ActivatePricePlanRequest
     */
    'currencies': Array<string>;
}
/**
 * Payload to add aliases from account
 * @export
 * @interface AddAccountAliasesRequest
 */
export interface AddAccountAliasesRequest {
    /**
     * List of aliases to add
     * @type {Array<string>}
     * @memberof AddAccountAliasesRequest
     */
    'aliases'?: Array<string>;
}
/**
 * Request to adding currency to a price plan
 * @export
 * @interface AddCurrencyToPricePlanRequest
 */
export interface AddCurrencyToPricePlanRequest {
    /**
     * Currency to be added
     * @type {string}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'currency': string;
    /**
     * List of usage rates
     * @type {Array<UsageRate>}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'usageRates'?: Array<UsageRate>;
    /**
     * Rates for fixed fee rate cards
     * @type {Array<FixedFeeRate>}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'fixedFeeRates'?: Array<FixedFeeRate>;
    /**
     * Rates for license rate cards
     * @type {Array<LicenseRate>}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'licenseRates'?: Array<LicenseRate>;
    /**
     * Rates for billing entitlement rate cards
     * @type {Array<BillingEntitlementRate>}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'billingEntitlementRates'?: Array<BillingEntitlementRate>;
    /**
     * Rates for minimum commitment.
     * @type {number}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'minimumCommitmentRate'?: number;
    /**
     * List of slab rates
     * @type {Array<SlabRate>}
     * @memberof AddCurrencyToPricePlanRequest
     */
    'rateDetailsRate'?: Array<SlabRate>;
}
/**
 * 
 * @export
 * @interface AddOn
 */
export interface AddOn {
    /**
     * Name of addon
     * @type {string}
     * @memberof AddOn
     */
    'name': string;
    /**
     * 
     * @type {AddOnType}
     * @memberof AddOn
     */
    'type': AddOnType;
    /**
     * Id of addon
     * @type {string}
     * @memberof AddOn
     */
    'id': string;
    /**
     * Created Time of addon
     * @type {string}
     * @memberof AddOn
     */
    'createdAt': string;
    /**
     * status of addon
     * @type {string}
     * @memberof AddOn
     */
    'status': AddOnStatusEnum;
}

export const AddOnStatusEnum = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type AddOnStatusEnum = typeof AddOnStatusEnum[keyof typeof AddOnStatusEnum];

/**
 * 
 * @export
 * @interface AddOnAllOf
 */
export interface AddOnAllOf {
    /**
     * Id of addon
     * @type {string}
     * @memberof AddOnAllOf
     */
    'id': string;
    /**
     * Created Time of addon
     * @type {string}
     * @memberof AddOnAllOf
     */
    'createdAt': string;
    /**
     * status of addon
     * @type {string}
     * @memberof AddOnAllOf
     */
    'status': AddOnAllOfStatusEnum;
}

export const AddOnAllOfStatusEnum = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type AddOnAllOfStatusEnum = typeof AddOnAllOfStatusEnum[keyof typeof AddOnAllOfStatusEnum];

/**
 * 
 * @export
 * @interface AddOnPaginatedResponse
 */
export interface AddOnPaginatedResponse {
    /**
     * 
     * @type {Array<AddOn>}
     * @memberof AddOnPaginatedResponse
     */
    'data': Array<AddOn>;
    /**
     * 
     * @type {string}
     * @memberof AddOnPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof AddOnPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * LICENSE: Addon can be used in license rate cards FIXED_FEE: Addon can be used in fixed fee rate cards 
 * @export
 * @enum {string}
 */

export const AddOnType = {
    License: 'LICENSE',
    FixedFee: 'FIXED_FEE'
} as const;

export type AddOnType = typeof AddOnType[keyof typeof AddOnType];


/**
 * Metric to be recorded
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * Name of the event attribute
     * @type {string}
     * @memberof Attribute
     */
    'name': string;
    /**
     * Value of the event attribute
     * @type {string}
     * @memberof Attribute
     */
    'value': string;
    /**
     * Unit with which the attribute value was measured. Natively supported units - \"Meters, Miles, Kilometers, Grams, Kilograms, ounces, Pounds, Minutes, Hours, Seconds, Milliseconds, Microseconds, None\". Clients are free to add any other custom units.
     * @type {string}
     * @memberof Attribute
     */
    'unit'?: string;
}
/**
 * 
 * @export
 * @interface BaseSuccessResponse
 */
export interface BaseSuccessResponse {
    /**
     * 
     * @type {boolean}
     * @memberof BaseSuccessResponse
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface BillingEntitlementRate
 */
export interface BillingEntitlementRate {
    /**
     * 
     * @type {string}
     * @memberof BillingEntitlementRate
     */
    'id': string;
    /**
     * List of slab rates
     * @type {Array<SlabRate>}
     * @memberof BillingEntitlementRate
     */
    'slabRates': Array<SlabRate>;
}
/**
 * 
 * @export
 * @interface BillingEntitlementRateCard
 */
export interface BillingEntitlementRateCard {
    /**
     * 
     * @type {string}
     * @memberof BillingEntitlementRateCard
     */
    'featureId': string;
    /**
     * 
     * @type {Array<FeatureConfig>}
     * @memberof BillingEntitlementRateCard
     */
    'featureConfigs': Array<FeatureConfig>;
    /**
     * A tag string to group rate cards
     * @type {string}
     * @memberof BillingEntitlementRateCard
     */
    'tag'?: string;
    /**
     * 
     * @type {InvoiceTiming}
     * @memberof BillingEntitlementRateCard
     */
    'invoiceTiming': InvoiceTiming;
    /**
     * Name your rate card, this will be used in invoice
     * @type {string}
     * @memberof BillingEntitlementRateCard
     */
    'displayName'?: string;
    /**
     * 
     * @type {RatePlan}
     * @memberof BillingEntitlementRateCard
     */
    'ratePlan': RatePlan;
    /**
     * 
     * @type {Array<RateValue>}
     * @memberof BillingEntitlementRateCard
     */
    'rateValues': Array<RateValue>;
}


/**
 * 
 * @export
 * @interface BillingEntitlementRateCardAllOf
 */
export interface BillingEntitlementRateCardAllOf {
    /**
     * A tag string to group rate cards
     * @type {string}
     * @memberof BillingEntitlementRateCardAllOf
     */
    'tag'?: string;
    /**
     * 
     * @type {InvoiceTiming}
     * @memberof BillingEntitlementRateCardAllOf
     */
    'invoiceTiming': InvoiceTiming;
    /**
     * Name your rate card, this will be used in invoice
     * @type {string}
     * @memberof BillingEntitlementRateCardAllOf
     */
    'displayName'?: string;
    /**
     * 
     * @type {RatePlan}
     * @memberof BillingEntitlementRateCardAllOf
     */
    'ratePlan': RatePlan;
    /**
     * 
     * @type {Array<RateValue>}
     * @memberof BillingEntitlementRateCardAllOf
     */
    'rateValues': Array<RateValue>;
}


/**
 * 
 * @export
 * @interface BillingEntitlementRevenueSummary
 */
export interface BillingEntitlementRevenueSummary {
    /**
     * 
     * @type {number}
     * @memberof BillingEntitlementRevenueSummary
     */
    'revenue': number;
}
/**
 * Request to get revenue details
 * @export
 * @interface CalculateRevenueRequest
 */
export interface CalculateRevenueRequest {
    /**
     * 
     * @type {CurrencyConfig}
     * @memberof CalculateRevenueRequest
     */
    'currencyConfig': CurrencyConfig;
    /**
     * 
     * @type {PricePlanDetailsConfig}
     * @memberof CalculateRevenueRequest
     */
    'pricePlanDetailsConfig': PricePlanDetailsConfig;
    /**
     * 
     * @type {UsageConfig}
     * @memberof CalculateRevenueRequest
     */
    'usageConfig': UsageConfig;
    /**
     * 
     * @type {LicenseEntriesConfig}
     * @memberof CalculateRevenueRequest
     */
    'licenseEntriesConfig': LicenseEntriesConfig;
    /**
     * 
     * @type {ProrationConfig}
     * @memberof CalculateRevenueRequest
     */
    'prorationConfig'?: ProrationConfig;
}
/**
 * 
 * @export
 * @interface CalculateRevenueResponse
 */
export interface CalculateRevenueResponse {
    /**
     * 
     * @type {string}
     * @memberof CalculateRevenueResponse
     */
    'currency': string;
    /**
     * 
     * @type {UsageLookupRange}
     * @memberof CalculateRevenueResponse
     */
    'usageLookupRange'?: UsageLookupRange;
    /**
     * 
     * @type {PricePlanDetails}
     * @memberof CalculateRevenueResponse
     */
    'pricePlanDetails': PricePlanDetails;
    /**
     * 
     * @type {Array<RevenueInfo>}
     * @memberof CalculateRevenueResponse
     */
    'revenueInfo': Array<RevenueInfo>;
}
/**
 * 
 * @export
 * @interface Computation
 */
export interface Computation {
    /**
     * Optional identifier describing the matcher and computation pair
     * @type {string}
     * @memberof Computation
     */
    'id'?: string;
    /**
     * Condition to be applied on event. Upon matching it the corresponding computation will be considered for usage_meter unit calculation. The result of the matcher needs to be [truthy](https://jsonlogic.com/truthy.html) in order to be considered as a match. 
     * @type {string}
     * @memberof Computation
     */
    'matcher'?: string;
    /**
     * Computation to be applied on an event if it matches the matcher. In case of a COUNT aggregation type, computation should be passed as \'1\' 
     * @type {string}
     * @memberof Computation
     */
    'computation': string;
    /**
     * The order in which multiple matched computations will get evaluated
     * @type {number}
     * @memberof Computation
     */
    'order': number;
}
/**
 * Payload to create account
 * @export
 * @interface CreateAccountRequest
 */
export interface CreateAccountRequest {
    /**
     * Identifier of the account
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'id': string;
    /**
     * Name of the Account
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'name': string;
    /**
     * Use [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code in which the account must be invoiced.   For example: AED is the currency code for United Arab Emirates dirham. 
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'invoiceCurrency'?: string;
    /**
     * Aliases are tags that are associated with an account. Multiple aliases are allowed for a single account.
     * @type {Array<string>}
     * @memberof CreateAccountRequest
     */
    'aliases'?: Array<string>;
    /**
     * 
     * @type {Array<CreateEntitySetting>}
     * @memberof CreateAccountRequest
     */
    'settings'?: Array<CreateEntitySetting>;
    /**
     * Customer Identifier for whom the account is being created
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'customerId': string;
}
/**
 * Payload to create account
 * @export
 * @interface CreateAccountRequestWithoutCustomerId
 */
export interface CreateAccountRequestWithoutCustomerId {
    /**
     * Identifier of the account
     * @type {string}
     * @memberof CreateAccountRequestWithoutCustomerId
     */
    'id': string;
    /**
     * Name of the Account
     * @type {string}
     * @memberof CreateAccountRequestWithoutCustomerId
     */
    'name': string;
    /**
     * Use [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code in which the account must be invoiced.   For example: AED is the currency code for United Arab Emirates dirham. 
     * @type {string}
     * @memberof CreateAccountRequestWithoutCustomerId
     */
    'invoiceCurrency'?: string;
    /**
     * Aliases are tags that are associated with an account. Multiple aliases are allowed for a single account.
     * @type {Array<string>}
     * @memberof CreateAccountRequestWithoutCustomerId
     */
    'aliases'?: Array<string>;
    /**
     * 
     * @type {Array<CreateEntitySetting>}
     * @memberof CreateAccountRequestWithoutCustomerId
     */
    'settings'?: Array<CreateEntitySetting>;
}
/**
 * Request to create an addon
 * @export
 * @interface CreateAddOnRequest
 */
export interface CreateAddOnRequest {
    /**
     * Name of addon
     * @type {string}
     * @memberof CreateAddOnRequest
     */
    'name': string;
    /**
     * 
     * @type {AddOnType}
     * @memberof CreateAddOnRequest
     */
    'type': AddOnType;
}


/**
 * Payload to grant Credits
 * @export
 * @interface CreateCreditRequest
 */
export interface CreateCreditRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCreditRequest
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCreditRequest
     */
    'purpose': string;
    /**
     * List of entity ids for which the credit is applicable. If null or empty, the credit is applicable to all ids. This list can accept special values like: - ALL_USAGE_METER_RATE_CARDS: To apply the credit to all usage meter rate cards - ALL_FIXED_FEE_RATE_CARDS: To apply the credit to all fixed fee rate cards 
     * @type {Array<string>}
     * @memberof CreateCreditRequest
     */
    'applicableEntityIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateCreditRequest
     */
    'effectiveFrom': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCreditRequest
     */
    'effectiveUntil'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateCreditRequest
     */
    'creditAmount': number;
    /**
     * 
     * @type {number}
     * @memberof CreateCreditRequest
     */
    'priority': number;
}
/**
 * Payload to create customer
 * @export
 * @interface CreateCustomerRequest
 */
export interface CreateCustomerRequest {
    /**
     * Customer identifier
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'id': string;
    /**
     * Name of the Customer
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'name': string;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'primaryEmail': string;
    /**
     * billing address of the customer
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'billingAddress': string;
    /**
     * 
     * @type {Array<CreateEntitySetting>}
     * @memberof CreateCustomerRequest
     */
    'settings'?: Array<CreateEntitySetting>;
    /**
     * 
     * @type {CreateAccountRequestWithoutCustomerId}
     * @memberof CreateCustomerRequest
     */
    'account'?: CreateAccountRequestWithoutCustomerId;
}
/**
 * 
 * @export
 * @interface CreateCustomerResponse
 */
export interface CreateCustomerResponse {
    /**
     * Identifier of customer
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'id': string;
    /**
     * Name of the Customer
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'name': string;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'primaryEmail': string;
    /**
     * billing address of the customer
     * @type {string}
     * @memberof CreateCustomerResponse
     */
    'billingAddress': string;
    /**
     * 
     * @type {Array<CreateEntitySetting>}
     * @memberof CreateCustomerResponse
     */
    'settings'?: Array<CreateEntitySetting>;
    /**
     * 
     * @type {Account}
     * @memberof CreateCustomerResponse
     */
    'account'?: Account;
}
/**
 * Represents a setting
 * @export
 * @interface CreateEntitySetting
 */
export interface CreateEntitySetting {
    /**
     * 
     * @type {string}
     * @memberof CreateEntitySetting
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEntitySetting
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEntitySetting
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEntitySetting
     */
    'name': string;
    /**
     * 
     * @type {SettingDataType}
     * @memberof CreateEntitySetting
     */
    'dataType': SettingDataType;
}


/**
 * Request to create event schema
 * @export
 * @interface CreateEventSchemaRequest
 */
export interface CreateEventSchemaRequest {
    /**
     * Name of the event. Must be unique for an organization.
     * @type {string}
     * @memberof CreateEventSchemaRequest
     */
    'name': string;
    /**
     * Description of the event
     * @type {string}
     * @memberof CreateEventSchemaRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<EventAttributeSchema>}
     * @memberof CreateEventSchemaRequest
     */
    'attributes': Array<EventAttributeSchema>;
    /**
     * 
     * @type {Array<DimensionsSchema>}
     * @memberof CreateEventSchemaRequest
     */
    'dimensions': Array<DimensionsSchema>;
    /**
     * 
     * @type {Enrichments}
     * @memberof CreateEventSchemaRequest
     */
    'enrichments'?: Enrichments;
}
/**
 * Create a Feature stand-alone or associate it with schemas
 * @export
 * @interface CreateFeatureRequest
 */
export interface CreateFeatureRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateFeatureRequest
     */
    'name': string;
    /**
     * Association of a feature with event_schemas
     * @type {Array<EventSchemasForFeature>}
     * @memberof CreateFeatureRequest
     */
    'schemaAssociations': Array<EventSchemasForFeature>;
}
/**
 * 
 * @export
 * @interface CreatePricePlanDetails
 */
export interface CreatePricePlanDetails {
    /**
     * 
     * @type {PricingCycleConfig}
     * @memberof CreatePricePlanDetails
     */
    'pricingCycleConfig'?: PricingCycleConfig;
    /**
     * List of currencies supported by the price plan
     * @type {Array<string>}
     * @memberof CreatePricePlanDetails
     */
    'supportedCurrencies': Array<string>;
    /**
     * List of usage rate cards
     * @type {Array<UsageRateCard>}
     * @memberof CreatePricePlanDetails
     */
    'usageRateCards'?: Array<UsageRateCard>;
    /**
     * 
     * @type {Array<FixedFeeRateCard>}
     * @memberof CreatePricePlanDetails
     */
    'fixedFeeRateCards'?: Array<FixedFeeRateCard>;
    /**
     * 
     * @type {Array<LicenseRateCard>}
     * @memberof CreatePricePlanDetails
     */
    'licenseRateCards'?: Array<LicenseRateCard>;
    /**
     * 
     * @type {Array<BillingEntitlementRateCard>}
     * @memberof CreatePricePlanDetails
     */
    'billingEntitlementRateCards'?: Array<BillingEntitlementRateCard>;
    /**
     * 
     * @type {MinimumCommitment}
     * @memberof CreatePricePlanDetails
     */
    'minimumCommitment'?: MinimumCommitment;
    /**
     * 
     * @type {RateDetails}
     * @memberof CreatePricePlanDetails
     */
    'rateDetails'?: RateDetails;
    /**
     * 
     * @type {Array<EntitlementRateCard>}
     * @memberof CreatePricePlanDetails
     */
    'entitlementRateCards'?: Array<EntitlementRateCard>;
    /**
     * 
     * @type {PricePlanType}
     * @memberof CreatePricePlanDetails
     */
    'type'?: PricePlanType;
}


/**
 * 
 * @export
 * @interface CreatePricePlanDetailsOverride
 */
export interface CreatePricePlanDetailsOverride {
    /**
     * 
     * @type {PricingCycleConfig}
     * @memberof CreatePricePlanDetailsOverride
     */
    'pricingCycleConfig'?: PricingCycleConfig;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreatePricePlanDetailsOverride
     */
    'supportedCurrencies'?: Array<string>;
    /**
     * 
     * @type {Array<UsageRateCard>}
     * @memberof CreatePricePlanDetailsOverride
     */
    'usageRateCards'?: Array<UsageRateCard>;
    /**
     * 
     * @type {Array<BillingEntitlementRateCard>}
     * @memberof CreatePricePlanDetailsOverride
     */
    'billingEntitlementRateCards'?: Array<BillingEntitlementRateCard>;
    /**
     * 
     * @type {Array<FixedFeeRateCard>}
     * @memberof CreatePricePlanDetailsOverride
     */
    'fixedFeeRateCards'?: Array<FixedFeeRateCard>;
    /**
     * 
     * @type {Array<LicenseRateCard>}
     * @memberof CreatePricePlanDetailsOverride
     */
    'licenseRateCards'?: Array<LicenseRateCard>;
    /**
     * 
     * @type {MinimumCommitment}
     * @memberof CreatePricePlanDetailsOverride
     */
    'minimumCommitment'?: MinimumCommitment;
    /**
     * 
     * @type {RateDetails}
     * @memberof CreatePricePlanDetailsOverride
     */
    'rateDetails'?: RateDetails;
    /**
     * 
     * @type {Array<EntitlementRateCard>}
     * @memberof CreatePricePlanDetailsOverride
     */
    'entitlementRateCards'?: Array<EntitlementRateCard>;
}
/**
 * Request to migrate all account associations of a price plan to another price plan
 * @export
 * @interface CreatePricePlanMigrationRequest
 */
export interface CreatePricePlanMigrationRequest {
    /**
     * Id of source price plan
     * @type {string}
     * @memberof CreatePricePlanMigrationRequest
     */
    'sourceId': string;
    /**
     * Version of the source price plan
     * @type {number}
     * @memberof CreatePricePlanMigrationRequest
     */
    'sourceVersion': number;
    /**
     * Id of target price plan
     * @type {string}
     * @memberof CreatePricePlanMigrationRequest
     */
    'targetId': string;
    /**
     * Version of the target price plan
     * @type {number}
     * @memberof CreatePricePlanMigrationRequest
     */
    'targetVersion': number;
    /**
     * 
     * @type {string}
     * @memberof CreatePricePlanMigrationRequest
     */
    'migrationMode': CreatePricePlanMigrationRequestMigrationModeEnum;
}

export const CreatePricePlanMigrationRequestMigrationModeEnum = {
    Immediate: 'IMMEDIATE',
    ImmediateIgnoreOverride: 'IMMEDIATE_IGNORE_OVERRIDE',
    NextCycle: 'NEXT_CYCLE',
    NextCycleIgnoreOverride: 'NEXT_CYCLE_IGNORE_OVERRIDE'
} as const;

export type CreatePricePlanMigrationRequestMigrationModeEnum = typeof CreatePricePlanMigrationRequestMigrationModeEnum[keyof typeof CreatePricePlanMigrationRequestMigrationModeEnum];

/**
 * Request to create a price plan
 * @export
 * @interface CreatePricePlanRequest
 */
export interface CreatePricePlanRequest {
    /**
     * Name of the price plan
     * @type {string}
     * @memberof CreatePricePlanRequest
     */
    'name': string;
    /**
     * Description of price plan
     * @type {string}
     * @memberof CreatePricePlanRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePricePlanRequest
     */
    'type'?: CreatePricePlanRequestTypeEnum;
    /**
     * 
     * @type {CreatePricePlanDetails}
     * @memberof CreatePricePlanRequest
     */
    'pricePlanDetails': CreatePricePlanDetails;
}

export const CreatePricePlanRequestTypeEnum = {
    Billing: 'BILLING',
    Entitlement: 'ENTITLEMENT'
} as const;

export type CreatePricePlanRequestTypeEnum = typeof CreatePricePlanRequestTypeEnum[keyof typeof CreatePricePlanRequestTypeEnum];

/**
 * Create a purchase for an account
 * @export
 * @interface CreatePurchaseRequest
 */
export interface CreatePurchaseRequest {
    /**
     * Id of the price plan
     * @type {string}
     * @memberof CreatePurchaseRequest
     */
    'pricePlanId': string;
    /**
     * 
     * @type {number}
     * @memberof CreatePurchaseRequest
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof CreatePurchaseRequest
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {PurchasePlanOverride}
     * @memberof CreatePurchaseRequest
     */
    'purchasePlanOverride'?: PurchasePlanOverride;
}
/**
 * Request to create usage meter
 * @export
 * @interface CreateUsageMeterRequest
 */
export interface CreateUsageMeterRequest {
    /**
     * Name of the event. Must be unique for an organization.
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'name': string;
    /**
     * Description of the event
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'description'?: string;
    /**
     * Type of usage meter
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'type': CreateUsageMeterRequestTypeEnum;
    /**
     * Aggregation to be applied on usage meter result
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'aggregation': CreateUsageMeterRequestAggregationEnum;
    /**
     * 
     * @type {Array<Computation>}
     * @memberof CreateUsageMeterRequest
     */
    'computations'?: Array<Computation>;
    /**
     * Event Schema Identifier
     * @type {string}
     * @memberof CreateUsageMeterRequest
     */
    'eventSchemaName': string;
}

export const CreateUsageMeterRequestTypeEnum = {
    Counter: 'COUNTER'
} as const;

export type CreateUsageMeterRequestTypeEnum = typeof CreateUsageMeterRequestTypeEnum[keyof typeof CreateUsageMeterRequestTypeEnum];
export const CreateUsageMeterRequestAggregationEnum = {
    Count: 'COUNT',
    Sum: 'SUM'
} as const;

export type CreateUsageMeterRequestAggregationEnum = typeof CreateUsageMeterRequestAggregationEnum[keyof typeof CreateUsageMeterRequestAggregationEnum];

/**
 * 
 * @export
 * @interface Credit
 */
export interface Credit {
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'purpose': string;
    /**
     * List of entity ids for which the credit is applicable. If null or empty, the credit is applicable to all ids. This list can accept special values like: - ALL_USAGE_METER_RATE_CARDS: To apply the credit to all usage meter rate cards - ALL_FIXED_FEE_RATE_CARDS: To apply the credit to all fixed fee rate cards 
     * @type {Array<string>}
     * @memberof Credit
     */
    'applicableEntityIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'effectiveFrom': string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'effectiveUntil'?: string;
    /**
     * 
     * @type {number}
     * @memberof Credit
     */
    'creditAmount': number;
    /**
     * 
     * @type {number}
     * @memberof Credit
     */
    'priority': number;
    /**
     * Identifier of credits
     * @type {string}
     * @memberof Credit
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'customerId': string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'status': CreditStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'creditUnit'?: string;
    /**
     * 
     * @type {number}
     * @memberof Credit
     */
    'holdAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Credit
     */
    'consumedAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'updatedAt'?: string;
}

export const CreditStatusEnum = {
    Active: 'ACTIVE',
    Consumed: 'CONSUMED',
    Expired: 'EXPIRED',
    Voided: 'VOIDED'
} as const;

export type CreditStatusEnum = typeof CreditStatusEnum[keyof typeof CreditStatusEnum];

/**
 * 
 * @export
 * @interface CreditAllOf
 */
export interface CreditAllOf {
    /**
     * Identifier of credits
     * @type {string}
     * @memberof CreditAllOf
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreditAllOf
     */
    'customerId': string;
    /**
     * 
     * @type {string}
     * @memberof CreditAllOf
     */
    'status': CreditAllOfStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CreditAllOf
     */
    'creditUnit'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditAllOf
     */
    'holdAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreditAllOf
     */
    'consumedAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreditAllOf
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CreditAllOf
     */
    'updatedAt'?: string;
}

export const CreditAllOfStatusEnum = {
    Active: 'ACTIVE',
    Consumed: 'CONSUMED',
    Expired: 'EXPIRED',
    Voided: 'VOIDED'
} as const;

export type CreditAllOfStatusEnum = typeof CreditAllOfStatusEnum[keyof typeof CreditAllOfStatusEnum];

/**
 * Credit Balance response
 * @export
 * @interface CreditBalanceResponse
 */
export interface CreditBalanceResponse {
    /**
     * 
     * @type {number}
     * @memberof CreditBalanceResponse
     */
    'activeCredits': number;
    /**
     * 
     * @type {number}
     * @memberof CreditBalanceResponse
     */
    'availableBalance': number;
    /**
     * 
     * @type {number}
     * @memberof CreditBalanceResponse
     */
    'runningBalance': number;
    /**
     * 
     * @type {number}
     * @memberof CreditBalanceResponse
     */
    'inapplicableCredits': number;
    /**
     * 
     * @type {string}
     * @memberof CreditBalanceResponse
     */
    'unit': string;
}
/**
 * 
 * @export
 * @interface CreditDetailsResponse
 */
export interface CreditDetailsResponse {
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'purpose': string;
    /**
     * List of entity ids for which the credit is applicable. If null or empty, the credit is applicable to all ids. This list can accept special values like: - ALL_USAGE_METER_RATE_CARDS: To apply the credit to all usage meter rate cards - ALL_FIXED_FEE_RATE_CARDS: To apply the credit to all fixed fee rate cards 
     * @type {Array<string>}
     * @memberof CreditDetailsResponse
     */
    'applicableEntityIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'effectiveFrom': string;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'effectiveUntil'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditDetailsResponse
     */
    'creditAmount': number;
    /**
     * 
     * @type {number}
     * @memberof CreditDetailsResponse
     */
    'priority': number;
    /**
     * Identifier of credits
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'customerId': string;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'status': CreditDetailsResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'creditUnit'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditDetailsResponse
     */
    'holdAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreditDetailsResponse
     */
    'consumedAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CreditDetailsResponse
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {Array<CreditTransaction>}
     * @memberof CreditDetailsResponse
     */
    'transactions': Array<CreditTransaction>;
}

export const CreditDetailsResponseStatusEnum = {
    Active: 'ACTIVE',
    Consumed: 'CONSUMED',
    Expired: 'EXPIRED',
    Voided: 'VOIDED'
} as const;

export type CreditDetailsResponseStatusEnum = typeof CreditDetailsResponseStatusEnum[keyof typeof CreditDetailsResponseStatusEnum];

/**
 * 
 * @export
 * @interface CreditDetailsResponseAllOf
 */
export interface CreditDetailsResponseAllOf {
    /**
     * 
     * @type {Array<CreditTransaction>}
     * @memberof CreditDetailsResponseAllOf
     */
    'transactions': Array<CreditTransaction>;
}
/**
 * 
 * @export
 * @interface CreditTransaction
 */
export interface CreditTransaction {
    /**
     * Identifier of credit transactions
     * @type {string}
     * @memberof CreditTransaction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreditTransaction
     */
    'creditId': string;
    /**
     * 
     * @type {string}
     * @memberof CreditTransaction
     */
    'transactionType': CreditTransactionTransactionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreditTransaction
     */
    'invoiceId'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditTransaction
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreditTransaction
     */
    'createdAt': string;
}

export const CreditTransactionTransactionTypeEnum = {
    Credited: 'CREDITED',
    Debited: 'DEBITED',
    Expired: 'EXPIRED',
    Voided: 'VOIDED'
} as const;

export type CreditTransactionTransactionTypeEnum = typeof CreditTransactionTransactionTypeEnum[keyof typeof CreditTransactionTransactionTypeEnum];

/**
 * Configuration for getting the currency
 * @export
 * @interface CurrencyConfig
 */
export interface CurrencyConfig {
    /**
     * Mode to get the currency - CUSTOM: Use the currency provided in the request - ACCOUNT_INVOICE: Use the invoice currency of the given account 
     * @type {string}
     * @memberof CurrencyConfig
     */
    'mode': CurrencyConfigModeEnum;
    /**
     * Currency to be used, this will be considered if mode is CUSTOM
     * @type {string}
     * @memberof CurrencyConfig
     */
    'currency'?: string;
    /**
     * Id of the account of which invoice currency will be used, this will be considered if mode is ACCOUNT_INVOICE
     * @type {string}
     * @memberof CurrencyConfig
     */
    'accountId'?: string;
}

export const CurrencyConfigModeEnum = {
    Custom: 'CUSTOM',
    AccountInvoice: 'ACCOUNT_INVOICE'
} as const;

export type CurrencyConfigModeEnum = typeof CurrencyConfigModeEnum[keyof typeof CurrencyConfigModeEnum];

/**
 * 
 * @export
 * @interface CurrencyRateValue
 */
export interface CurrencyRateValue {
    /**
     * 
     * @type {string}
     * @memberof CurrencyRateValue
     */
    'currency': string;
    /**
     * 
     * @type {number}
     * @memberof CurrencyRateValue
     */
    'rate': number;
}
/**
 * Structure of customer
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * Identifier of customer
     * @type {string}
     * @memberof Customer
     */
    'id': string;
    /**
     * Name of the Customer
     * @type {string}
     * @memberof Customer
     */
    'name': string;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof Customer
     */
    'primaryEmail': string;
    /**
     * billing address of the customer
     * @type {string}
     * @memberof Customer
     */
    'billingAddress': string;
    /**
     * Status of the customer
     * @type {string}
     * @memberof Customer
     */
    'status': CustomerStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'updatedAt': string;
}

export const CustomerStatusEnum = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type CustomerStatusEnum = typeof CustomerStatusEnum[keyof typeof CustomerStatusEnum];

/**
 * 
 * @export
 * @interface CustomerPaginatedResponse
 */
export interface CustomerPaginatedResponse {
    /**
     * 
     * @type {Array<Customer>}
     * @memberof CustomerPaginatedResponse
     */
    'data'?: Array<Customer>;
    /**
     * 
     * @type {string}
     * @memberof CustomerPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof CustomerPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * 
 * @export
 * @interface Dependency
 */
export interface Dependency {
    /**
     * 
     * @type {string}
     * @memberof Dependency
     */
    'type': DependencyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Dependency
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof Dependency
     */
    'name': string;
}

export const DependencyTypeEnum = {
    Setting: 'SETTING'
} as const;

export type DependencyTypeEnum = typeof DependencyTypeEnum[keyof typeof DependencyTypeEnum];

/**
 * Structure of dimensions
 * @export
 * @interface DimensionsSchema
 */
export interface DimensionsSchema {
    /**
     * Name of the event dimension
     * @type {string}
     * @memberof DimensionsSchema
     */
    'name': string;
}
/**
 * Request to dis/associate one or more schedules to an account
 * @export
 * @interface EditPricingScheduleRequest
 */
export interface EditPricingScheduleRequest {
    /**
     * 
     * @type {Array<UpdatePricingScheduleRequest>}
     * @memberof EditPricingScheduleRequest
     */
    'edits': Array<UpdatePricingScheduleRequest>;
}
/**
 * enriched field
 * @export
 * @interface EnrichedField
 */
export interface EnrichedField {
    /**
     * 
     * @type {string}
     * @memberof EnrichedField
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EnrichedField
     */
    'type': EnrichedFieldTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EnrichedField
     */
    'value': string;
}

export const EnrichedFieldTypeEnum = {
    Attribute: 'ATTRIBUTE',
    Dimension: 'DIMENSION'
} as const;

export type EnrichedFieldTypeEnum = typeof EnrichedFieldTypeEnum[keyof typeof EnrichedFieldTypeEnum];

/**
 * enrichment dependency
 * @export
 * @interface EnrichmentDependency
 */
export interface EnrichmentDependency {
    /**
     * 
     * @type {string}
     * @memberof EnrichmentDependency
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof EnrichmentDependency
     */
    'type': EnrichmentDependencyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EnrichmentDependency
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnrichmentDependency
     */
    'value': string;
}

export const EnrichmentDependencyTypeEnum = {
    Setting: 'SETTING'
} as const;

export type EnrichmentDependencyTypeEnum = typeof EnrichmentDependencyTypeEnum[keyof typeof EnrichmentDependencyTypeEnum];

/**
 * 
 * @export
 * @interface Enrichments
 */
export interface Enrichments {
    /**
     * 
     * @type {Array<Dependency>}
     * @memberof Enrichments
     */
    'dependencies'?: Array<Dependency>;
    /**
     * 
     * @type {Array<Field>}
     * @memberof Enrichments
     */
    'fields': Array<Field>;
}
/**
 * Entitlement type rate card
 * @export
 * @interface EntitlementRateCard
 */
export interface EntitlementRateCard {
    /**
     * 
     * @type {string}
     * @memberof EntitlementRateCard
     */
    'featureId': string;
    /**
     * 
     * @type {Array<FeatureConfig>}
     * @memberof EntitlementRateCard
     */
    'featureConfigs': Array<FeatureConfig>;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * error description
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
}
/**
 * Contents of the event
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * Name of the Event Schema.  Know more about [event schema](https://docs.togai.com/docs/event-schemas) 
     * @type {string}
     * @memberof Event
     */
    'schemaName': string;
    /**
     * A unique value to identify the event instance. This unique value should be generated by the client and it acts as the **idempotency key**. Togai server will use this key to recognize subsequent retries of the same request and avoid metering multiple times for that same request. This id can be created in any format but we recommend using UUIDv4 to reduce collision occurance.    NOTE1: Expiry time for idempotency validation will be until the end of the billing cycle. Any request which comes after the billing cycle with the same id will be treated as new request and ingested for metering.   NOTE2: If the billing cycle is not configured for the idempotency validation will be until **10 days** of the event ingestion.
     * @type {string}
     * @memberof Event
     */
    'id': string;
    /**
     * Source time stamp of the event. This timestamp must be in ISO 8601 format.
     * @type {string}
     * @memberof Event
     */
    'timestamp': string;
    /**
     * The event will be associated with the provided account
     * @type {string}
     * @memberof Event
     */
    'accountId': string;
    /**
     * Attributes are numeric values. It can be usage metric which you push to Togai
     * @type {Array<Attribute>}
     * @memberof Event
     */
    'attributes': Array<Attribute>;
    /**
     * Dimensions are tags/labels associated with the events.
     * @type {{ [key: string]: string; }}
     * @memberof Event
     */
    'dimensions': { [key: string]: string; };
}
/**
 * Structure of an event attribute
 * @export
 * @interface EventAttributeSchema
 */
export interface EventAttributeSchema {
    /**
     * Name of the event attribute.
     * @type {string}
     * @memberof EventAttributeSchema
     */
    'name': string;
    /**
     * Unit for the attribute
     * @type {string}
     * @memberof EventAttributeSchema
     */
    'defaultUnit'?: string;
}
/**
 * Information related to ingestion of an event
 * @export
 * @interface EventPipelineInfo
 */
export interface EventPipelineInfo {
    /**
     * 
     * @type {EventPipelineInfoEventSchema}
     * @memberof EventPipelineInfo
     */
    'eventSchema'?: EventPipelineInfoEventSchema;
    /**
     * 
     * @type {Array<EventPipelineInfoUsageMeters>}
     * @memberof EventPipelineInfo
     */
    'usageMeters'?: Array<EventPipelineInfoUsageMeters>;
    /**
     * 
     * @type {Array<EventPipelineInfoPricePlans>}
     * @memberof EventPipelineInfo
     */
    'pricePlans'?: Array<EventPipelineInfoPricePlans>;
    /**
     * 
     * @type {EventPipelineInfoAccount}
     * @memberof EventPipelineInfo
     */
    'account'?: EventPipelineInfoAccount;
    /**
     * 
     * @type {EventPipelineInfoCustomer}
     * @memberof EventPipelineInfo
     */
    'customer'?: EventPipelineInfoCustomer;
    /**
     * 
     * @type {EventPipelineInfoFeatureDetails}
     * @memberof EventPipelineInfo
     */
    'featureDetails'?: EventPipelineInfoFeatureDetails;
    /**
     * 
     * @type {EventPipelineInfoEnrichments}
     * @memberof EventPipelineInfo
     */
    'enrichments'?: EventPipelineInfoEnrichments;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoAccount
 */
export interface EventPipelineInfoAccount {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoAccount
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoAccount
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoCustomer
 */
export interface EventPipelineInfoCustomer {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoCustomer
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoCustomer
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoEnrichments
 */
export interface EventPipelineInfoEnrichments {
    /**
     * 
     * @type {Array<EnrichedField>}
     * @memberof EventPipelineInfoEnrichments
     */
    'attributes'?: Array<EnrichedField>;
    /**
     * 
     * @type {Array<EnrichedField>}
     * @memberof EventPipelineInfoEnrichments
     */
    'dimensions'?: Array<EnrichedField>;
    /**
     * 
     * @type {Array<EnrichmentDependency>}
     * @memberof EventPipelineInfoEnrichments
     */
    'dependencies'?: Array<EnrichmentDependency>;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoEventSchema
 */
export interface EventPipelineInfoEventSchema {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoEventSchema
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof EventPipelineInfoEventSchema
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoFeatureDetails
 */
export interface EventPipelineInfoFeatureDetails {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoFeatureDetails
     */
    'featureId': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoFeatureDetails
     */
    'mappedAttribute': string;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoPricePlans
 */
export interface EventPipelineInfoPricePlans {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlans
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlans
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlans
     */
    'scheduleId': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlans
     */
    'cycleStart': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoPricePlans
     */
    'cycleEnd': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventPipelineInfoPricePlans
     */
    'usageMeters'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EventPipelineInfoUsageMeters
 */
export interface EventPipelineInfoUsageMeters {
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoUsageMeters
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoUsageMeters
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof EventPipelineInfoUsageMeters
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof EventPipelineInfoUsageMeters
     */
    'status': EventPipelineInfoUsageMetersStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof EventPipelineInfoUsageMeters
     */
    'units'?: number;
}

export const EventPipelineInfoUsageMetersStatusEnum = {
    FilteredOut: 'PROCESSED_FILTERED_OUT',
    UnitsComputed: 'PROCESSED_UNITS_COMPUTED'
} as const;

export type EventPipelineInfoUsageMetersStatusEnum = typeof EventPipelineInfoUsageMetersStatusEnum[keyof typeof EventPipelineInfoUsageMetersStatusEnum];

/**
 * Structure of an event schema
 * @export
 * @interface EventSchema
 */
export interface EventSchema {
    /**
     * Name of the event. Must be unique for an organization.
     * @type {string}
     * @memberof EventSchema
     */
    'name': string;
    /**
     * Description of the event
     * @type {string}
     * @memberof EventSchema
     */
    'description'?: string;
    /**
     * Version of event schema
     * @type {number}
     * @memberof EventSchema
     */
    'version': number;
    /**
     * Status of event schema * DRAFT - Schema is in draft state  * ACTIVE - Schema is currently active  * INACTIVE - Schema is currently inactive * ARCHIVED - Older version of event schema 
     * @type {string}
     * @memberof EventSchema
     */
    'status'?: EventSchemaStatusEnum;
    /**
     * 
     * @type {Array<EventAttributeSchema>}
     * @memberof EventSchema
     */
    'attributes'?: Array<EventAttributeSchema>;
    /**
     * 
     * @type {Array<DimensionsSchema>}
     * @memberof EventSchema
     */
    'dimensions'?: Array<DimensionsSchema>;
    /**
     * 
     * @type {FeatureDetails}
     * @memberof EventSchema
     */
    'featureDetails'?: FeatureDetails;
    /**
     * 
     * @type {Enrichments}
     * @memberof EventSchema
     */
    'enrichments'?: Enrichments;
    /**
     * 
     * @type {string}
     * @memberof EventSchema
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSchema
     */
    'updatedAt'?: string;
}

export const EventSchemaStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type EventSchemaStatusEnum = typeof EventSchemaStatusEnum[keyof typeof EventSchemaStatusEnum];

/**
 * 
 * @export
 * @interface EventSchemaListData
 */
export interface EventSchemaListData {
    /**
     * Name of the event. Must be unique for an organization.
     * @type {string}
     * @memberof EventSchemaListData
     */
    'name': string;
    /**
     * Description of the event
     * @type {string}
     * @memberof EventSchemaListData
     */
    'description'?: string;
    /**
     * Version of event schema
     * @type {number}
     * @memberof EventSchemaListData
     */
    'version': number;
    /**
     * Status of event schema * DRAFT - Schema is in draft state  * ACTIVE - Schema is currently active  * INACTIVE - Schema is currently inactive * ARCHIVED - Older version of event schema 
     * @type {string}
     * @memberof EventSchemaListData
     */
    'status'?: EventSchemaListDataStatusEnum;
    /**
     * 
     * @type {Array<EventAttributeSchema>}
     * @memberof EventSchemaListData
     */
    'attributes'?: Array<EventAttributeSchema>;
    /**
     * 
     * @type {Array<DimensionsSchema>}
     * @memberof EventSchemaListData
     */
    'dimensions'?: Array<DimensionsSchema>;
    /**
     * 
     * @type {FeatureDetails}
     * @memberof EventSchemaListData
     */
    'featureDetails'?: FeatureDetails;
    /**
     * 
     * @type {Enrichments}
     * @memberof EventSchemaListData
     */
    'enrichments'?: Enrichments;
    /**
     * 
     * @type {string}
     * @memberof EventSchemaListData
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSchemaListData
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventSchemaListData
     */
    'usageMetersCount'?: number;
}

export const EventSchemaListDataStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type EventSchemaListDataStatusEnum = typeof EventSchemaListDataStatusEnum[keyof typeof EventSchemaListDataStatusEnum];

/**
 * 
 * @export
 * @interface EventSchemaListDataAllOf
 */
export interface EventSchemaListDataAllOf {
    /**
     * 
     * @type {number}
     * @memberof EventSchemaListDataAllOf
     */
    'usageMetersCount'?: number;
}
/**
 * 
 * @export
 * @interface EventSchemaListPaginatedResponse
 */
export interface EventSchemaListPaginatedResponse {
    /**
     * 
     * @type {Array<EventSchemaListData>}
     * @memberof EventSchemaListPaginatedResponse
     */
    'data'?: Array<EventSchemaListData>;
    /**
     * 
     * @type {string}
     * @memberof EventSchemaListPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof EventSchemaListPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * Response for event schema versions
 * @export
 * @interface EventSchemaVersionsResponse
 */
export interface EventSchemaVersionsResponse {
    /**
     * 
     * @type {Array<EventSchema>}
     * @memberof EventSchemaVersionsResponse
     */
    'data': Array<EventSchema>;
}
/**
 * event_schema details that are in association with feature
 * @export
 * @interface EventSchemasForFeature
 */
export interface EventSchemasForFeature {
    /**
     * 
     * @type {string}
     * @memberof EventSchemasForFeature
     */
    'schemaName': string;
    /**
     * 
     * @type {string}
     * @memberof EventSchemasForFeature
     */
    'attributeName': string;
}
/**
 * Source of ingestion of event
 * @export
 * @interface EventSource
 */
export interface EventSource {
    /**
     * Unique identifier representing the source
     * @type {string}
     * @memberof EventSource
     */
    'id': string;
    /**
     * Type of source
     * @type {string}
     * @memberof EventSource
     */
    'type': string;
}
/**
 * Raw usage event ingested by the business team and the status of the event ingestion.
 * @export
 * @interface EventWithStatus
 */
export interface EventWithStatus {
    /**
     * 
     * @type {Event}
     * @memberof EventWithStatus
     */
    'eventPayload': Event;
    /**
     * 
     * @type {IngestionStatus}
     * @memberof EventWithStatus
     */
    'ingestionStatus': IngestionStatus;
    /**
     * The associated account belongs to this customer
     * @type {string}
     * @memberof EventWithStatus
     */
    'customerId'?: string;
    /**
     * 
     * @type {EventSource}
     * @memberof EventWithStatus
     */
    'source'?: EventSource;
    /**
     * Created time stamp of the event. This timestamp must be in ISO 8601 format.
     * @type {string}
     * @memberof EventWithStatus
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface EventWithStatusAndEventPipelineInfo
 */
export interface EventWithStatusAndEventPipelineInfo {
    /**
     * 
     * @type {Event}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'eventPayload': Event;
    /**
     * 
     * @type {IngestionStatus}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'ingestionStatus': IngestionStatus;
    /**
     * The associated account belongs to this customer
     * @type {string}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'customerId'?: string;
    /**
     * 
     * @type {EventSource}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'source'?: EventSource;
    /**
     * Created time stamp of the event. This timestamp must be in ISO 8601 format.
     * @type {string}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'createdAt': string;
    /**
     * 
     * @type {EventPipelineInfo}
     * @memberof EventWithStatusAndEventPipelineInfo
     */
    'EventPipelineInfo'?: EventPipelineInfo;
}
/**
 * 
 * @export
 * @interface EventWithStatusAndEventPipelineInfoAllOf
 */
export interface EventWithStatusAndEventPipelineInfoAllOf {
    /**
     * 
     * @type {EventPipelineInfo}
     * @memberof EventWithStatusAndEventPipelineInfoAllOf
     */
    'EventPipelineInfo'?: EventPipelineInfo;
}
/**
 * Represents a Feature
 * @export
 * @interface Feature
 */
export interface Feature {
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'name': string;
    /**
     * Association of a feature with event_schemas
     * @type {Array<EventSchemasForFeature>}
     * @memberof Feature
     */
    'schemaAssociations': Array<EventSchemasForFeature>;
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'updatedAt'?: string;
}
/**
 * Feature configuration object
 * @export
 * @interface FeatureConfig
 */
export interface FeatureConfig {
    /**
     * 
     * @type {string}
     * @memberof FeatureConfig
     */
    'effectiveFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeatureConfig
     */
    'effectiveUntil': string;
    /**
     * 
     * @type {number}
     * @memberof FeatureConfig
     */
    'featureCreditLimit': number;
}
/**
 * details of feature associated with event schema with attribute name
 * @export
 * @interface FeatureDetails
 */
export interface FeatureDetails {
    /**
     * 
     * @type {string}
     * @memberof FeatureDetails
     */
    'featureId': string;
    /**
     * 
     * @type {string}
     * @memberof FeatureDetails
     */
    'attributeName': string;
}
/**
 * Represents a Feature for List Response
 * @export
 * @interface FeatureListResponse
 */
export interface FeatureListResponse {
    /**
     * 
     * @type {string}
     * @memberof FeatureListResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FeatureListResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof FeatureListResponse
     */
    'schemaCount': number;
    /**
     * 
     * @type {string}
     * @memberof FeatureListResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof FeatureListResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface FeaturePaginatedListData
 */
export interface FeaturePaginatedListData {
    /**
     * 
     * @type {Array<FeatureListResponse>}
     * @memberof FeaturePaginatedListData
     */
    'data'?: Array<FeatureListResponse>;
    /**
     * 
     * @type {string}
     * @memberof FeaturePaginatedListData
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof FeaturePaginatedListData
     */
    'context'?: PaginationOptions;
}
/**
 * 
 * @export
 * @interface Field
 */
export interface Field {
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'type': FieldTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'enrichmentType': FieldEnrichmentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'value': string;
    /**
     * 
     * @type {number}
     * @memberof Field
     */
    'order': number;
}

export const FieldTypeEnum = {
    Attribute: 'ATTRIBUTE',
    Dimension: 'DIMENSION'
} as const;

export type FieldTypeEnum = typeof FieldTypeEnum[keyof typeof FieldTypeEnum];
export const FieldEnrichmentTypeEnum = {
    Value: 'VALUE',
    JsonLogic: 'JSON_LOGIC',
    JsonLogicFromDependency: 'JSON_LOGIC_FROM_DEPENDENCY'
} as const;

export type FieldEnrichmentTypeEnum = typeof FieldEnrichmentTypeEnum[keyof typeof FieldEnrichmentTypeEnum];

/**
 * 
 * @export
 * @interface FixedFeeRate
 */
export interface FixedFeeRate {
    /**
     * 
     * @type {string}
     * @memberof FixedFeeRate
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof FixedFeeRate
     */
    'rate': number;
}
/**
 * 
 * @export
 * @interface FixedFeeRateCard
 */
export interface FixedFeeRateCard {
    /**
     * Unique Identifier of the attached AddOn
     * @type {string}
     * @memberof FixedFeeRateCard
     */
    'id': string;
    /**
     * Name of the attached AddOn
     * @type {string}
     * @memberof FixedFeeRateCard
     */
    'displayName'?: string;
    /**
     * A tag string to group fixedFeeRateCards
     * @type {string}
     * @memberof FixedFeeRateCard
     */
    'tag'?: string;
    /**
     * 
     * @type {InvoiceTiming}
     * @memberof FixedFeeRateCard
     */
    'invoiceTiming'?: InvoiceTiming;
    /**
     * 
     * @type {FixedFeeType}
     * @memberof FixedFeeRateCard
     */
    'type'?: FixedFeeType;
    /**
     * 
     * @type {Array<CurrencyRateValue>}
     * @memberof FixedFeeRateCard
     */
    'rateValues': Array<CurrencyRateValue>;
    /**
     * 
     * @type {boolean}
     * @memberof FixedFeeRateCard
     */
    'enableProration': boolean;
    /**
     * 
     * @type {FixedFeeRateCardConfig}
     * @memberof FixedFeeRateCard
     */
    'config'?: FixedFeeRateCardConfig;
}


/**
 * 
 * @export
 * @interface FixedFeeRateCardConfig
 */
export interface FixedFeeRateCardConfig {
    /**
     * Represents the number of pricing cycles after which the fixed fee will be charged
     * @type {number}
     * @memberof FixedFeeRateCardConfig
     */
    'recurrenceInterval'?: number;
}
/**
 * 
 * @export
 * @interface FixedFeeRevenueSummary
 */
export interface FixedFeeRevenueSummary {
    /**
     * 
     * @type {number}
     * @memberof FixedFeeRevenueSummary
     */
    'revenue': number;
}
/**
 * Fixed fee applies either for a one-time occurrence or for each cycle.
 * @export
 * @enum {string}
 */

export const FixedFeeType = {
    OneTime: 'ONE_TIME',
    Recurring: 'RECURRING'
} as const;

export type FixedFeeType = typeof FixedFeeType[keyof typeof FixedFeeType];


/**
 * Get single event response
 * @export
 * @interface GetEventResponse
 */
export interface GetEventResponse {
    /**
     * 
     * @type {Array<EventWithStatusAndEventPipelineInfo>}
     * @memberof GetEventResponse
     */
    'events': Array<EventWithStatusAndEventPipelineInfo>;
}
/**
 * Get batch events response
 * @export
 * @interface GetEventsResponse
 */
export interface GetEventsResponse {
    /**
     * 
     * @type {Array<EventWithStatus>}
     * @memberof GetEventsResponse
     */
    'events': Array<EventWithStatus>;
    /**
     * 
     * @type {string}
     * @memberof GetEventsResponse
     */
    'nextToken'?: string;
}
/**
 * Get feature credits response
 * @export
 * @interface GetFeatureCreditsResponse
 */
export interface GetFeatureCreditsResponse {
    /**
     * 
     * @type {string}
     * @memberof GetFeatureCreditsResponse
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof GetFeatureCreditsResponse
     */
    'featureId': string;
    /**
     * 
     * @type {number}
     * @memberof GetFeatureCreditsResponse
     */
    'granted': number;
    /**
     * 
     * @type {number}
     * @memberof GetFeatureCreditsResponse
     */
    'balance': number;
}
/**
 * Get license updates response
 * @export
 * @interface GetLicenseUpdatesResponse
 */
export interface GetLicenseUpdatesResponse {
    /**
     * 
     * @type {Array<LicenseUpdateResponse>}
     * @memberof GetLicenseUpdatesResponse
     */
    'data': Array<LicenseUpdateResponse>;
    /**
     * 
     * @type {string}
     * @memberof GetLicenseUpdatesResponse
     */
    'nextToken'?: string;
}
/**
 * Request to get metrics from togai
 * @export
 * @interface GetMetricsRequest
 */
export interface GetMetricsRequest {
    /**
     * 
     * @type {string}
     * @memberof GetMetricsRequest
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof GetMetricsRequest
     */
    'endTime': string;
    /**
     * 
     * @type {Array<MetricQuery>}
     * @memberof GetMetricsRequest
     */
    'metricQueries': Array<MetricQuery>;
}
/**
 * Response to GetMetrics Request
 * @export
 * @interface GetMetricsResponse
 */
export interface GetMetricsResponse {
    /**
     * 
     * @type {Array<MetricQueryResponse>}
     * @memberof GetMetricsResponse
     */
    'results': Array<MetricQueryResponse>;
}
/**
 * 
 * @export
 * @interface GetMigrationResponse
 */
export interface GetMigrationResponse {
    /**
     * 
     * @type {string}
     * @memberof GetMigrationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetMigrationResponse
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof GetMigrationResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetMigrationResponse
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof GetMigrationResponse
     */
    'sourceId': string;
    /**
     * 
     * @type {number}
     * @memberof GetMigrationResponse
     */
    'sourceVersion'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetMigrationResponse
     */
    'targetId': string;
    /**
     * 
     * @type {number}
     * @memberof GetMigrationResponse
     */
    'targetVersion'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetMigrationResponse
     */
    'totalMigrationEntries': number;
    /**
     * 
     * @type {number}
     * @memberof GetMigrationResponse
     */
    'pendingMigrationEntries': number;
    /**
     * 
     * @type {number}
     * @memberof GetMigrationResponse
     */
    'failedMigrationEntries': number;
    /**
     * 
     * @type {number}
     * @memberof GetMigrationResponse
     */
    'completedMigrationEntries': number;
}
/**
 * 
 * @export
 * @interface GetPurchaseResponse
 */
export interface GetPurchaseResponse {
    /**
     * 
     * @type {string}
     * @memberof GetPurchaseResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetPurchaseResponse
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof GetPurchaseResponse
     */
    'pricePlanId': string;
    /**
     * 
     * @type {number}
     * @memberof GetPurchaseResponse
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof GetPurchaseResponse
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetPurchaseResponse
     */
    'pricePlanVersion': number;
    /**
     * 
     * @type {PurchasePlanOverride}
     * @memberof GetPurchaseResponse
     */
    'purchasePlanOverrides'?: PurchasePlanOverride;
    /**
     * 
     * @type {string}
     * @memberof GetPurchaseResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetPurchaseResponse
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetPurchaseResponse
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetPurchaseResponse
     */
    'invoiceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPurchaseResponse
     */
    'invoiceCurrency'?: string;
    /**
     * 
     * @type {PurchaseStatus}
     * @memberof GetPurchaseResponse
     */
    'status': PurchaseStatus;
    /**
     * 
     * @type {PurchasePlanOverride}
     * @memberof GetPurchaseResponse
     */
    'purchasePlan': PurchasePlanOverride;
    /**
     * 
     * @type {Array<PurchaseFeatureDetails>}
     * @memberof GetPurchaseResponse
     */
    'features': Array<PurchaseFeatureDetails>;
}


/**
 * 
 * @export
 * @interface GetPurchaseResponseAllOf
 */
export interface GetPurchaseResponseAllOf {
    /**
     * 
     * @type {number}
     * @memberof GetPurchaseResponseAllOf
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetPurchaseResponseAllOf
     */
    'invoiceCurrency'?: string;
    /**
     * 
     * @type {PurchasePlanOverride}
     * @memberof GetPurchaseResponseAllOf
     */
    'purchasePlan': PurchasePlanOverride;
    /**
     * 
     * @type {Array<PurchaseFeatureDetails>}
     * @memberof GetPurchaseResponseAllOf
     */
    'features': Array<PurchaseFeatureDetails>;
}
/**
 * Payload for ingesting batch events
 * @export
 * @interface IngestBatchEventRequest
 */
export interface IngestBatchEventRequest {
    /**
     * 
     * @type {Array<Event>}
     * @memberof IngestBatchEventRequest
     */
    'events': Array<Event>;
}
/**
 * Payload for ingesting events
 * @export
 * @interface IngestEventRequest
 */
export interface IngestEventRequest {
    /**
     * 
     * @type {Event}
     * @memberof IngestEventRequest
     */
    'event'?: Event;
}
/**
 * 
 * @export
 * @interface IngestEventResponse
 */
export interface IngestEventResponse {
    /**
     * 
     * @type {boolean}
     * @memberof IngestEventResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof IngestEventResponse
     */
    'statusCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof IngestEventResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof IngestEventResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof IngestEventResponse
     */
    'code'?: string;
    /**
     * 
     * @type {object}
     * @memberof IngestEventResponse
     */
    'details'?: object;
}
/**
 * Status about the event ingestion.
 * @export
 * @interface IngestionStatus
 */
export interface IngestionStatus {
    /**
     * Ingestion status
     * @type {string}
     * @memberof IngestionStatus
     */
    'status': IngestionStatusStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof IngestionStatus
     */
    'statusDescription'?: string;
}

export const IngestionStatusStatusEnum = {
    IngestionInProgress: 'INGESTION_IN_PROGRESS',
    IngestionFailed: 'INGESTION_FAILED',
    IngestionFailedSchemaNotDefined: 'INGESTION_FAILED_SCHEMA_NOT_DEFINED',
    IngestionFailedEnrichmentFailed: 'INGESTION_FAILED_ENRICHMENT_FAILED',
    IngestionFailedUnitsInvalid: 'INGESTION_FAILED_UNITS_INVALID',
    IngestionCompletedNoMatchingMeters: 'INGESTION_COMPLETED_NO_MATCHING_METERS',
    IngestionCompletedEventMetered: 'INGESTION_COMPLETED_EVENT_METERED',
    IngestionCompletedEventNotMetered: 'INGESTION_COMPLETED_EVENT_NOT_METERED',
    IngestionFailedPastGracePeriod: 'INGESTION_FAILED_PAST_GRACE_PERIOD',
    Unknown: 'UNKNOWN'
} as const;

export type IngestionStatusStatusEnum = typeof IngestionStatusStatusEnum[keyof typeof IngestionStatusStatusEnum];

/**
 * Structure of invoice
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * Identifier of customer
     * @type {string}
     * @memberof Invoice
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'customerId': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'pricePlanId'?: string;
    /**
     * 
     * @type {Array<InvoiceLineItem>}
     * @memberof Invoice
     */
    'usageInfo'?: Array<InvoiceLineItem>;
    /**
     * 
     * @type {InvoiceLineItem}
     * @memberof Invoice
     */
    'revenueInfo'?: InvoiceLineItem;
    /**
     * 
     * @type {InvoiceDetails}
     * @memberof Invoice
     */
    'invoiceDetails'?: InvoiceDetails;
    /**
     * Status of the invoice
     * @type {string}
     * @memberof Invoice
     */
    'status': InvoiceStatusEnum;
    /**
     * Payment status of the invoice
     * @type {string}
     * @memberof Invoice
     */
    'paymentStatus': InvoicePaymentStatusEnum;
    /**
     * Start date of the invoice
     * @type {string}
     * @memberof Invoice
     */
    'startDate': string;
    /**
     * End date of the invoice
     * @type {string}
     * @memberof Invoice
     */
    'endDate': string;
    /**
     * Invoice date of the invoice
     * @type {string}
     * @memberof Invoice
     */
    'invoiceDate': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'generatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'updatedAt': string;
}

export const InvoiceStatusEnum = {
    Ongoing: 'ONGOING',
    GracePeriod: 'GRACE_PERIOD',
    Generated: 'GENERATED',
    Published: 'PUBLISHED'
} as const;

export type InvoiceStatusEnum = typeof InvoiceStatusEnum[keyof typeof InvoiceStatusEnum];
export const InvoicePaymentStatusEnum = {
    Due: 'DUE',
    Paid: 'PAID'
} as const;

export type InvoicePaymentStatusEnum = typeof InvoicePaymentStatusEnum[keyof typeof InvoicePaymentStatusEnum];

/**
 * 
 * @export
 * @interface InvoiceDetails
 */
export interface InvoiceDetails {
    /**
     * 
     * @type {InvoiceDetailsCustomer}
     * @memberof InvoiceDetails
     */
    'customer': InvoiceDetailsCustomer;
    /**
     * 
     * @type {InvoiceDetailsAccount}
     * @memberof InvoiceDetails
     */
    'account': InvoiceDetailsAccount;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetails
     */
    'pricePlanName'?: string;
}
/**
 * 
 * @export
 * @interface InvoiceDetailsAccount
 */
export interface InvoiceDetailsAccount {
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsAccount
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsAccount
     */
    'invoiceCurrency': string;
}
/**
 * 
 * @export
 * @interface InvoiceDetailsCustomer
 */
export interface InvoiceDetailsCustomer {
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsCustomer
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsCustomer
     */
    'primaryEmail': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDetailsCustomer
     */
    'billingAddress': string;
}
/**
 * 
 * @export
 * @interface InvoiceLineItem
 */
export interface InvoiceLineItem {
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineItem
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineItem
     */
    'description': string;
    /**
     * Type of the line item - TOTAL_USAGE: List of all the usage meter usages - USAGE_METER_USAGE: A single usage meter usage - NET_REVENUE: Net revenue of the invoice ( Gross revenue - Discounts ) - GROSS_REVENUE: Gross revenue of the invoice  - USAGE_RATE_CARD_REVENUE: Revenue generated from usage rate card - USAGE_RATE_CARD_SLAB_REVENUE: Revenue generated from usage rate card slab 
     * @type {string}
     * @memberof InvoiceLineItem
     */
    'type': string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLineItem
     */
    'valuePerQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLineItem
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceLineItem
     */
    'units': string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLineItem
     */
    'value': number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof InvoiceLineItem
     */
    'metadata'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<InvoiceLineItem>}
     * @memberof InvoiceLineItem
     */
    'lineItems': Array<InvoiceLineItem>;
}
/**
 * Payload to update payment information of invoice
 * @export
 * @interface InvoicePaymentsRequest
 */
export interface InvoicePaymentsRequest {
    /**
     * Payment status of the invoice
     * @type {string}
     * @memberof InvoicePaymentsRequest
     */
    'status': InvoicePaymentsRequestStatusEnum;
}

export const InvoicePaymentsRequestStatusEnum = {
    Paid: 'PAID',
    Void: 'VOID',
    UnCollectible: 'UN_COLLECTIBLE'
} as const;

export type InvoicePaymentsRequestStatusEnum = typeof InvoicePaymentsRequestStatusEnum[keyof typeof InvoicePaymentsRequestStatusEnum];

/**
 * If IN_ADVANCE, the fixed fee will be invoiced in the previous billing cycle. If IN_ARREARS, the fixed fee will be invoiced in the current billing cycle. 
 * @export
 * @enum {string}
 */

export const InvoiceTiming = {
    IN_ADVANCE: 'IN_ADVANCE',
    IN_ARREARS: 'IN_ARREARS'
} as const;

export type InvoiceTiming = typeof InvoiceTiming[keyof typeof InvoiceTiming];


/**
 * Configuration for getting the license entries
 * @export
 * @interface LicenseEntriesConfig
 */
export interface LicenseEntriesConfig {
    /**
     * Mode to get the license entries for the license rate cards - CUSTOM: Use the license entries provided in the request - LOOKUP_RANGE: Use the license entries of a given account for the specified range - LOOKUP_CYCLE: Use the license entries of a given account for the specified cycle 
     * @type {string}
     * @memberof LicenseEntriesConfig
     */
    'mode': LicenseEntriesConfigModeEnum;
    /**
     * List of license entries, this will be considered if mode is CUSTOM
     * @type {Array<LicenseEntry>}
     * @memberof LicenseEntriesConfig
     */
    'custom'?: Array<LicenseEntry>;
    /**
     * 
     * @type {LicenseEntriesConfigLookupRange}
     * @memberof LicenseEntriesConfig
     */
    'lookupRange'?: LicenseEntriesConfigLookupRange;
    /**
     * 
     * @type {LicenseEntriesConfigLookupCycle}
     * @memberof LicenseEntriesConfig
     */
    'lookupCycle'?: LicenseEntriesConfigLookupCycle;
}

export const LicenseEntriesConfigModeEnum = {
    Custom: 'CUSTOM',
    LookupRange: 'LOOKUP_RANGE',
    LookupCycle: 'LOOKUP_CYCLE'
} as const;

export type LicenseEntriesConfigModeEnum = typeof LicenseEntriesConfigModeEnum[keyof typeof LicenseEntriesConfigModeEnum];

/**
 * Cycle of license entries to be looked up, this will be considered if mode is LOOKUP_CYCLE
 * @export
 * @interface LicenseEntriesConfigLookupCycle
 */
export interface LicenseEntriesConfigLookupCycle {
    /**
     * Effective date of the cycle, will be used to get the license entries of the cycle
     * @type {string}
     * @memberof LicenseEntriesConfigLookupCycle
     */
    'cycleEffectiveOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof LicenseEntriesConfigLookupCycle
     */
    'accountId': string;
}
/**
 * Range of license entries to be looked up, this will be considered if mode is LOOKUP_RANGE
 * @export
 * @interface LicenseEntriesConfigLookupRange
 */
export interface LicenseEntriesConfigLookupRange {
    /**
     * 
     * @type {string}
     * @memberof LicenseEntriesConfigLookupRange
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof LicenseEntriesConfigLookupRange
     */
    'end': string;
    /**
     * 
     * @type {string}
     * @memberof LicenseEntriesConfigLookupRange
     */
    'accountId': string;
}
/**
 * 
 * @export
 * @interface LicenseEntry
 */
export interface LicenseEntry {
    /**
     * 
     * @type {string}
     * @memberof LicenseEntry
     */
    'licenseId': string;
    /**
     * 
     * @type {number}
     * @memberof LicenseEntry
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof LicenseEntry
     */
    'effectiveFrom': string;
}
/**
 * 
 * @export
 * @interface LicenseRate
 */
export interface LicenseRate {
    /**
     * 
     * @type {string}
     * @memberof LicenseRate
     */
    'id': string;
    /**
     * List of slab rates
     * @type {Array<SlabRate>}
     * @memberof LicenseRate
     */
    'slabRates': Array<SlabRate>;
}
/**
 * 
 * @export
 * @interface LicenseRateCard
 */
export interface LicenseRateCard {
    /**
     * Unique Identifier of the attached AddOn
     * @type {string}
     * @memberof LicenseRateCard
     */
    'id': string;
    /**
     * Name of the attached AddOn
     * @type {string}
     * @memberof LicenseRateCard
     */
    'displayName'?: string;
    /**
     * A tag string to group licenseRateCards
     * @type {string}
     * @memberof LicenseRateCard
     */
    'tag'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LicenseRateCard
     */
    'enableProration': boolean;
    /**
     * 
     * @type {LicenseRateCardConfig}
     * @memberof LicenseRateCard
     */
    'config'?: LicenseRateCardConfig;
    /**
     * 
     * @type {RatePlan}
     * @memberof LicenseRateCard
     */
    'ratePlan': RatePlan;
    /**
     * 
     * @type {Array<RateValue>}
     * @memberof LicenseRateCard
     */
    'rateValues': Array<RateValue>;
}
/**
 * 
 * @export
 * @interface LicenseRateCardConfig
 */
export interface LicenseRateCardConfig {
    /**
     * Max allowed quantity for a particular license in a price plan
     * @type {number}
     * @memberof LicenseRateCardConfig
     */
    'maxQuantity'?: number;
}
/**
 * 
 * @export
 * @interface LicenseRevenueSummary
 */
export interface LicenseRevenueSummary {
    /**
     * 
     * @type {number}
     * @memberof LicenseRevenueSummary
     */
    'revenue': number;
}
/**
 * License update
 * @export
 * @interface LicenseUpdate
 */
export interface LicenseUpdate {
    /**
     * 
     * @type {string}
     * @memberof LicenseUpdate
     */
    'licenseId': string;
    /**
     * 
     * @type {string}
     * @memberof LicenseUpdate
     */
    'accountId': string;
    /**
     * Absolute quantity of the license
     * @type {number}
     * @memberof LicenseUpdate
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof LicenseUpdate
     */
    'effectiveFrom': string;
}
/**
 * License update request
 * @export
 * @interface LicenseUpdateRequest
 */
export interface LicenseUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof LicenseUpdateRequest
     */
    'licenseId': string;
    /**
     * 
     * @type {string}
     * @memberof LicenseUpdateRequest
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof LicenseUpdateRequest
     */
    'updateType': LicenseUpdateRequestUpdateTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof LicenseUpdateRequest
     */
    'quantity': number;
}

export const LicenseUpdateRequestUpdateTypeEnum = {
    Relative: 'RELATIVE',
    Absolute: 'ABSOLUTE'
} as const;

export type LicenseUpdateRequestUpdateTypeEnum = typeof LicenseUpdateRequestUpdateTypeEnum[keyof typeof LicenseUpdateRequestUpdateTypeEnum];

/**
 * 
 * @export
 * @interface LicenseUpdateResponse
 */
export interface LicenseUpdateResponse {
    /**
     * 
     * @type {string}
     * @memberof LicenseUpdateResponse
     */
    'licenseId': string;
    /**
     * 
     * @type {string}
     * @memberof LicenseUpdateResponse
     */
    'accountId': string;
    /**
     * Absolute quantity of the license
     * @type {number}
     * @memberof LicenseUpdateResponse
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof LicenseUpdateResponse
     */
    'effectiveFrom': string;
    /**
     * 
     * @type {string}
     * @memberof LicenseUpdateResponse
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface LicenseUpdateResponseAllOf
 */
export interface LicenseUpdateResponseAllOf {
    /**
     * 
     * @type {string}
     * @memberof LicenseUpdateResponseAllOf
     */
    'createdAt': string;
}
/**
 * List credits response
 * @export
 * @interface ListCreditsResponse
 */
export interface ListCreditsResponse {
    /**
     * 
     * @type {Array<Credit>}
     * @memberof ListCreditsResponse
     */
    'data': Array<Credit>;
    /**
     * 
     * @type {string}
     * @memberof ListCreditsResponse
     */
    'nextToken'?: string;
}
/**
 * List invoices response
 * @export
 * @interface ListInvoicesResponse
 */
export interface ListInvoicesResponse {
    /**
     * 
     * @type {Array<Invoice>}
     * @memberof ListInvoicesResponse
     */
    'data': Array<Invoice>;
    /**
     * 
     * @type {string}
     * @memberof ListInvoicesResponse
     */
    'nextToken'?: string;
}
/**
 * Payload to update custom line items
 * @export
 * @interface ManageMiscellaneousChargesRequest
 */
export interface ManageMiscellaneousChargesRequest {
    /**
     * 
     * @type {Array<MiscellaneousCharge>}
     * @memberof ManageMiscellaneousChargesRequest
     */
    'items': Array<MiscellaneousCharge>;
}
/**
 * 
 * @export
 * @interface MetricDataPoints
 */
export interface MetricDataPoints {
    /**
     * 
     * @type {MetricDataPointsGroupedBy}
     * @memberof MetricDataPoints
     */
    'groupedBy'?: MetricDataPointsGroupedBy;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetricDataPoints
     */
    'timestamps': Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof MetricDataPoints
     */
    'metricValues': Array<number>;
}
/**
 * 
 * @export
 * @interface MetricDataPointsGroupedBy
 */
export interface MetricDataPointsGroupedBy {
    /**
     * 
     * @type {string}
     * @memberof MetricDataPointsGroupedBy
     */
    'fieldName': string;
    /**
     * 
     * @type {string}
     * @memberof MetricDataPointsGroupedBy
     */
    'fieldValue': string;
}
/**
 * Define the metric you would like to get - allowed options are EVENTS - Aggregation of raw events, USAGE - Aggregated usage value from Usage meters, REVENUE - Aggregated revenue value from Pricing Plans USAGE_FOR_CYCLE - Usage in pricing cycle REVENUE_FOR_CYCLE - Revenue in pricing cycle 
 * @export
 * @enum {string}
 */

export const MetricName = {
    Events: 'EVENTS',
    Usage: 'USAGE',
    Revenue: 'REVENUE',
    UsageForCycle: 'USAGE_FOR_CYCLE',
    RevenueForCycle: 'REVENUE_FOR_CYCLE'
} as const;

export type MetricName = typeof MetricName[keyof typeof MetricName];


/**
 * Object representing a single metrics query
 * @export
 * @interface MetricQuery
 */
export interface MetricQuery {
    /**
     * Mandatory  for all request.  User defined ID for identifying the request for your internal reference 
     * @type {string}
     * @memberof MetricQuery
     */
    'id': string;
    /**
     * 
     * @type {MetricName}
     * @memberof MetricQuery
     */
    'name': MetricName;
    /**
     * Set the aggregation period. Allowed periods are DAY, WEEK, MONTH
     * @type {string}
     * @memberof MetricQuery
     */
    'aggregationPeriod': MetricQueryAggregationPeriodEnum;
    /**
     * Group your metric with a groupBy field.  Allowed fields are  ACCOUNT_ID EVENT_STATUS  SCHEMA_NAME  USAGE_METER_ID  Please refer the table above for the list of combinations allowed in the groupBy 
     * @type {string}
     * @memberof MetricQuery
     */
    'groupBy'?: string;
    /**
     * Configurations. | Metric Name       | Config Key | Allowed Values  | Default value |              Description          | |-------------------|------------|-----------------|---------------|-----------------------------------| | REVENUE           | CURRENCY   | BASE or INVOICE | BASE          | currency to return the revenue in | | REVENUE_FOR_CYCLE | CURRENCY   | BASE or INVOICE | BASE          | currency to return the revenue in | 
     * @type {{ [key: string]: string; }}
     * @memberof MetricQuery
     */
    'configs'?: { [key: string]: string; };
    /**
     * Filter on specific fields.  Refer possible fieldNames and fieldValues from the table above. 
     * @type {Array<MetricQueryFilterEntry>}
     * @memberof MetricQuery
     */
    'filters'?: Array<MetricQueryFilterEntry>;
}

export const MetricQueryAggregationPeriodEnum = {
    Day: 'DAY',
    Week: 'WEEK',
    Month: 'MONTH'
} as const;

export type MetricQueryAggregationPeriodEnum = typeof MetricQueryAggregationPeriodEnum[keyof typeof MetricQueryAggregationPeriodEnum];

/**
 *  | Metric Name       | FilterEntry Name |    Allowed groupBy fields                 |      Default Values      |                 Allowed Values                  | |-------------------|------------------|-------------------------------------------|--------------------------|-------------------------------------------------| | EVENTS            | ACCOUNT_ID       | ACCOUNT_ID, EVENT_STATUS, SCHEMA_NAME,    | None                     | *\\<one or more valid account IDs>               | | EVENTS            | CUSTOMER_ID      | ACCOUNT_ID, EVENT_STATUS, SCHEMA_NAME,    | None                     | *\\<one or more valid customer IDs>              | | EVENTS            | SCHEMA_NAME      | ACCOUNT_ID, EVENT_STATUS, SCHEMA_NAME,    | None                     | *\\<at most one valid schema names>              | | EVENTS            | EVENT_STATUS     | ACCOUNT_ID, EVENT_STATUS, SCHEMA_NAME,    | [PROCESSED, UNPROCESSED] | oneOrMoreOf PROCESSED, UNPROCESSED, IN_PROGRESS | | USAGE             | ACCOUNT_ID       | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | None                     | *\\<one or more valid account IDs>               | | USAGE             | CUSTOMER_ID      | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | None                     | *\\<one or more valid customer IDs>              | | USAGE             | USAGE_METER_ID   | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | None                     | *\\<one or more valid usage meter name>          | | REVENUE           | ACCOUNT_ID       | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | None                     | *\\<one or more valid account IDs>               | | REVENUE           | CUSTOMER_ID      | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | None                     | *\\<one or more valid customer IDs>              | | REVENUE           | USAGE_METER_ID   | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | None                     | *\\<one or more valid usage meter name>          | | EVENTS            | ORGANIZATION_ID  | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | <From auth token>        |                                                 | | USAGE             | ORGANIZATION_ID  | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | <From auth token>        |                                                 | | REVENUE           | ORGANIZATION_ID  | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | <From auth token>        |                                                 | | USAGE_FOR_CYCLE   | ACCOUNT_ID       | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | None                     | *\\<one or more valid account IDs>               | | USAGE_FOR_CYCLE   | CUSTOMER_ID      | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | None                     | *\\<one or more valid customer IDs>              | | USAGE_FOR_CYCLE   | USAGE_METER_ID   | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | None                     | *\\<one or more valid usage meter name>          | | REVENUE_FOR_CYCLE | ACCOUNT_ID       | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | None                     | *\\<one or more valid account IDs>               | | REVENUE_FOR_CYCLE | CUSTOMER_ID      | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | None                     | *\\<one or more valid customer IDs>              | | REVENUE_FOR_CYCLE | USAGE_METER_ID   | ACCOUNT_ID, USAGE_METER_ID, CUSTOMER_ID   | None                     | *\\<one or more valid usage meter name>          | 
 * @export
 * @interface MetricQueryFilterEntry
 */
export interface MetricQueryFilterEntry {
    /**
     * 
     * @type {string}
     * @memberof MetricQueryFilterEntry
     */
    'fieldName': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetricQueryFilterEntry
     */
    'fieldValues': Array<string>;
}
/**
 * Response to GetMetrics Request
 * @export
 * @interface MetricQueryResponse
 */
export interface MetricQueryResponse {
    /**
     * 
     * @type {string}
     * @memberof MetricQueryResponse
     */
    'id': string;
    /**
     * 
     * @type {MetricName}
     * @memberof MetricQueryResponse
     */
    'name': MetricName;
    /**
     * 
     * @type {Array<MetricDataPoints>}
     * @memberof MetricQueryResponse
     */
    'data': Array<MetricDataPoints>;
}


/**
 * 
 * @export
 * @interface MigrationsPaginatedResponse
 */
export interface MigrationsPaginatedResponse {
    /**
     * 
     * @type {Array<MigrationsWithoutStatusInfo>}
     * @memberof MigrationsPaginatedResponse
     */
    'data'?: Array<MigrationsWithoutStatusInfo>;
    /**
     * 
     * @type {string}
     * @memberof MigrationsPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof MigrationsPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * 
 * @export
 * @interface MigrationsWithoutStatusInfo
 */
export interface MigrationsWithoutStatusInfo {
    /**
     * 
     * @type {string}
     * @memberof MigrationsWithoutStatusInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MigrationsWithoutStatusInfo
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof MigrationsWithoutStatusInfo
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof MigrationsWithoutStatusInfo
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface MinimumCommitment
 */
export interface MinimumCommitment {
    /**
     * 
     * @type {string}
     * @memberof MinimumCommitment
     */
    'displayName': string;
    /**
     * 
     * @type {Array<CurrencyRateValue>}
     * @memberof MinimumCommitment
     */
    'rateValues': Array<CurrencyRateValue>;
}
/**
 * Miscellaneous charges are the charges that can be added to the invoice
 * @export
 * @interface MiscellaneousCharge
 */
export interface MiscellaneousCharge {
    /**
     * Name of the miscellaneous charge
     * @type {string}
     * @memberof MiscellaneousCharge
     */
    'name': string;
    /**
     * Value of the charge
     * @type {string}
     * @memberof MiscellaneousCharge
     */
    'value': string;
}
/**
 * Miscellaneous charges response
 * @export
 * @interface MiscellaneousChargesResponse
 */
export interface MiscellaneousChargesResponse {
    /**
     * 
     * @type {Array<MiscellaneousCharge>}
     * @memberof MiscellaneousChargesResponse
     */
    'data': Array<MiscellaneousCharge>;
}
/**
 * 
 * @export
 * @interface PaginationOptions
 */
export interface PaginationOptions {
    /**
     * 
     * @type {number}
     * @memberof PaginationOptions
     */
    'pageSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginationOptions
     */
    'sortOrder'?: PaginationOptionsSortOrderEnum;
}

export const PaginationOptionsSortOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type PaginationOptionsSortOrderEnum = typeof PaginationOptionsSortOrderEnum[keyof typeof PaginationOptionsSortOrderEnum];

/**
 * Represents effectiveness period and config of a price plan. i.e, price plan bound by time.
 * @export
 * @interface PlanOverride
 */
export interface PlanOverride {
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'pricePlanId': string;
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'pricePlanName': string;
    /**
     * 
     * @type {PricePlanDetailsOverride}
     * @memberof PlanOverride
     */
    'pricePlanDetailsOverride'?: PricePlanDetailsOverride;
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof PlanOverride
     */
    'endDate': string;
}
/**
 * Price plan entity
 * @export
 * @interface PricePlan
 */
export interface PricePlan {
    /**
     * Price plan id
     * @type {string}
     * @memberof PricePlan
     */
    'id': string;
    /**
     * Name of the price plan
     * @type {string}
     * @memberof PricePlan
     */
    'name': string;
    /**
     * 
     * @type {PricePlanType}
     * @memberof PricePlan
     */
    'type': PricePlanType;
    /**
     * Description of price plan
     * @type {string}
     * @memberof PricePlan
     */
    'description'?: string;
    /**
     * Status of Price plan
     * @type {string}
     * @memberof PricePlan
     */
    'status': PricePlanStatusEnum;
    /**
     * 
     * @type {Array<PricingSchedule>}
     * @memberof PricePlan
     */
    'pricingSchedule': Array<PricingSchedule>;
}

export const PricePlanStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type PricePlanStatusEnum = typeof PricePlanStatusEnum[keyof typeof PricePlanStatusEnum];

/**
 * 
 * @export
 * @interface PricePlanDetails
 */
export interface PricePlanDetails {
    /**
     * 
     * @type {Array<string>}
     * @memberof PricePlanDetails
     */
    'supportedCurrencies': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PricePlanDetails
     */
    'activeCurrencies': Array<string>;
    /**
     * 
     * @type {PricingCycleConfig}
     * @memberof PricePlanDetails
     */
    'pricingCycleConfig'?: PricingCycleConfig;
    /**
     * 
     * @type {Array<UsageRateCard>}
     * @memberof PricePlanDetails
     */
    'usageRateCards'?: Array<UsageRateCard>;
    /**
     * 
     * @type {Array<FixedFeeRateCard>}
     * @memberof PricePlanDetails
     */
    'fixedFeeRateCards'?: Array<FixedFeeRateCard>;
    /**
     * 
     * @type {Array<LicenseRateCard>}
     * @memberof PricePlanDetails
     */
    'licenseRateCards'?: Array<LicenseRateCard>;
    /**
     * 
     * @type {Array<BillingEntitlementRateCard>}
     * @memberof PricePlanDetails
     */
    'billingEntitlementRateCards'?: Array<BillingEntitlementRateCard>;
    /**
     * 
     * @type {MinimumCommitment}
     * @memberof PricePlanDetails
     */
    'minimumCommitment'?: MinimumCommitment;
    /**
     * 
     * @type {RateDetails}
     * @memberof PricePlanDetails
     */
    'rateDetails'?: RateDetails;
    /**
     * 
     * @type {Array<EntitlementRateCard>}
     * @memberof PricePlanDetails
     */
    'entitlementRateCards'?: Array<EntitlementRateCard>;
    /**
     * 
     * @type {PricePlanType}
     * @memberof PricePlanDetails
     */
    'type'?: PricePlanType;
}


/**
 * Configuration for getting the usage rate card
 * @export
 * @interface PricePlanDetailsConfig
 */
export interface PricePlanDetailsConfig {
    /**
     * Mode to get the usage rate card - CUSTOM: Use the price plan details provided in the request - PRICE_PLAN: Use the usage rate cards of the given price plan - ACCOUNT: Use the usage rate cards of a associated price plan of the given account 
     * @type {string}
     * @memberof PricePlanDetailsConfig
     */
    'mode': PricePlanDetailsConfigModeEnum;
    /**
     * 
     * @type {CreatePricePlanDetails}
     * @memberof PricePlanDetailsConfig
     */
    'pricePlanDetails'?: CreatePricePlanDetails;
    /**
     * Id of the price plan, this will be considered if mode is PRICE_PLAN
     * @type {string}
     * @memberof PricePlanDetailsConfig
     */
    'pricePlanId'?: string;
    /**
     * Id of the account, this will be considered if mode is ACCOUNT
     * @type {string}
     * @memberof PricePlanDetailsConfig
     */
    'accountId'?: string;
    /**
     * Will be used for getting the usage rate card, only used if mode is ACCOUNT or PRICE_PLAN
     * @type {string}
     * @memberof PricePlanDetailsConfig
     */
    'effectiveOn'?: string;
    /**
     * nth cycle, will be used to calculate revenue for the particular cycle, only used if mode is CUSTOM or PRICE_PLAN
     * @type {number}
     * @memberof PricePlanDetailsConfig
     */
    'pricingCycleOrdinal'?: number;
}

export const PricePlanDetailsConfigModeEnum = {
    Custom: 'CUSTOM',
    PricePlan: 'PRICE_PLAN',
    Account: 'ACCOUNT'
} as const;

export type PricePlanDetailsConfigModeEnum = typeof PricePlanDetailsConfigModeEnum[keyof typeof PricePlanDetailsConfigModeEnum];

/**
 * 
 * @export
 * @interface PricePlanDetailsOverride
 */
export interface PricePlanDetailsOverride {
    /**
     * 
     * @type {PricingCycleConfig}
     * @memberof PricePlanDetailsOverride
     */
    'pricingCycleConfig'?: PricingCycleConfig;
    /**
     * 
     * @type {Array<string>}
     * @memberof PricePlanDetailsOverride
     */
    'supportedCurrencies'?: Array<string>;
    /**
     * 
     * @type {Array<UsageRateCard>}
     * @memberof PricePlanDetailsOverride
     */
    'usageRateCards'?: Array<UsageRateCard>;
    /**
     * 
     * @type {Array<BillingEntitlementRateCard>}
     * @memberof PricePlanDetailsOverride
     */
    'billingEntitlementRateCards'?: Array<BillingEntitlementRateCard>;
    /**
     * 
     * @type {Array<FixedFeeRateCard>}
     * @memberof PricePlanDetailsOverride
     */
    'fixedFeeRateCards'?: Array<FixedFeeRateCard>;
    /**
     * 
     * @type {Array<LicenseRateCard>}
     * @memberof PricePlanDetailsOverride
     */
    'licenseRateCards'?: Array<LicenseRateCard>;
    /**
     * 
     * @type {MinimumCommitment}
     * @memberof PricePlanDetailsOverride
     */
    'minimumCommitment'?: MinimumCommitment;
    /**
     * 
     * @type {RateDetails}
     * @memberof PricePlanDetailsOverride
     */
    'rateDetails'?: RateDetails;
    /**
     * 
     * @type {Array<EntitlementRateCard>}
     * @memberof PricePlanDetailsOverride
     */
    'entitlementRateCards'?: Array<EntitlementRateCard>;
}
/**
 * 
 * @export
 * @interface PricePlanDetailsOverrideAllOf
 */
export interface PricePlanDetailsOverrideAllOf {
    /**
     * 
     * @type {Array<FixedFeeRateCard>}
     * @memberof PricePlanDetailsOverrideAllOf
     */
    'fixedFeeRateCards'?: Array<FixedFeeRateCard>;
}
/**
 * Data of price plan list
 * @export
 * @interface PricePlanListData
 */
export interface PricePlanListData {
    /**
     * Identifier of price plan
     * @type {string}
     * @memberof PricePlanListData
     */
    'id': string;
    /**
     * Name of the price plan
     * @type {string}
     * @memberof PricePlanListData
     */
    'name': string;
    /**
     * Version of the price plan
     * @type {number}
     * @memberof PricePlanListData
     */
    'version': number;
    /**
     * Description of price plan
     * @type {string}
     * @memberof PricePlanListData
     */
    'description'?: string;
    /**
     * Status of Price plan
     * @type {string}
     * @memberof PricePlanListData
     */
    'status': PricePlanListDataStatusEnum;
    /**
     * Usage meters id linked to the price plan
     * @type {Array<string>}
     * @memberof PricePlanListData
     */
    'usageMeters': Array<string>;
    /**
     * 
     * @type {PricePlanDetails}
     * @memberof PricePlanListData
     */
    'pricePlanDetails': PricePlanDetails;
    /**
     * 
     * @type {string}
     * @memberof PricePlanListData
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PricePlanListData
     */
    'updatedAt': string;
    /**
     * 
     * @type {PricePlanType}
     * @memberof PricePlanListData
     */
    'type': PricePlanType;
}

export const PricePlanListDataStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type PricePlanListDataStatusEnum = typeof PricePlanListDataStatusEnum[keyof typeof PricePlanListDataStatusEnum];

/**
 * 
 * @export
 * @interface PricePlanPaginatedResponse
 */
export interface PricePlanPaginatedResponse {
    /**
     * 
     * @type {Array<PricePlanListData>}
     * @memberof PricePlanPaginatedResponse
     */
    'data': Array<PricePlanListData>;
    /**
     * 
     * @type {string}
     * @memberof PricePlanPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof PricePlanPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * Type of price plan
 * @export
 * @enum {string}
 */

export const PricePlanType = {
    Entitlement: 'ENTITLEMENT',
    Billing: 'BILLING'
} as const;

export type PricePlanType = typeof PricePlanType[keyof typeof PricePlanType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PriceType = {
    Flat: 'FLAT',
    PerUnit: 'PER_UNIT',
    Package: 'PACKAGE'
} as const;

export type PriceType = typeof PriceType[keyof typeof PriceType];


/**
 * Represents configurations related to pricing cycle
 * @export
 * @interface PricingCycleConfig
 */
export interface PricingCycleConfig {
    /**
     * Interval field allow you to define the billing interval you would like to set
     * @type {string}
     * @memberof PricingCycleConfig
     */
    'interval': PricingCycleConfigIntervalEnum;
    /**
     * 
     * @type {PricingCycleConfigStartOffset}
     * @memberof PricingCycleConfig
     */
    'startOffset': PricingCycleConfigStartOffset;
    /**
     * Togai allows you to ingest past dated events that will be processed by a pricing cycle till the end grace period.  For example: Pricing cycle is Monthly from 1st to 30th and gracePeriod is 5 days which next month 1 to 5th date, you can ingest past dated events during this grace period. 
     * @type {number}
     * @memberof PricingCycleConfig
     */
    'gracePeriod': number;
}

export const PricingCycleConfigIntervalEnum = {
    Monthly: 'MONTHLY',
    Quarterly: 'QUARTERLY',
    HalfYearly: 'HALF_YEARLY',
    Annually: 'ANNUALLY'
} as const;

export type PricingCycleConfigIntervalEnum = typeof PricingCycleConfigIntervalEnum[keyof typeof PricingCycleConfigIntervalEnum];

/**
 * Represents the start of pricing cycle in terms of  - dayOffset - number of days from beginning of month and  - monthOffset - number of months from beginning of interval (quarter, half-year or year) Note: If a day with offset doesn\'t exist for a month, closest previous day is considered Examples: MONTHLY -   - {dayOffset: 1, monthOffset: NIL} - First day of every month   - {dayOffset: 12, monthOffset: NIL} - 12th of every month   - {dayOffset: 28, monthOffset: NIL} - 28th of every month. i.e, 28th of Jan, 28th of Feb, ...   - {dayOffset: 30, monthOffset: NIL} - 30th of every month. i.e, 28th of Jan, 28th of Feb, ...   - {dayOffset: LAST, monthOffset: NIL} - Last day of every month. i.e, 31st of Jan, 28th of Feb, ... QUARTERLY   - {dayOffset: 15, monthOffset: FIRST} - 15th Jan, 15th Apr, 15th Jul and 15th Oct   - {dayOffset: 15, monthOffset: 2} - 15th Feb, 15th May, 15th Aug and 15th Nov   - {dayOffset: 15, monthOffset: LAST} - 15th Mar, 15th Jun, 15th Sep and 15th Dec   - {dayOffset: LAST, monthOffset: FIRST} - 31st Jan, 30th Apr, 30th Jul and 31th Oct HALF_YEARLY   - {dayOffset: 15, monthOffset: FIRST} - 15th Jan and 15th Jul   - {dayOffset: 15, monthOffset: 4} - 15th Apr and 15th Oct   - {dayOffset: 15, monthOffset: LAST} - 15th Jun and 15th Dec ANNUALLY   - {dayOffset: 15, monthOffset: FIRST} - 15th Jan   - {dayOffset: 15, monthOffset: 1} - 15th Jan   - {dayOffset: LAST, monthOffset: 2} - 29th Feb on Leap year, 28th otherwise    - {dayOffset: 15, monthOffset: 8} - 15th Aug   - {dayOffset: 15, monthOffset: LAST} - 15th Dec 
 * @export
 * @interface PricingCycleConfigStartOffset
 */
export interface PricingCycleConfigStartOffset {
    /**
     * min: \"1\" and max: \"31\" as strings. Spl. string allowed: LAST 
     * @type {string}
     * @memberof PricingCycleConfigStartOffset
     */
    'dayOffset': string;
    /**
     * min: \"1\" and max: \"12\". Spl. string allowed: FIRST / LAST. For QUARTERLY only 1 - 3 is allowed and for HALF_YEARLY 1 - 6. This being an optional field, shouldn\'t be passed for MONTHLY. 
     * @type {string}
     * @memberof PricingCycleConfigStartOffset
     */
    'monthOffset': string;
}
/**
 * Togai supports two type of pricing model Tiered and Volume. Tiered pricing model applies respective slab and its rate to the usage value while volume pricing model applies the latest matching slab of the usage value and applies respective rate.  For more understanding read [Rate Cards](https://docs.togai.com/docs/priceplan#setting-up-multiple-rate-cards) 
 * @export
 * @enum {string}
 */

export const PricingModel = {
    Tiered: 'TIERED',
    Volume: 'VOLUME'
} as const;

export type PricingModel = typeof PricingModel[keyof typeof PricingModel];


/**
 * Represents effectiveness period and config of a price plan. i.e, price plan bound by time.
 * @export
 * @interface PricingSchedule
 */
export interface PricingSchedule {
    /**
     * 
     * @type {string}
     * @memberof PricingSchedule
     */
    'id': string;
    /**
     * 
     * @type {PricePlanDetails}
     * @memberof PricingSchedule
     */
    'pricePlanDetails'?: PricePlanDetails;
    /**
     * 
     * @type {string}
     * @memberof PricingSchedule
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof PricingSchedule
     */
    'endDate': string;
    /**
     * 
     * @type {number}
     * @memberof PricingSchedule
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface PricingSchedulePaginatedResponse
 */
export interface PricingSchedulePaginatedResponse {
    /**
     * 
     * @type {Array<PricingScheduleWithPricePlanId>}
     * @memberof PricingSchedulePaginatedResponse
     */
    'data'?: Array<PricingScheduleWithPricePlanId>;
    /**
     * 
     * @type {string}
     * @memberof PricingSchedulePaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof PricingSchedulePaginatedResponse
     */
    'previousToken'?: string;
}
/**
 * 
 * @export
 * @interface PricingScheduleWithPricePlanId
 */
export interface PricingScheduleWithPricePlanId {
    /**
     * 
     * @type {string}
     * @memberof PricingScheduleWithPricePlanId
     */
    'id': string;
    /**
     * 
     * @type {PricePlanDetails}
     * @memberof PricingScheduleWithPricePlanId
     */
    'pricePlanDetails'?: PricePlanDetails;
    /**
     * 
     * @type {string}
     * @memberof PricingScheduleWithPricePlanId
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof PricingScheduleWithPricePlanId
     */
    'endDate': string;
    /**
     * 
     * @type {number}
     * @memberof PricingScheduleWithPricePlanId
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof PricingScheduleWithPricePlanId
     */
    'pricePlanId': string;
}
/**
 * 
 * @export
 * @interface PricingScheduleWithPricePlanIdAllOf
 */
export interface PricingScheduleWithPricePlanIdAllOf {
    /**
     * 
     * @type {string}
     * @memberof PricingScheduleWithPricePlanIdAllOf
     */
    'pricePlanId': string;
}
/**
 * Configuration for getting the proration, if not provided no proration will be applied
 * @export
 * @interface ProrationConfig
 */
export interface ProrationConfig {
    /**
     * Mode to get the proration - CUSTOM: Use the proration provided in the request - LOOKUP_CYCLE: Use the proration of a given account for the specified cycle 
     * @type {string}
     * @memberof ProrationConfig
     */
    'mode': ProrationConfigModeEnum;
    /**
     * 
     * @type {ProrationConfigCustomConfig}
     * @memberof ProrationConfig
     */
    'customConfig'?: ProrationConfigCustomConfig;
    /**
     * 
     * @type {ProrationConfigLookupCycleConfig}
     * @memberof ProrationConfig
     */
    'lookupCycleConfig'?: ProrationConfigLookupCycleConfig;
}

export const ProrationConfigModeEnum = {
    Custom: 'CUSTOM',
    LookupCycle: 'LOOKUP_CYCLE'
} as const;

export type ProrationConfigModeEnum = typeof ProrationConfigModeEnum[keyof typeof ProrationConfigModeEnum];

/**
 * Custom proration config, this will be considered if mode is CUSTOM
 * @export
 * @interface ProrationConfigCustomConfig
 */
export interface ProrationConfigCustomConfig {
    /**
     * 
     * @type {string}
     * @memberof ProrationConfigCustomConfig
     */
    'cycleStartDate': string;
    /**
     * 
     * @type {string}
     * @memberof ProrationConfigCustomConfig
     */
    'cycleEndDate': string;
    /**
     * 
     * @type {string}
     * @memberof ProrationConfigCustomConfig
     */
    'currentDate': string;
}
/**
 * Cycle of proration to be looked up, this will be considered if mode is LOOKUP_CYCLE
 * @export
 * @interface ProrationConfigLookupCycleConfig
 */
export interface ProrationConfigLookupCycleConfig {
    /**
     * Defaults to current date time if not provided
     * @type {string}
     * @memberof ProrationConfigLookupCycleConfig
     */
    'currentDateTime'?: string;
    /**
     * Defaults to current date time if not provided
     * @type {string}
     * @memberof ProrationConfigLookupCycleConfig
     */
    'cycleEffectiveOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProrationConfigLookupCycleConfig
     */
    'accountId': string;
}
/**
 * Represents a Purchase
 * @export
 * @interface Purchase
 */
export interface Purchase {
    /**
     * 
     * @type {string}
     * @memberof Purchase
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Purchase
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof Purchase
     */
    'pricePlanId': string;
    /**
     * 
     * @type {number}
     * @memberof Purchase
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof Purchase
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof Purchase
     */
    'pricePlanVersion': number;
    /**
     * 
     * @type {PurchasePlanOverride}
     * @memberof Purchase
     */
    'purchasePlanOverrides'?: PurchasePlanOverride;
    /**
     * 
     * @type {string}
     * @memberof Purchase
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Purchase
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof Purchase
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof Purchase
     */
    'invoiceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Purchase
     */
    'invoiceCurrency'?: string;
    /**
     * 
     * @type {PurchaseStatus}
     * @memberof Purchase
     */
    'status': PurchaseStatus;
}


/**
 * 
 * @export
 * @interface PurchaseFeatureDetails
 */
export interface PurchaseFeatureDetails {
    /**
     * 
     * @type {string}
     * @memberof PurchaseFeatureDetails
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseFeatureDetails
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PurchaseFeatureDetails
     */
    'creditsGranted': number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseFeatureDetails
     */
    'creditsAvailable': number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseFeatureDetails
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseFeatureDetails
     */
    'effectiveFrom': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseFeatureDetails
     */
    'effectiveUntil': string;
}
/**
 * Represents a Purchase for List Response
 * @export
 * @interface PurchaseListResponse
 */
export interface PurchaseListResponse {
    /**
     * 
     * @type {string}
     * @memberof PurchaseListResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseListResponse
     */
    'pricePlanId': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseListResponse
     */
    'pricePlanName': string;
    /**
     * 
     * @type {number}
     * @memberof PurchaseListResponse
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseListResponse
     */
    'pricePlanVersion': number;
    /**
     * 
     * @type {PurchaseStatus}
     * @memberof PurchaseListResponse
     */
    'status': PurchaseStatus;
    /**
     * 
     * @type {string}
     * @memberof PurchaseListResponse
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {PurchasePlanOverride}
     * @memberof PurchaseListResponse
     */
    'purchasePlan': PurchasePlanOverride;
    /**
     * 
     * @type {number}
     * @memberof PurchaseListResponse
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseListResponse
     */
    'invoiceCurrency'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseListResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseListResponse
     */
    'updatedAt'?: string;
}


/**
 * 
 * @export
 * @interface PurchasePaginatedListData
 */
export interface PurchasePaginatedListData {
    /**
     * 
     * @type {Array<PurchaseListResponse>}
     * @memberof PurchasePaginatedListData
     */
    'data'?: Array<PurchaseListResponse>;
    /**
     * 
     * @type {string}
     * @memberof PurchasePaginatedListData
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof PurchasePaginatedListData
     */
    'context'?: PaginationOptions;
}
/**
 * entitlements override options for purchase of a price plan for an account
 * @export
 * @interface PurchasePlanOverride
 */
export interface PurchasePlanOverride {
    /**
     * 
     * @type {RateDetails}
     * @memberof PurchasePlanOverride
     */
    'rateDetails'?: RateDetails;
    /**
     * 
     * @type {Array<EntitlementRateCard>}
     * @memberof PurchasePlanOverride
     */
    'entitlementRateCards'?: Array<EntitlementRateCard>;
}
/**
 * Status of the purchase
 * @export
 * @enum {string}
 */

export const PurchaseStatus = {
    Success: 'SUCCESS',
    Failure: 'FAILURE',
    Pending: 'PENDING'
} as const;

export type PurchaseStatus = typeof PurchaseStatus[keyof typeof PurchaseStatus];


/**
 * rate details for a price plan
 * @export
 * @interface RateDetails
 */
export interface RateDetails {
    /**
     * 
     * @type {Array<RateValue>}
     * @memberof RateDetails
     */
    'rateValues': Array<RateValue>;
    /**
     * 
     * @type {RatePlan}
     * @memberof RateDetails
     */
    'ratePlan': RatePlan;
}
/**
 * Contains all rate related configurations
 * @export
 * @interface RatePlan
 */
export interface RatePlan {
    /**
     * 
     * @type {PricingModel}
     * @memberof RatePlan
     */
    'pricingModel': PricingModel;
    /**
     * Rate cards can have single or multiple slab up to 100.
     * @type {Array<Slab>}
     * @memberof RatePlan
     */
    'slabs': Array<Slab>;
}


/**
 * Represents a rate
 * @export
 * @interface RateValue
 */
export interface RateValue {
    /**
     * 
     * @type {string}
     * @memberof RateValue
     */
    'currency': string;
    /**
     * 
     * @type {Array<SlabRate>}
     * @memberof RateValue
     */
    'slabRates': Array<SlabRate>;
}
/**
 * Payload to remove aliases from account
 * @export
 * @interface RemoveAccountAliasesRequest
 */
export interface RemoveAccountAliasesRequest {
    /**
     * List of aliases to remove
     * @type {Array<string>}
     * @memberof RemoveAccountAliasesRequest
     */
    'aliases'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RevenueInfo
 */
export interface RevenueInfo {
    /**
     * 
     * @type {UsageRateCard}
     * @memberof RevenueInfo
     */
    'usageRateCard'?: UsageRateCard;
    /**
     * 
     * @type {FixedFeeRateCard}
     * @memberof RevenueInfo
     */
    'fixedFeeRateCard'?: FixedFeeRateCard;
    /**
     * 
     * @type {LicenseRateCard}
     * @memberof RevenueInfo
     */
    'licenseRateCard'?: LicenseRateCard;
    /**
     * 
     * @type {BillingEntitlementRateCard}
     * @memberof RevenueInfo
     */
    'billingEntitlementRateCard'?: BillingEntitlementRateCard;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof RevenueInfo
     */
    'usages': { [key: string]: number; };
    /**
     * 
     * @type {FixedFeeRevenueSummary}
     * @memberof RevenueInfo
     */
    'fixedFeeRevenueSummary'?: FixedFeeRevenueSummary;
    /**
     * 
     * @type {LicenseRevenueSummary}
     * @memberof RevenueInfo
     */
    'licenseRevenueSummary'?: LicenseRevenueSummary;
    /**
     * 
     * @type {BillingEntitlementRevenueSummary}
     * @memberof RevenueInfo
     */
    'billingEntitlementRevenueSummary'?: BillingEntitlementRevenueSummary;
    /**
     * 
     * @type {Array<SlabRevenueSummary>}
     * @memberof RevenueInfo
     */
    'slabRevenueSummaries'?: Array<SlabRevenueSummary>;
}
/**
 * Represents a setting
 * @export
 * @interface Setting
 */
export interface Setting {
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'entityType': string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'entityId': string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'name': string;
    /**
     * 
     * @type {SettingDataType}
     * @memberof Setting
     */
    'dataType': SettingDataType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SettingDataType = {
    String: 'STRING',
    Numeric: 'NUMERIC',
    Json: 'JSON',
    JsonLogic: 'JSON_LOGIC'
} as const;

export type SettingDataType = typeof SettingDataType[keyof typeof SettingDataType];


/**
 * 
 * @export
 * @interface SettingPaginatedResponse
 */
export interface SettingPaginatedResponse {
    /**
     * 
     * @type {Array<Setting>}
     * @memberof SettingPaginatedResponse
     */
    'data'?: Array<Setting>;
    /**
     * 
     * @type {string}
     * @memberof SettingPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof SettingPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * Represents a pricing priceType (rates + slabs) for usage price plan
 * @export
 * @interface Slab
 */
export interface Slab {
    /**
     * 
     * @type {number}
     * @memberof Slab
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof Slab
     */
    'startAfter': number;
    /**
     * 
     * @type {PriceType}
     * @memberof Slab
     */
    'priceType': PriceType;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Slab
     */
    'slabConfig'?: { [key: string]: string; };
}


/**
 * Represents a rate for a slab
 * @export
 * @interface SlabRate
 */
export interface SlabRate {
    /**
     * 
     * @type {number}
     * @memberof SlabRate
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof SlabRate
     */
    'rate': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SlabRate
     */
    'slabRateConfig'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface SlabRevenueMetadata
 */
export interface SlabRevenueMetadata {
    /**
     * 
     * @type {boolean}
     * @memberof SlabRevenueMetadata
     */
    'minimumRateApplied'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SlabRevenueMetadata
     */
    'maximumRateApplied'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SlabRevenueMetadata
     */
    'packageQuantity'?: number;
}
/**
 * 
 * @export
 * @interface SlabRevenueSummary
 */
export interface SlabRevenueSummary {
    /**
     * 
     * @type {number}
     * @memberof SlabRevenueSummary
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof SlabRevenueSummary
     */
    'usage': number;
    /**
     * 
     * @type {number}
     * @memberof SlabRevenueSummary
     */
    'revenue': number;
    /**
     * 
     * @type {SlabRevenueMetadata}
     * @memberof SlabRevenueSummary
     */
    'metadata'?: SlabRevenueMetadata;
}
/**
 * Payload to update account
 * @export
 * @interface UpdateAccountRequest
 */
export interface UpdateAccountRequest {
    /**
     * Name of the Account
     * @type {string}
     * @memberof UpdateAccountRequest
     */
    'name'?: string;
}
/**
 * Request to update an addon
 * @export
 * @interface UpdateAddOnRequest
 */
export interface UpdateAddOnRequest {
    /**
     * Name of addon
     * @type {string}
     * @memberof UpdateAddOnRequest
     */
    'name'?: string;
}
/**
 * Payload to update customer
 * @export
 * @interface UpdateCustomerRequest
 */
export interface UpdateCustomerRequest {
    /**
     * Name of the Customer
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'name'?: string;
    /**
     * Primary email of the customer
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'primaryEmail'?: string;
    /**
     * billing address of the customer
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'billingAddress'?: string;
}
/**
 * Request to update event schema
 * @export
 * @interface UpdateEventSchemaRequest
 */
export interface UpdateEventSchemaRequest {
    /**
     * Description of the event
     * @type {string}
     * @memberof UpdateEventSchemaRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<EventAttributeSchema>}
     * @memberof UpdateEventSchemaRequest
     */
    'attributes'?: Array<EventAttributeSchema>;
    /**
     * 
     * @type {Array<DimensionsSchema>}
     * @memberof UpdateEventSchemaRequest
     */
    'dimensions'?: Array<DimensionsSchema>;
    /**
     * 
     * @type {Enrichments}
     * @memberof UpdateEventSchemaRequest
     */
    'enrichments'?: Enrichments;
}
/**
 * Update a Feature properties
 * @export
 * @interface UpdateFeatureRequest
 */
export interface UpdateFeatureRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateFeatureRequest
     */
    'name': string;
    /**
     * Association of a feature with event_schemas
     * @type {Array<EventSchemasForFeature>}
     * @memberof UpdateFeatureRequest
     */
    'schemaAssociations': Array<EventSchemasForFeature>;
}
/**
 * Request to update a price plan
 * @export
 * @interface UpdatePricePlanRequest
 */
export interface UpdatePricePlanRequest {
    /**
     * Description of price plan
     * @type {string}
     * @memberof UpdatePricePlanRequest
     */
    'description'?: string;
    /**
     * 
     * @type {CreatePricePlanDetailsOverride}
     * @memberof UpdatePricePlanRequest
     */
    'pricePlanDetails'?: CreatePricePlanDetailsOverride;
    /**
     * 
     * @type {string}
     * @memberof UpdatePricePlanRequest
     */
    'migrationMode'?: UpdatePricePlanRequestMigrationModeEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdatePricePlanRequest
     */
    'versionsToMigrate'?: UpdatePricePlanRequestVersionsToMigrateEnum;
}

export const UpdatePricePlanRequestMigrationModeEnum = {
    Immediate: 'IMMEDIATE',
    ImmediateIgnoreOverride: 'IMMEDIATE_IGNORE_OVERRIDE',
    NextCycle: 'NEXT_CYCLE',
    NextCycleIgnoreOverride: 'NEXT_CYCLE_IGNORE_OVERRIDE',
    None: 'NONE'
} as const;

export type UpdatePricePlanRequestMigrationModeEnum = typeof UpdatePricePlanRequestMigrationModeEnum[keyof typeof UpdatePricePlanRequestMigrationModeEnum];
export const UpdatePricePlanRequestVersionsToMigrateEnum = {
    LatestVersion: 'LATEST_VERSION',
    AllVersion: 'ALL_VERSION'
} as const;

export type UpdatePricePlanRequestVersionsToMigrateEnum = typeof UpdatePricePlanRequestVersionsToMigrateEnum[keyof typeof UpdatePricePlanRequestVersionsToMigrateEnum];

/**
 * Request to dis/associate a price plan to an account
 * @export
 * @interface UpdatePricingScheduleRequest
 */
export interface UpdatePricingScheduleRequest {
    /**
     * Mode of request to create dis/association
     * @type {string}
     * @memberof UpdatePricingScheduleRequest
     */
    'mode'?: UpdatePricingScheduleRequestModeEnum;
    /**
     * Id of the price plan if association request
     * @type {string}
     * @memberof UpdatePricingScheduleRequest
     */
    'pricePlanId'?: string;
    /**
     * Date of effectiveness of the association. - Expected only if the account already has a price plan associated with it. 
     * @type {string}
     * @memberof UpdatePricingScheduleRequest
     */
    'effectiveFrom': string;
    /**
     * Date until which the association must be effective. - Expected only if effectiveFrom is present. 
     * @type {string}
     * @memberof UpdatePricingScheduleRequest
     */
    'effectiveUntil': string;
    /**
     * 
     * @type {CreatePricePlanDetailsOverride}
     * @memberof UpdatePricingScheduleRequest
     */
    'pricePlanDetailsOverride'?: CreatePricePlanDetailsOverride;
}

export const UpdatePricingScheduleRequestModeEnum = {
    Associate: 'ASSOCIATE',
    Disassociate: 'DISASSOCIATE'
} as const;

export type UpdatePricingScheduleRequestModeEnum = typeof UpdatePricingScheduleRequestModeEnum[keyof typeof UpdatePricingScheduleRequestModeEnum];

/**
 * 
 * @export
 * @interface UpdatePricingScheduleResponse
 */
export interface UpdatePricingScheduleResponse {
    /**
     * Identifier of the account
     * @type {string}
     * @memberof UpdatePricingScheduleResponse
     */
    'accountId': string;
    /**
     * Name of the Account
     * @type {string}
     * @memberof UpdatePricingScheduleResponse
     */
    'accountName': string;
    /**
     * 
     * @type {Array<PlanOverride>}
     * @memberof UpdatePricingScheduleResponse
     */
    'pricingSchedules': Array<PlanOverride>;
}
/**
 * Update Settings
 * @export
 * @interface UpdateSettingRequest
 */
export interface UpdateSettingRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateSettingRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSettingRequest
     */
    'value'?: string;
    /**
     * 
     * @type {SettingDataType}
     * @memberof UpdateSettingRequest
     */
    'dataType'?: SettingDataType;
}


/**
 * Request to update usage meter
 * @export
 * @interface UpdateUsageMeterRequest
 */
export interface UpdateUsageMeterRequest {
    /**
     * Description of the event
     * @type {string}
     * @memberof UpdateUsageMeterRequest
     */
    'description'?: string;
    /**
     * Type of usage meter * COUNTER - Count usage 
     * @type {string}
     * @memberof UpdateUsageMeterRequest
     */
    'type'?: UpdateUsageMeterRequestTypeEnum;
    /**
     * Aggregation to be applied on usage meter result * COUNT - Counts number of events matching the usage meter * SUM - Sums up results of computation of all events matching usage meter 
     * @type {string}
     * @memberof UpdateUsageMeterRequest
     */
    'aggregation'?: UpdateUsageMeterRequestAggregationEnum;
    /**
     * 
     * @type {Array<Computation>}
     * @memberof UpdateUsageMeterRequest
     */
    'computations'?: Array<Computation>;
}

export const UpdateUsageMeterRequestTypeEnum = {
    Counter: 'COUNTER'
} as const;

export type UpdateUsageMeterRequestTypeEnum = typeof UpdateUsageMeterRequestTypeEnum[keyof typeof UpdateUsageMeterRequestTypeEnum];
export const UpdateUsageMeterRequestAggregationEnum = {
    Count: 'COUNT',
    Sum: 'SUM'
} as const;

export type UpdateUsageMeterRequestAggregationEnum = typeof UpdateUsageMeterRequestAggregationEnum[keyof typeof UpdateUsageMeterRequestAggregationEnum];

/**
 * Configuration for getting the usage
 * @export
 * @interface UsageConfig
 */
export interface UsageConfig {
    /**
     * Mode to get the usage for the usage meters - CUSTOM: Use the usages provided in the request - LOOKUP_RANGE: Use the usage of a given account for the specified range - LOOKUP_CYCLE: Use the usage of a given account for the specified cycle 
     * @type {string}
     * @memberof UsageConfig
     */
    'mode': UsageConfigModeEnum;
    /**
     * Map of usage meter id and usage, this will be considered if mode is CUSTOM
     * @type {{ [key: string]: number; }}
     * @memberof UsageConfig
     */
    'usageMap'?: { [key: string]: number; };
    /**
     * 
     * @type {UsageConfigLookupRange}
     * @memberof UsageConfig
     */
    'lookupRange'?: UsageConfigLookupRange;
    /**
     * 
     * @type {UsageConfigLookupCycle}
     * @memberof UsageConfig
     */
    'lookupCycle'?: UsageConfigLookupCycle;
}

export const UsageConfigModeEnum = {
    Custom: 'CUSTOM',
    LookupRange: 'LOOKUP_RANGE',
    LookupCycle: 'LOOKUP_CYCLE'
} as const;

export type UsageConfigModeEnum = typeof UsageConfigModeEnum[keyof typeof UsageConfigModeEnum];

/**
 * Cycle of usage to be looked up, this will be considered if mode is LOOKUP_CYCLE
 * @export
 * @interface UsageConfigLookupCycle
 */
export interface UsageConfigLookupCycle {
    /**
     * 
     * @type {string}
     * @memberof UsageConfigLookupCycle
     */
    'cycleEffectiveOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsageConfigLookupCycle
     */
    'accountId': string;
}
/**
 * Range of usage to be looked up, this will be considered if mode is LOOKUP_RANGE
 * @export
 * @interface UsageConfigLookupRange
 */
export interface UsageConfigLookupRange {
    /**
     * 
     * @type {string}
     * @memberof UsageConfigLookupRange
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof UsageConfigLookupRange
     */
    'end': string;
    /**
     * 
     * @type {string}
     * @memberof UsageConfigLookupRange
     */
    'accountId': string;
}
/**
 * Start and end dates of usage lookup if usage mode is LOOKUP
 * @export
 * @interface UsageLookupRange
 */
export interface UsageLookupRange {
    /**
     * 
     * @type {string}
     * @memberof UsageLookupRange
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof UsageLookupRange
     */
    'end': string;
}
/**
 * Structure of usage meter
 * @export
 * @interface UsageMeter
 */
export interface UsageMeter {
    /**
     * Identifier of the usage meter
     * @type {string}
     * @memberof UsageMeter
     */
    'id': string;
    /**
     * Name of the usage meter
     * @type {string}
     * @memberof UsageMeter
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UsageMeter
     */
    'description'?: string;
    /**
     * Type of usage meter
     * @type {string}
     * @memberof UsageMeter
     */
    'type': UsageMeterTypeEnum;
    /**
     * Status of usage meter
     * @type {string}
     * @memberof UsageMeter
     */
    'status'?: UsageMeterStatusEnum;
    /**
     * Aggregation to be applied on usage meter result
     * @type {string}
     * @memberof UsageMeter
     */
    'aggregation': UsageMeterAggregationEnum;
    /**
     * 
     * @type {Array<Computation>}
     * @memberof UsageMeter
     */
    'computations'?: Array<Computation>;
    /**
     * 
     * @type {string}
     * @memberof UsageMeter
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsageMeter
     */
    'lastActivatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsageMeter
     */
    'updatedAt'?: string;
}

export const UsageMeterTypeEnum = {
    Counter: 'COUNTER'
} as const;

export type UsageMeterTypeEnum = typeof UsageMeterTypeEnum[keyof typeof UsageMeterTypeEnum];
export const UsageMeterStatusEnum = {
    Draft: 'DRAFT',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type UsageMeterStatusEnum = typeof UsageMeterStatusEnum[keyof typeof UsageMeterStatusEnum];
export const UsageMeterAggregationEnum = {
    Count: 'COUNT',
    Sum: 'SUM'
} as const;

export type UsageMeterAggregationEnum = typeof UsageMeterAggregationEnum[keyof typeof UsageMeterAggregationEnum];

/**
 * 
 * @export
 * @interface UsageMeterPaginatedResponse
 */
export interface UsageMeterPaginatedResponse {
    /**
     * 
     * @type {Array<UsageMeter>}
     * @memberof UsageMeterPaginatedResponse
     */
    'data'?: Array<UsageMeter>;
    /**
     * 
     * @type {string}
     * @memberof UsageMeterPaginatedResponse
     */
    'nextToken'?: string;
    /**
     * 
     * @type {PaginationOptions}
     * @memberof UsageMeterPaginatedResponse
     */
    'context'?: PaginationOptions;
}
/**
 * 
 * @export
 * @interface UsageRate
 */
export interface UsageRate {
    /**
     * The usage meter will be associated with the rate card to transform the usage value to billable value
     * @type {string}
     * @memberof UsageRate
     */
    'usageMeterId': string;
    /**
     * List of slab rates
     * @type {Array<SlabRate>}
     * @memberof UsageRate
     */
    'slabRates': Array<SlabRate>;
}
/**
 * 
 * @export
 * @interface UsageRateCard
 */
export interface UsageRateCard {
    /**
     * Name your rate card, this will be displayed in the Togai App
     * @type {string}
     * @memberof UsageRateCard
     */
    'displayName': string;
    /**
     * A tag string to group usageRateCards
     * @type {string}
     * @memberof UsageRateCard
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsageRateCard
     */
    'usageMeterId': string;
    /**
     * 
     * @type {RatePlan}
     * @memberof UsageRateCard
     */
    'ratePlan': RatePlan;
    /**
     * 
     * @type {Array<RateValue>}
     * @memberof UsageRateCard
     */
    'rateValues': Array<RateValue>;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add aliases to an account using customer_id and account_id.
         * @summary Add Aliases to account
         * @param {string} accountId account_id corresponding to an account
         * @param {AddAccountAliasesRequest} addAccountAliasesRequest Payload to add aliases to account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAliases: async (accountId: string, addAccountAliasesRequest: AddAccountAliasesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('addAliases', 'accountId', accountId)
            // verify required parameter 'addAccountAliasesRequest' is not null or undefined
            assertParamExists('addAliases', 'addAccountAliasesRequest', addAccountAliasesRequest)
            const localVarPath = `/accounts/{account_id}/add_aliases`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAccountAliasesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to create an account for a customer using customer_id.
         * @summary Create an account
         * @param {CreateAccountRequest} createAccountRequest Payload to create account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (createAccountRequest: CreateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccountRequest' is not null or undefined
            assertParamExists('createAccount', 'createAccountRequest', createAccountRequest)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to delete a customer using customer_id and account_id.
         * @summary Delete an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account information using customer_id and account_id.
         * @summary Get an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of accounts of a customer with pagination and sort.
         * @summary List accounts of customer
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of pricing schedules of an account with pagination and sort.
         * @summary List pricing schedules of an account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingSchedules: async (accountId: string, nextToken?: string, pageSize?: number, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getPricingSchedules', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/pricing_schedules`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get purchase information of an account for a specific plan using account_id and price_plan_id
         * @summary Get a specific purchase of an account
         * @param {string} purchaseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPurchase: async (purchaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'purchaseId' is not null or undefined
            assertParamExists('getPurchase', 'purchaseId', purchaseId)
            const localVarPath = `/purchases/{purchase_id}`
                .replace(`{${"purchase_id"}}`, encodeURIComponent(String(purchaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to initiate a purchase for an account
         * @summary Initiate a purchase
         * @param {string} accountId account_id corresponding to an account
         * @param {CreatePurchaseRequest} createPurchaseRequest Payload to initiate a purchase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateOneTimeEntitlementPlan: async (accountId: string, createPurchaseRequest: CreatePurchaseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('initiateOneTimeEntitlementPlan', 'accountId', accountId)
            // verify required parameter 'createPurchaseRequest' is not null or undefined
            assertParamExists('initiateOneTimeEntitlementPlan', 'createPurchaseRequest', createPurchaseRequest)
            const localVarPath = `/accounts/{account_id}/purchases`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPurchaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Purchase information for an account using account_id and price_plan_id
         * @summary Get all purchases for an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountPurchases: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listAccountPurchases', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/purchases`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove existing aliases tagged to an account using this API
         * @summary Remove Aliases to account
         * @param {string} accountId account_id corresponding to an account
         * @param {RemoveAccountAliasesRequest} removeAccountAliasesRequest Payload to remove aliases from account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAliases: async (accountId: string, removeAccountAliasesRequest: RemoveAccountAliasesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('removeAliases', 'accountId', accountId)
            // verify required parameter 'removeAccountAliasesRequest' is not null or undefined
            assertParamExists('removeAliases', 'removeAccountAliasesRequest', removeAccountAliasesRequest)
            const localVarPath = `/accounts/{account_id}/remove_aliases`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeAccountAliasesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to update an account’s information using customer_id and account_id.
         * @summary Update an account
         * @param {string} accountId account_id corresponding to an account
         * @param {UpdateAccountRequest} updateAccountRequest Payload to update account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (accountId: string, updateAccountRequest: UpdateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateAccount', 'accountId', accountId)
            // verify required parameter 'updateAccountRequest' is not null or undefined
            assertParamExists('updateAccount', 'updateAccountRequest', updateAccountRequest)
            const localVarPath = `/accounts/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to detach/attach a price plan from/to an existing account
         * @summary Dis/associate a plan from/to an account
         * @param {string} accountId account_id corresponding to an account
         * @param {UpdatePricingScheduleRequest} updatePricingScheduleRequest Payload to dis/associate a price plan to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricingSchedule: async (accountId: string, updatePricingScheduleRequest: UpdatePricingScheduleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updatePricingSchedule', 'accountId', accountId)
            // verify required parameter 'updatePricingScheduleRequest' is not null or undefined
            assertParamExists('updatePricingSchedule', 'updatePricingScheduleRequest', updatePricingScheduleRequest)
            const localVarPath = `/accounts/{account_id}/price_plans`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePricingScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to detach/attach one or more price plans from/to an existing account
         * @summary Edit schedules of an account.
         * @param {string} accountId account_id corresponding to an account
         * @param {EditPricingScheduleRequest} editPricingScheduleRequest Payload to dis/associate one or more price plans to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricingScheduleBatch: async (accountId: string, editPricingScheduleRequest: EditPricingScheduleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updatePricingScheduleBatch', 'accountId', accountId)
            // verify required parameter 'editPricingScheduleRequest' is not null or undefined
            assertParamExists('updatePricingScheduleBatch', 'editPricingScheduleRequest', editPricingScheduleRequest)
            const localVarPath = `/accounts/{account_id}/edit_schedules`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editPricingScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add aliases to an account using customer_id and account_id.
         * @summary Add Aliases to account
         * @param {string} accountId account_id corresponding to an account
         * @param {AddAccountAliasesRequest} addAccountAliasesRequest Payload to add aliases to account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAliases(accountId: string, addAccountAliasesRequest: AddAccountAliasesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAliases(accountId, addAccountAliasesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to create an account for a customer using customer_id.
         * @summary Create an account
         * @param {CreateAccountRequest} createAccountRequest Payload to create account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(createAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to delete a customer using customer_id and account_id.
         * @summary Delete an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get account information using customer_id and account_id.
         * @summary Get an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of accounts of a customer with pagination and sort.
         * @summary List accounts of customer
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of pricing schedules of an account with pagination and sort.
         * @summary List pricing schedules of an account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricingSchedules(accountId: string, nextToken?: string, pageSize?: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricingSchedulePaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricingSchedules(accountId, nextToken, pageSize, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get purchase information of an account for a specific plan using account_id and price_plan_id
         * @summary Get a specific purchase of an account
         * @param {string} purchaseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPurchase(purchaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPurchaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPurchase(purchaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to initiate a purchase for an account
         * @summary Initiate a purchase
         * @param {string} accountId account_id corresponding to an account
         * @param {CreatePurchaseRequest} createPurchaseRequest Payload to initiate a purchase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateOneTimeEntitlementPlan(accountId: string, createPurchaseRequest: CreatePurchaseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Purchase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateOneTimeEntitlementPlan(accountId, createPurchaseRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Purchase information for an account using account_id and price_plan_id
         * @summary Get all purchases for an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountPurchases(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PurchasePaginatedListData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountPurchases(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove existing aliases tagged to an account using this API
         * @summary Remove Aliases to account
         * @param {string} accountId account_id corresponding to an account
         * @param {RemoveAccountAliasesRequest} removeAccountAliasesRequest Payload to remove aliases from account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAliases(accountId: string, removeAccountAliasesRequest: RemoveAccountAliasesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAliases(accountId, removeAccountAliasesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to update an account’s information using customer_id and account_id.
         * @summary Update an account
         * @param {string} accountId account_id corresponding to an account
         * @param {UpdateAccountRequest} updateAccountRequest Payload to update account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(accountId: string, updateAccountRequest: UpdateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(accountId, updateAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to detach/attach a price plan from/to an existing account
         * @summary Dis/associate a plan from/to an account
         * @param {string} accountId account_id corresponding to an account
         * @param {UpdatePricingScheduleRequest} updatePricingScheduleRequest Payload to dis/associate a price plan to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePricingSchedule(accountId: string, updatePricingScheduleRequest: UpdatePricingScheduleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdatePricingScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePricingSchedule(accountId, updatePricingScheduleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to detach/attach one or more price plans from/to an existing account
         * @summary Edit schedules of an account.
         * @param {string} accountId account_id corresponding to an account
         * @param {EditPricingScheduleRequest} editPricingScheduleRequest Payload to dis/associate one or more price plans to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePricingScheduleBatch(accountId: string, editPricingScheduleRequest: EditPricingScheduleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdatePricingScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePricingScheduleBatch(accountId, editPricingScheduleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Add aliases to an account using customer_id and account_id.
         * @summary Add Aliases to account
         * @param {string} accountId account_id corresponding to an account
         * @param {AddAccountAliasesRequest} addAccountAliasesRequest Payload to add aliases to account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAliases(accountId: string, addAccountAliasesRequest: AddAccountAliasesRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.addAliases(accountId, addAccountAliasesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to create an account for a customer using customer_id.
         * @summary Create an account
         * @param {CreateAccountRequest} createAccountRequest Payload to create account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(createAccountRequest: CreateAccountRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.createAccount(createAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to delete a customer using customer_id and account_id.
         * @summary Delete an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(accountId: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get account information using customer_id and account_id.
         * @summary Get an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accountId: string, options?: any): AxiosPromise<Account> {
            return localVarFp.getAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of accounts of a customer with pagination and sort.
         * @summary List accounts of customer
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(nextToken?: string, pageSize?: number, options?: any): AxiosPromise<AccountPaginatedResponse> {
            return localVarFp.getAccounts(nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of pricing schedules of an account with pagination and sort.
         * @summary List pricing schedules of an account
         * @param {string} accountId account_id corresponding to an account
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingSchedules(accountId: string, nextToken?: string, pageSize?: number, startDate?: string, endDate?: string, options?: any): AxiosPromise<PricingSchedulePaginatedResponse> {
            return localVarFp.getPricingSchedules(accountId, nextToken, pageSize, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get purchase information of an account for a specific plan using account_id and price_plan_id
         * @summary Get a specific purchase of an account
         * @param {string} purchaseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPurchase(purchaseId: string, options?: any): AxiosPromise<GetPurchaseResponse> {
            return localVarFp.getPurchase(purchaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to initiate a purchase for an account
         * @summary Initiate a purchase
         * @param {string} accountId account_id corresponding to an account
         * @param {CreatePurchaseRequest} createPurchaseRequest Payload to initiate a purchase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateOneTimeEntitlementPlan(accountId: string, createPurchaseRequest: CreatePurchaseRequest, options?: any): AxiosPromise<Purchase> {
            return localVarFp.initiateOneTimeEntitlementPlan(accountId, createPurchaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Purchase information for an account using account_id and price_plan_id
         * @summary Get all purchases for an account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountPurchases(accountId: string, options?: any): AxiosPromise<PurchasePaginatedListData> {
            return localVarFp.listAccountPurchases(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove existing aliases tagged to an account using this API
         * @summary Remove Aliases to account
         * @param {string} accountId account_id corresponding to an account
         * @param {RemoveAccountAliasesRequest} removeAccountAliasesRequest Payload to remove aliases from account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAliases(accountId: string, removeAccountAliasesRequest: RemoveAccountAliasesRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.removeAliases(accountId, removeAccountAliasesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to update an account’s information using customer_id and account_id.
         * @summary Update an account
         * @param {string} accountId account_id corresponding to an account
         * @param {UpdateAccountRequest} updateAccountRequest Payload to update account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(accountId: string, updateAccountRequest: UpdateAccountRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.updateAccount(accountId, updateAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to detach/attach a price plan from/to an existing account
         * @summary Dis/associate a plan from/to an account
         * @param {string} accountId account_id corresponding to an account
         * @param {UpdatePricingScheduleRequest} updatePricingScheduleRequest Payload to dis/associate a price plan to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricingSchedule(accountId: string, updatePricingScheduleRequest: UpdatePricingScheduleRequest, options?: any): AxiosPromise<UpdatePricingScheduleResponse> {
            return localVarFp.updatePricingSchedule(accountId, updatePricingScheduleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to detach/attach one or more price plans from/to an existing account
         * @summary Edit schedules of an account.
         * @param {string} accountId account_id corresponding to an account
         * @param {EditPricingScheduleRequest} editPricingScheduleRequest Payload to dis/associate one or more price plans to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricingScheduleBatch(accountId: string, editPricingScheduleRequest: EditPricingScheduleRequest, options?: any): AxiosPromise<UpdatePricingScheduleResponse> {
            return localVarFp.updatePricingScheduleBatch(accountId, editPricingScheduleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Add aliases to an account using customer_id and account_id.
     * @summary Add Aliases to account
     * @param {string} accountId account_id corresponding to an account
     * @param {AddAccountAliasesRequest} addAccountAliasesRequest Payload to add aliases to account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public addAliases(accountId: string, addAccountAliasesRequest: AddAccountAliasesRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).addAliases(accountId, addAccountAliasesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to create an account for a customer using customer_id.
     * @summary Create an account
     * @param {CreateAccountRequest} createAccountRequest Payload to create account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccount(createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createAccount(createAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to delete a customer using customer_id and account_id.
     * @summary Delete an account
     * @param {string} accountId account_id corresponding to an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteAccount(accountId: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).deleteAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get account information using customer_id and account_id.
     * @summary Get an account
     * @param {string} accountId account_id corresponding to an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(accountId: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of accounts of a customer with pagination and sort.
     * @summary List accounts of customer
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccounts(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccounts(nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of pricing schedules of an account with pagination and sort.
     * @summary List pricing schedules of an account
     * @param {string} accountId account_id corresponding to an account
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getPricingSchedules(accountId: string, nextToken?: string, pageSize?: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getPricingSchedules(accountId, nextToken, pageSize, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get purchase information of an account for a specific plan using account_id and price_plan_id
     * @summary Get a specific purchase of an account
     * @param {string} purchaseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getPurchase(purchaseId: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getPurchase(purchaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to initiate a purchase for an account
     * @summary Initiate a purchase
     * @param {string} accountId account_id corresponding to an account
     * @param {CreatePurchaseRequest} createPurchaseRequest Payload to initiate a purchase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public initiateOneTimeEntitlementPlan(accountId: string, createPurchaseRequest: CreatePurchaseRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).initiateOneTimeEntitlementPlan(accountId, createPurchaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Purchase information for an account using account_id and price_plan_id
     * @summary Get all purchases for an account
     * @param {string} accountId account_id corresponding to an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAccountPurchases(accountId: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listAccountPurchases(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove existing aliases tagged to an account using this API
     * @summary Remove Aliases to account
     * @param {string} accountId account_id corresponding to an account
     * @param {RemoveAccountAliasesRequest} removeAccountAliasesRequest Payload to remove aliases from account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public removeAliases(accountId: string, removeAccountAliasesRequest: RemoveAccountAliasesRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).removeAliases(accountId, removeAccountAliasesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to update an account’s information using customer_id and account_id.
     * @summary Update an account
     * @param {string} accountId account_id corresponding to an account
     * @param {UpdateAccountRequest} updateAccountRequest Payload to update account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateAccount(accountId: string, updateAccountRequest: UpdateAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updateAccount(accountId, updateAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to detach/attach a price plan from/to an existing account
     * @summary Dis/associate a plan from/to an account
     * @param {string} accountId account_id corresponding to an account
     * @param {UpdatePricingScheduleRequest} updatePricingScheduleRequest Payload to dis/associate a price plan to an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updatePricingSchedule(accountId: string, updatePricingScheduleRequest: UpdatePricingScheduleRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updatePricingSchedule(accountId, updatePricingScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to detach/attach one or more price plans from/to an existing account
     * @summary Edit schedules of an account.
     * @param {string} accountId account_id corresponding to an account
     * @param {EditPricingScheduleRequest} editPricingScheduleRequest Payload to dis/associate one or more price plans to an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updatePricingScheduleBatch(accountId: string, editPricingScheduleRequest: EditPricingScheduleRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updatePricingScheduleBatch(accountId, editPricingScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AddOnsApi - axios parameter creator
 * @export
 */
export const AddOnsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an AddOn
         * @summary Create an AddOn
         * @param {CreateAddOnRequest} createAddOnRequest Payload to create addon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddOn: async (createAddOnRequest: CreateAddOnRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAddOnRequest' is not null or undefined
            assertParamExists('createAddOn', 'createAddOnRequest', createAddOnRequest)
            const localVarPath = `/addons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAddOnRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archive an addOn
         * @summary Delete an addon
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAddOn: async (addonId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addonId' is not null or undefined
            assertParamExists('deleteAddOn', 'addonId', addonId)
            const localVarPath = `/addons/{addon_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of an addon
         * @summary Get an addon
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddOn: async (addonId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addonId' is not null or undefined
            assertParamExists('getAddOn', 'addonId', addonId)
            const localVarPath = `/addons/{addon_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of add-ons
         * @summary List addOns
         * @param {'ACTIVE' | 'ARCHIVED'} [status] Filter by status 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddOns: async (status?: 'ACTIVE' | 'ARCHIVED', nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/addons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing addon 
         * @summary Update an addon
         * @param {string} addonId 
         * @param {UpdateAddOnRequest} updateAddOnRequest Payload to update addon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAddOn: async (addonId: string, updateAddOnRequest: UpdateAddOnRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addonId' is not null or undefined
            assertParamExists('updateAddOn', 'addonId', addonId)
            // verify required parameter 'updateAddOnRequest' is not null or undefined
            assertParamExists('updateAddOn', 'updateAddOnRequest', updateAddOnRequest)
            const localVarPath = `/addons/{addon_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAddOnRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddOnsApi - functional programming interface
 * @export
 */
export const AddOnsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddOnsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an AddOn
         * @summary Create an AddOn
         * @param {CreateAddOnRequest} createAddOnRequest Payload to create addon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAddOn(createAddOnRequest: CreateAddOnRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAddOn(createAddOnRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Archive an addOn
         * @summary Delete an addon
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAddOn(addonId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAddOn(addonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of an addon
         * @summary Get an addon
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddOn(addonId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddOn(addonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of add-ons
         * @summary List addOns
         * @param {'ACTIVE' | 'ARCHIVED'} [status] Filter by status 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddOns(status?: 'ACTIVE' | 'ARCHIVED', nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOnPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddOns(status, nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing addon 
         * @summary Update an addon
         * @param {string} addonId 
         * @param {UpdateAddOnRequest} updateAddOnRequest Payload to update addon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAddOn(addonId: string, updateAddOnRequest: UpdateAddOnRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAddOn(addonId, updateAddOnRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddOnsApi - factory interface
 * @export
 */
export const AddOnsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddOnsApiFp(configuration)
    return {
        /**
         * Create an AddOn
         * @summary Create an AddOn
         * @param {CreateAddOnRequest} createAddOnRequest Payload to create addon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddOn(createAddOnRequest: CreateAddOnRequest, options?: any): AxiosPromise<AddOn> {
            return localVarFp.createAddOn(createAddOnRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Archive an addOn
         * @summary Delete an addon
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAddOn(addonId: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteAddOn(addonId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of an addon
         * @summary Get an addon
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddOn(addonId: string, options?: any): AxiosPromise<AddOn> {
            return localVarFp.getAddOn(addonId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of add-ons
         * @summary List addOns
         * @param {'ACTIVE' | 'ARCHIVED'} [status] Filter by status 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddOns(status?: 'ACTIVE' | 'ARCHIVED', nextToken?: string, pageSize?: number, options?: any): AxiosPromise<AddOnPaginatedResponse> {
            return localVarFp.getAddOns(status, nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing addon 
         * @summary Update an addon
         * @param {string} addonId 
         * @param {UpdateAddOnRequest} updateAddOnRequest Payload to update addon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAddOn(addonId: string, updateAddOnRequest: UpdateAddOnRequest, options?: any): AxiosPromise<AddOn> {
            return localVarFp.updateAddOn(addonId, updateAddOnRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddOnsApi - object-oriented interface
 * @export
 * @class AddOnsApi
 * @extends {BaseAPI}
 */
export class AddOnsApi extends BaseAPI {
    /**
     * Create an AddOn
     * @summary Create an AddOn
     * @param {CreateAddOnRequest} createAddOnRequest Payload to create addon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddOnsApi
     */
    public createAddOn(createAddOnRequest: CreateAddOnRequest, options?: AxiosRequestConfig) {
        return AddOnsApiFp(this.configuration).createAddOn(createAddOnRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archive an addOn
     * @summary Delete an addon
     * @param {string} addonId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddOnsApi
     */
    public deleteAddOn(addonId: string, options?: AxiosRequestConfig) {
        return AddOnsApiFp(this.configuration).deleteAddOn(addonId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of an addon
     * @summary Get an addon
     * @param {string} addonId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddOnsApi
     */
    public getAddOn(addonId: string, options?: AxiosRequestConfig) {
        return AddOnsApiFp(this.configuration).getAddOn(addonId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of add-ons
     * @summary List addOns
     * @param {'ACTIVE' | 'ARCHIVED'} [status] Filter by status 
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddOnsApi
     */
    public getAddOns(status?: 'ACTIVE' | 'ARCHIVED', nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return AddOnsApiFp(this.configuration).getAddOns(status, nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing addon 
     * @summary Update an addon
     * @param {string} addonId 
     * @param {UpdateAddOnRequest} updateAddOnRequest Payload to update addon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddOnsApi
     */
    public updateAddOn(addonId: string, updateAddOnRequest: UpdateAddOnRequest, options?: AxiosRequestConfig) {
        return AddOnsApiFp(this.configuration).updateAddOn(addonId, updateAddOnRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreditsApi - axios parameter creator
 * @export
 */
export const CreditsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Grant credit
         * @summary Grant credit
         * @param {CreateCreditRequest} [createCreditRequest] Payload to grant credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredit: async (createCreditRequest?: CreateCreditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/credits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCreditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Credit balance for Account
         * @summary Credit balance for Account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditBalanceForAccount: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('creditBalanceForAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/credit_balance`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get credit details
         * @summary Get credit details
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditDetails: async (creditId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'creditId' is not null or undefined
            assertParamExists('getCreditDetails', 'creditId', creditId)
            const localVarPath = `/credits/{credit_id}`
                .replace(`{${"credit_id"}}`, encodeURIComponent(String(creditId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all credits
         * @summary List credits
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [id] Filter option to filter based on credit id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredits: async (nextToken?: string, status?: string, accountId?: string, id?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/credits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Void credit
         * @summary Void credit
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidCredit: async (creditId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'creditId' is not null or undefined
            assertParamExists('voidCredit', 'creditId', creditId)
            const localVarPath = `/credits/{credit_id}/void`
                .replace(`{${"credit_id"}}`, encodeURIComponent(String(creditId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditsApi - functional programming interface
 * @export
 */
export const CreditsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditsApiAxiosParamCreator(configuration)
    return {
        /**
         * Grant credit
         * @summary Grant credit
         * @param {CreateCreditRequest} [createCreditRequest] Payload to grant credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCredit(createCreditRequest?: CreateCreditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCredit(createCreditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Credit balance for Account
         * @summary Credit balance for Account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditBalanceForAccount(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditBalanceForAccount(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get credit details
         * @summary Get credit details
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCreditDetails(creditId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCreditDetails(creditId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all credits
         * @summary List credits
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [id] Filter option to filter based on credit id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCredits(nextToken?: string, status?: string, accountId?: string, id?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCreditsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCredits(nextToken, status, accountId, id, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Void credit
         * @summary Void credit
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voidCredit(creditId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voidCredit(creditId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreditsApi - factory interface
 * @export
 */
export const CreditsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditsApiFp(configuration)
    return {
        /**
         * Grant credit
         * @summary Grant credit
         * @param {CreateCreditRequest} [createCreditRequest] Payload to grant credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredit(createCreditRequest?: CreateCreditRequest, options?: any): AxiosPromise<Credit> {
            return localVarFp.createCredit(createCreditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Credit balance for Account
         * @summary Credit balance for Account
         * @param {string} accountId account_id corresponding to an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditBalanceForAccount(accountId: string, options?: any): AxiosPromise<CreditBalanceResponse> {
            return localVarFp.creditBalanceForAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get credit details
         * @summary Get credit details
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditDetails(creditId: string, options?: any): AxiosPromise<CreditDetailsResponse> {
            return localVarFp.getCreditDetails(creditId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all credits
         * @summary List credits
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [id] Filter option to filter based on credit id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredits(nextToken?: string, status?: string, accountId?: string, id?: string, pageSize?: number, options?: any): AxiosPromise<ListCreditsResponse> {
            return localVarFp.listCredits(nextToken, status, accountId, id, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Void credit
         * @summary Void credit
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidCredit(creditId: string, options?: any): AxiosPromise<Credit> {
            return localVarFp.voidCredit(creditId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreditsApi - object-oriented interface
 * @export
 * @class CreditsApi
 * @extends {BaseAPI}
 */
export class CreditsApi extends BaseAPI {
    /**
     * Grant credit
     * @summary Grant credit
     * @param {CreateCreditRequest} [createCreditRequest] Payload to grant credits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public createCredit(createCreditRequest?: CreateCreditRequest, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).createCredit(createCreditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Credit balance for Account
     * @summary Credit balance for Account
     * @param {string} accountId account_id corresponding to an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditBalanceForAccount(accountId: string, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditBalanceForAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get credit details
     * @summary Get credit details
     * @param {string} creditId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public getCreditDetails(creditId: string, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).getCreditDetails(creditId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all credits
     * @summary List credits
     * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
     * @param {string} [status] Filter option to filter by status.
     * @param {string} [accountId] Filter option to filter based on account id.
     * @param {string} [id] Filter option to filter based on credit id.
     * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public listCredits(nextToken?: string, status?: string, accountId?: string, id?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).listCredits(nextToken, status, accountId, id, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Void credit
     * @summary Void credit
     * @param {string} creditId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public voidCredit(creditId: string, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).voidCredit(creditId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomersApi - axios parameter creator
 * @export
 */
export const CustomersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API let’s you to create customers and corresponding accounts.
         * @summary Create a customer
         * @param {CreateCustomerRequest} createCustomerRequest Payload to create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer: async (createCustomerRequest: CreateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCustomerRequest' is not null or undefined
            assertParamExists('createCustomer', 'createCustomerRequest', createCustomerRequest)
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to delete a customer using customer_id.
         * @summary Delete a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer: async (customerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('deleteCustomer', 'customerId', customerId)
            const localVarPath = `/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get customer information using customer_id.
         * @summary Get a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer: async (customerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getCustomer', 'customerId', customerId)
            const localVarPath = `/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of customers with pagination and sort.
         * @summary List customers
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers: async (nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to update a customer’s information using customer_id.
         * @summary Update a customer
         * @param {string} customerId 
         * @param {UpdateCustomerRequest} updateCustomerRequest Payload to update customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer: async (customerId: string, updateCustomerRequest: UpdateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('updateCustomer', 'customerId', customerId)
            // verify required parameter 'updateCustomerRequest' is not null or undefined
            assertParamExists('updateCustomer', 'updateCustomerRequest', updateCustomerRequest)
            const localVarPath = `/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomersApi - functional programming interface
 * @export
 */
export const CustomersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomersApiAxiosParamCreator(configuration)
    return {
        /**
         * This API let’s you to create customers and corresponding accounts.
         * @summary Create a customer
         * @param {CreateCustomerRequest} createCustomerRequest Payload to create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomer(createCustomerRequest: CreateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomer(createCustomerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to delete a customer using customer_id.
         * @summary Delete a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomer(customerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomer(customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get customer information using customer_id.
         * @summary Get a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomer(customerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomer(customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of customers with pagination and sort.
         * @summary List customers
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomers(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomers(nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to update a customer’s information using customer_id.
         * @summary Update a customer
         * @param {string} customerId 
         * @param {UpdateCustomerRequest} updateCustomerRequest Payload to update customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomer(customerId, updateCustomerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomersApi - factory interface
 * @export
 */
export const CustomersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomersApiFp(configuration)
    return {
        /**
         * This API let’s you to create customers and corresponding accounts.
         * @summary Create a customer
         * @param {CreateCustomerRequest} createCustomerRequest Payload to create customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(createCustomerRequest: CreateCustomerRequest, options?: any): AxiosPromise<CreateCustomerResponse> {
            return localVarFp.createCustomer(createCustomerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to delete a customer using customer_id.
         * @summary Delete a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(customerId: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteCustomer(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get customer information using customer_id.
         * @summary Get a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(customerId: string, options?: any): AxiosPromise<Customer> {
            return localVarFp.getCustomer(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of customers with pagination and sort.
         * @summary List customers
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers(nextToken?: string, pageSize?: number, options?: any): AxiosPromise<CustomerPaginatedResponse> {
            return localVarFp.getCustomers(nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to update a customer’s information using customer_id.
         * @summary Update a customer
         * @param {string} customerId 
         * @param {UpdateCustomerRequest} updateCustomerRequest Payload to update customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: any): AxiosPromise<Customer> {
            return localVarFp.updateCustomer(customerId, updateCustomerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */
export class CustomersApi extends BaseAPI {
    /**
     * This API let’s you to create customers and corresponding accounts.
     * @summary Create a customer
     * @param {CreateCustomerRequest} createCustomerRequest Payload to create customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public createCustomer(createCustomerRequest: CreateCustomerRequest, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).createCustomer(createCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to delete a customer using customer_id.
     * @summary Delete a customer
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public deleteCustomer(customerId: string, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).deleteCustomer(customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get customer information using customer_id.
     * @summary Get a customer
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomer(customerId: string, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getCustomer(customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of customers with pagination and sort.
     * @summary List customers
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomers(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getCustomers(nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to update a customer’s information using customer_id.
     * @summary Update a customer
     * @param {string} customerId 
     * @param {UpdateCustomerRequest} updateCustomerRequest Payload to update customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).updateCustomer(customerId, updateCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EntitlementsApi - axios parameter creator
 * @export
 */
export const EntitlementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API let’s you to get the feature credits balance
         * @summary Get Feature credits balance
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureCredits: async (accountId: string, featureId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getFeatureCredits', 'accountId', accountId)
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('getFeatureCredits', 'featureId', featureId)
            const localVarPath = `/accounts/{account_id}/features/{feature_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to ingest an event if a user is entitled to a feature
         * @summary Ingest event if a user is entitled to a feature
         * @param {IngestEventRequest} [ingestEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestEntitledEvent: async (ingestEventRequest?: IngestEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/entitled`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingestEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntitlementsApi - functional programming interface
 * @export
 */
export const EntitlementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntitlementsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API let’s you to get the feature credits balance
         * @summary Get Feature credits balance
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureCredits(accountId: string, featureId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFeatureCreditsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureCredits(accountId, featureId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to ingest an event if a user is entitled to a feature
         * @summary Ingest event if a user is entitled to a feature
         * @param {IngestEventRequest} [ingestEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingestEntitledEvent(ingestEventRequest?: IngestEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingestEntitledEvent(ingestEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EntitlementsApi - factory interface
 * @export
 */
export const EntitlementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntitlementsApiFp(configuration)
    return {
        /**
         * This API let’s you to get the feature credits balance
         * @summary Get Feature credits balance
         * @param {string} accountId account_id corresponding to an account
         * @param {string} featureId feature_id corresponding to a feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureCredits(accountId: string, featureId: string, options?: any): AxiosPromise<GetFeatureCreditsResponse> {
            return localVarFp.getFeatureCredits(accountId, featureId, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to ingest an event if a user is entitled to a feature
         * @summary Ingest event if a user is entitled to a feature
         * @param {IngestEventRequest} [ingestEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestEntitledEvent(ingestEventRequest?: IngestEventRequest, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.ingestEntitledEvent(ingestEventRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntitlementsApi - object-oriented interface
 * @export
 * @class EntitlementsApi
 * @extends {BaseAPI}
 */
export class EntitlementsApi extends BaseAPI {
    /**
     * This API let’s you to get the feature credits balance
     * @summary Get Feature credits balance
     * @param {string} accountId account_id corresponding to an account
     * @param {string} featureId feature_id corresponding to a feature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementsApi
     */
    public getFeatureCredits(accountId: string, featureId: string, options?: AxiosRequestConfig) {
        return EntitlementsApiFp(this.configuration).getFeatureCredits(accountId, featureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to ingest an event if a user is entitled to a feature
     * @summary Ingest event if a user is entitled to a feature
     * @param {IngestEventRequest} [ingestEventRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementsApi
     */
    public ingestEntitledEvent(ingestEventRequest?: IngestEventRequest, options?: AxiosRequestConfig) {
        return EntitlementsApiFp(this.configuration).ingestEntitledEvent(ingestEventRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventIngestionApi - axios parameter creator
 * @export
 */
export const EventIngestionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API let’s you to ingest events to your Togai account. Events ingested using this API will be processed via associated usage meters and further via associated price plans to generate final billable value to invoice the customer Read more about [Event Ingestion](https://docs.togai.com/docs/event-ingestion) 
         * @summary Ingest events to Togai
         * @param {IngestEventRequest} ingestEventRequest Request body to ingest events to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingest: async (ingestEventRequest: IngestEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ingestEventRequest' is not null or undefined
            assertParamExists('ingest', 'ingestEventRequest', ingestEventRequest)
            const localVarPath = `/ingest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingestEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to ingest events in batch upto 1000 events. Ingest large amounts of events up to 1000 in batches in an array using this API.
         * @summary Ingest events to Togai in batch
         * @param {IngestBatchEventRequest} ingestBatchEventRequest Request body to ingest events in batch to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestBatch: async (ingestBatchEventRequest: IngestBatchEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ingestBatchEventRequest' is not null or undefined
            assertParamExists('ingestBatch', 'ingestBatchEventRequest', ingestBatchEventRequest)
            const localVarPath = `/ingestBatch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingestBatchEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventIngestionApi - functional programming interface
 * @export
 */
export const EventIngestionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventIngestionApiAxiosParamCreator(configuration)
    return {
        /**
         * This API let’s you to ingest events to your Togai account. Events ingested using this API will be processed via associated usage meters and further via associated price plans to generate final billable value to invoice the customer Read more about [Event Ingestion](https://docs.togai.com/docs/event-ingestion) 
         * @summary Ingest events to Togai
         * @param {IngestEventRequest} ingestEventRequest Request body to ingest events to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingest(ingestEventRequest: IngestEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngestEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingest(ingestEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to ingest events in batch upto 1000 events. Ingest large amounts of events up to 1000 in batches in an array using this API.
         * @summary Ingest events to Togai in batch
         * @param {IngestBatchEventRequest} ingestBatchEventRequest Request body to ingest events in batch to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingestBatch(ingestBatchEventRequest: IngestBatchEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngestEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingestBatch(ingestBatchEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventIngestionApi - factory interface
 * @export
 */
export const EventIngestionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventIngestionApiFp(configuration)
    return {
        /**
         * This API let’s you to ingest events to your Togai account. Events ingested using this API will be processed via associated usage meters and further via associated price plans to generate final billable value to invoice the customer Read more about [Event Ingestion](https://docs.togai.com/docs/event-ingestion) 
         * @summary Ingest events to Togai
         * @param {IngestEventRequest} ingestEventRequest Request body to ingest events to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingest(ingestEventRequest: IngestEventRequest, options?: any): AxiosPromise<IngestEventResponse> {
            return localVarFp.ingest(ingestEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to ingest events in batch upto 1000 events. Ingest large amounts of events up to 1000 in batches in an array using this API.
         * @summary Ingest events to Togai in batch
         * @param {IngestBatchEventRequest} ingestBatchEventRequest Request body to ingest events in batch to Togai usage and billing management service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestBatch(ingestBatchEventRequest: IngestBatchEventRequest, options?: any): AxiosPromise<IngestEventResponse> {
            return localVarFp.ingestBatch(ingestBatchEventRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventIngestionApi - object-oriented interface
 * @export
 * @class EventIngestionApi
 * @extends {BaseAPI}
 */
export class EventIngestionApi extends BaseAPI {
    /**
     * This API let’s you to ingest events to your Togai account. Events ingested using this API will be processed via associated usage meters and further via associated price plans to generate final billable value to invoice the customer Read more about [Event Ingestion](https://docs.togai.com/docs/event-ingestion) 
     * @summary Ingest events to Togai
     * @param {IngestEventRequest} ingestEventRequest Request body to ingest events to Togai usage and billing management service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventIngestionApi
     */
    public ingest(ingestEventRequest: IngestEventRequest, options?: AxiosRequestConfig) {
        return EventIngestionApiFp(this.configuration).ingest(ingestEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to ingest events in batch upto 1000 events. Ingest large amounts of events up to 1000 in batches in an array using this API.
     * @summary Ingest events to Togai in batch
     * @param {IngestBatchEventRequest} ingestBatchEventRequest Request body to ingest events in batch to Togai usage and billing management service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventIngestionApi
     */
    public ingestBatch(ingestBatchEventRequest: IngestBatchEventRequest, options?: AxiosRequestConfig) {
        return EventIngestionApiFp(this.configuration).ingestBatch(ingestBatchEventRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventManagementApi - axios parameter creator
 * @export
 */
export const EventManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API let’s you to fetch a list of events with multiple query parameters
         * @summary Get a list of usage events with multiple query options
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [schemaName] Filter option to filter the events based on schema name.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (nextToken?: string, status?: string, accountId?: string, schemaName?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (schemaName !== undefined) {
                localVarQueryParameter['schema_name'] = schemaName;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch details of a particular event using the event ID.
         * @summary Get an usage event using event id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleEvent: async (eventId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getSingleEvent', 'eventId', eventId)
            const localVarPath = `/events/{event_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventManagementApi - functional programming interface
 * @export
 */
export const EventManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * This API let’s you to fetch a list of events with multiple query parameters
         * @summary Get a list of usage events with multiple query options
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [schemaName] Filter option to filter the events based on schema name.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(nextToken?: string, status?: string, accountId?: string, schemaName?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(nextToken, status, accountId, schemaName, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch details of a particular event using the event ID.
         * @summary Get an usage event using event id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleEvent(eventId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleEvent(eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventManagementApi - factory interface
 * @export
 */
export const EventManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventManagementApiFp(configuration)
    return {
        /**
         * This API let’s you to fetch a list of events with multiple query parameters
         * @summary Get a list of usage events with multiple query options
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [schemaName] Filter option to filter the events based on schema name.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(nextToken?: string, status?: string, accountId?: string, schemaName?: string, pageSize?: number, options?: any): AxiosPromise<GetEventsResponse> {
            return localVarFp.getEvents(nextToken, status, accountId, schemaName, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch details of a particular event using the event ID.
         * @summary Get an usage event using event id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleEvent(eventId: string, options?: any): AxiosPromise<GetEventResponse> {
            return localVarFp.getSingleEvent(eventId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventManagementApi - object-oriented interface
 * @export
 * @class EventManagementApi
 * @extends {BaseAPI}
 */
export class EventManagementApi extends BaseAPI {
    /**
     * This API let’s you to fetch a list of events with multiple query parameters
     * @summary Get a list of usage events with multiple query options
     * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
     * @param {string} [status] Filter option to filter by status.
     * @param {string} [accountId] Filter option to filter based on account id.
     * @param {string} [schemaName] Filter option to filter the events based on schema name.
     * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventManagementApi
     */
    public getEvents(nextToken?: string, status?: string, accountId?: string, schemaName?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return EventManagementApiFp(this.configuration).getEvents(nextToken, status, accountId, schemaName, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch details of a particular event using the event ID.
     * @summary Get an usage event using event id
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventManagementApi
     */
    public getSingleEvent(eventId: string, options?: AxiosRequestConfig) {
        return EventManagementApiFp(this.configuration).getSingleEvent(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventSchemasApi - axios parameter creator
 * @export
 */
export const EventSchemasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate an event schema
         * @summary Activate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateEventSchema: async (eventSchemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('activateEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}/activate`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an event schema with attributes and dimensions to process events.
         * @summary Create an event schema
         * @param {CreateEventSchemaRequest} createEventSchemaRequest Payload to create event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSchema: async (createEventSchemaRequest: CreateEventSchemaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEventSchemaRequest' is not null or undefined
            assertParamExists('createEventSchema', 'createEventSchemaRequest', createEventSchemaRequest)
            const localVarPath = `/event_schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventSchemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can deactivate an event schema using this API. In case you have an activate usage meter associated with the event schema, you will need to deactivate it first and then try deactivating the event schema. 
         * @summary Deactivate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateEventSchema: async (eventSchemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('deactivateEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}/deactivate`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To delete(archive) an event schema, you’re required to archive associated active usage meters if any.
         * @summary Delete an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventSchema: async (eventSchemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('deleteEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an event schema and add new attributes and dimensions  Once an event schema is activated, you cannot update or delete existing attributes and dimensions however you can add new attributes and dimensions and update event schema description.     operationId: updateEventSchema 
         * @summary Update an event schema
         * @param {string} eventSchemaName 
         * @param {UpdateEventSchemaRequest} updateEventSchemaRequest Payload to update event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventSchemaEventSchemaNamePatch: async (eventSchemaName: string, updateEventSchemaRequest: UpdateEventSchemaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('eventSchemaEventSchemaNamePatch', 'eventSchemaName', eventSchemaName)
            // verify required parameter 'updateEventSchemaRequest' is not null or undefined
            assertParamExists('eventSchemaEventSchemaNamePatch', 'updateEventSchemaRequest', updateEventSchemaRequest)
            const localVarPath = `/event_schema/{event_schema_name}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventSchemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an event schema
         * @summary Get an event schema
         * @param {string} eventSchemaName 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSchema: async (eventSchemaName: string, version?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('getEventSchema', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all the versions of an event schema
         * @summary List all event schema versions
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventSchemaVersions: async (eventSchemaName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSchemaName' is not null or undefined
            assertParamExists('listEventSchemaVersions', 'eventSchemaName', eventSchemaName)
            const localVarPath = `/event_schema/{event_schema_name}/versions`
                .replace(`{${"event_schema_name"}}`, encodeURIComponent(String(eventSchemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of event schema with pagination.
         * @summary List event schemas
         * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by provided status
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventSchemas: async (status?: 'ACTIVE' | 'INACTIVE', nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event_schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventSchemasApi - functional programming interface
 * @export
 */
export const EventSchemasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventSchemasApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate an event schema
         * @summary Activate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateEventSchema(eventSchemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateEventSchema(eventSchemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an event schema with attributes and dimensions to process events.
         * @summary Create an event schema
         * @param {CreateEventSchemaRequest} createEventSchemaRequest Payload to create event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventSchema(createEventSchemaRequest: CreateEventSchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventSchema(createEventSchemaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can deactivate an event schema using this API. In case you have an activate usage meter associated with the event schema, you will need to deactivate it first and then try deactivating the event schema. 
         * @summary Deactivate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateEventSchema(eventSchemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateEventSchema(eventSchemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To delete(archive) an event schema, you’re required to archive associated active usage meters if any.
         * @summary Delete an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventSchema(eventSchemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventSchema(eventSchemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an event schema and add new attributes and dimensions  Once an event schema is activated, you cannot update or delete existing attributes and dimensions however you can add new attributes and dimensions and update event schema description.     operationId: updateEventSchema 
         * @summary Update an event schema
         * @param {string} eventSchemaName 
         * @param {UpdateEventSchemaRequest} updateEventSchemaRequest Payload to update event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventSchemaEventSchemaNamePatch(eventSchemaName: string, updateEventSchemaRequest: UpdateEventSchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventSchemaEventSchemaNamePatch(eventSchemaName, updateEventSchemaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an event schema
         * @summary Get an event schema
         * @param {string} eventSchemaName 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventSchema(eventSchemaName: string, version?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventSchema(eventSchemaName, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all the versions of an event schema
         * @summary List all event schema versions
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventSchemaVersions(eventSchemaName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchemaVersionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventSchemaVersions(eventSchemaName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of event schema with pagination.
         * @summary List event schemas
         * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by provided status
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventSchemas(status?: 'ACTIVE' | 'INACTIVE', nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchemaListPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventSchemas(status, nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventSchemasApi - factory interface
 * @export
 */
export const EventSchemasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventSchemasApiFp(configuration)
    return {
        /**
         * Activate an event schema
         * @summary Activate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateEventSchema(eventSchemaName: string, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.activateEventSchema(eventSchemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an event schema with attributes and dimensions to process events.
         * @summary Create an event schema
         * @param {CreateEventSchemaRequest} createEventSchemaRequest Payload to create event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSchema(createEventSchemaRequest: CreateEventSchemaRequest, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.createEventSchema(createEventSchemaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * You can deactivate an event schema using this API. In case you have an activate usage meter associated with the event schema, you will need to deactivate it first and then try deactivating the event schema. 
         * @summary Deactivate an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateEventSchema(eventSchemaName: string, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.deactivateEventSchema(eventSchemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * To delete(archive) an event schema, you’re required to archive associated active usage meters if any.
         * @summary Delete an event schema
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventSchema(eventSchemaName: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteEventSchema(eventSchemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an event schema and add new attributes and dimensions  Once an event schema is activated, you cannot update or delete existing attributes and dimensions however you can add new attributes and dimensions and update event schema description.     operationId: updateEventSchema 
         * @summary Update an event schema
         * @param {string} eventSchemaName 
         * @param {UpdateEventSchemaRequest} updateEventSchemaRequest Payload to update event schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventSchemaEventSchemaNamePatch(eventSchemaName: string, updateEventSchemaRequest: UpdateEventSchemaRequest, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.eventSchemaEventSchemaNamePatch(eventSchemaName, updateEventSchemaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an event schema
         * @summary Get an event schema
         * @param {string} eventSchemaName 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSchema(eventSchemaName: string, version?: number, options?: any): AxiosPromise<EventSchema> {
            return localVarFp.getEventSchema(eventSchemaName, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all the versions of an event schema
         * @summary List all event schema versions
         * @param {string} eventSchemaName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventSchemaVersions(eventSchemaName: string, options?: any): AxiosPromise<EventSchemaVersionsResponse> {
            return localVarFp.listEventSchemaVersions(eventSchemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of event schema with pagination.
         * @summary List event schemas
         * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by provided status
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventSchemas(status?: 'ACTIVE' | 'INACTIVE', nextToken?: string, pageSize?: number, options?: any): AxiosPromise<EventSchemaListPaginatedResponse> {
            return localVarFp.listEventSchemas(status, nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventSchemasApi - object-oriented interface
 * @export
 * @class EventSchemasApi
 * @extends {BaseAPI}
 */
export class EventSchemasApi extends BaseAPI {
    /**
     * Activate an event schema
     * @summary Activate an event schema
     * @param {string} eventSchemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public activateEventSchema(eventSchemaName: string, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).activateEventSchema(eventSchemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an event schema with attributes and dimensions to process events.
     * @summary Create an event schema
     * @param {CreateEventSchemaRequest} createEventSchemaRequest Payload to create event schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public createEventSchema(createEventSchemaRequest: CreateEventSchemaRequest, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).createEventSchema(createEventSchemaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can deactivate an event schema using this API. In case you have an activate usage meter associated with the event schema, you will need to deactivate it first and then try deactivating the event schema. 
     * @summary Deactivate an event schema
     * @param {string} eventSchemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public deactivateEventSchema(eventSchemaName: string, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).deactivateEventSchema(eventSchemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To delete(archive) an event schema, you’re required to archive associated active usage meters if any.
     * @summary Delete an event schema
     * @param {string} eventSchemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public deleteEventSchema(eventSchemaName: string, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).deleteEventSchema(eventSchemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an event schema and add new attributes and dimensions  Once an event schema is activated, you cannot update or delete existing attributes and dimensions however you can add new attributes and dimensions and update event schema description.     operationId: updateEventSchema 
     * @summary Update an event schema
     * @param {string} eventSchemaName 
     * @param {UpdateEventSchemaRequest} updateEventSchemaRequest Payload to update event schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public eventSchemaEventSchemaNamePatch(eventSchemaName: string, updateEventSchemaRequest: UpdateEventSchemaRequest, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).eventSchemaEventSchemaNamePatch(eventSchemaName, updateEventSchemaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an event schema
     * @summary Get an event schema
     * @param {string} eventSchemaName 
     * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public getEventSchema(eventSchemaName: string, version?: number, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).getEventSchema(eventSchemaName, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all the versions of an event schema
     * @summary List all event schema versions
     * @param {string} eventSchemaName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public listEventSchemaVersions(eventSchemaName: string, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).listEventSchemaVersions(eventSchemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of event schema with pagination.
     * @summary List event schemas
     * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by provided status
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSchemasApi
     */
    public listEventSchemas(status?: 'ACTIVE' | 'INACTIVE', nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return EventSchemasApiFp(this.configuration).listEventSchemas(status, nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FeatureApi - axios parameter creator
 * @export
 */
export const FeatureApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Feature optionally associate with one or more event_schemas
         * @summary Create a Feature and optionally associate with one or more event_schemas
         * @param {CreateFeatureRequest} createFeatureRequest Payload to create a Feature along the association with event_schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeature: async (createFeatureRequest: CreateFeatureRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFeatureRequest' is not null or undefined
            assertParamExists('createFeature', 'createFeatureRequest', createFeatureRequest)
            const localVarPath = `/features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFeatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a Feature
         * @summary Get a Feature
         * @param {string} featureId feature_id corresponding to a feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeature: async (featureId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('getFeature', 'featureId', featureId)
            const localVarPath = `/features/{feature_id}`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of features along with its associations
         * @summary List Feature
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatures: async (nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing feature and its eventSchema associations 
         * @summary Update a Feature
         * @param {string} featureId feature_id corresponding to a feature
         * @param {UpdateFeatureRequest} updateFeatureRequest Payload to update a Feature along the associations with event_schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeature: async (featureId: string, updateFeatureRequest: UpdateFeatureRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('updateFeature', 'featureId', featureId)
            // verify required parameter 'updateFeatureRequest' is not null or undefined
            assertParamExists('updateFeature', 'updateFeatureRequest', updateFeatureRequest)
            const localVarPath = `/features/{feature_id}`
                .replace(`{${"feature_id"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFeatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeatureApi - functional programming interface
 * @export
 */
export const FeatureApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeatureApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a Feature optionally associate with one or more event_schemas
         * @summary Create a Feature and optionally associate with one or more event_schemas
         * @param {CreateFeatureRequest} createFeatureRequest Payload to create a Feature along the association with event_schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeature(createFeatureRequest: CreateFeatureRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Feature>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFeature(createFeatureRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a Feature
         * @summary Get a Feature
         * @param {string} featureId feature_id corresponding to a feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeature(featureId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Feature>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeature(featureId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of features along with its associations
         * @summary List Feature
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatures(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeaturePaginatedListData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatures(nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing feature and its eventSchema associations 
         * @summary Update a Feature
         * @param {string} featureId feature_id corresponding to a feature
         * @param {UpdateFeatureRequest} updateFeatureRequest Payload to update a Feature along the associations with event_schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeature(featureId: string, updateFeatureRequest: UpdateFeatureRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Feature>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeature(featureId, updateFeatureRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FeatureApi - factory interface
 * @export
 */
export const FeatureApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeatureApiFp(configuration)
    return {
        /**
         * Create a Feature optionally associate with one or more event_schemas
         * @summary Create a Feature and optionally associate with one or more event_schemas
         * @param {CreateFeatureRequest} createFeatureRequest Payload to create a Feature along the association with event_schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeature(createFeatureRequest: CreateFeatureRequest, options?: any): AxiosPromise<Feature> {
            return localVarFp.createFeature(createFeatureRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a Feature
         * @summary Get a Feature
         * @param {string} featureId feature_id corresponding to a feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeature(featureId: string, options?: any): AxiosPromise<Feature> {
            return localVarFp.getFeature(featureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of features along with its associations
         * @summary List Feature
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatures(nextToken?: string, pageSize?: number, options?: any): AxiosPromise<FeaturePaginatedListData> {
            return localVarFp.getFeatures(nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing feature and its eventSchema associations 
         * @summary Update a Feature
         * @param {string} featureId feature_id corresponding to a feature
         * @param {UpdateFeatureRequest} updateFeatureRequest Payload to update a Feature along the associations with event_schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeature(featureId: string, updateFeatureRequest: UpdateFeatureRequest, options?: any): AxiosPromise<Feature> {
            return localVarFp.updateFeature(featureId, updateFeatureRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeatureApi - object-oriented interface
 * @export
 * @class FeatureApi
 * @extends {BaseAPI}
 */
export class FeatureApi extends BaseAPI {
    /**
     * Create a Feature optionally associate with one or more event_schemas
     * @summary Create a Feature and optionally associate with one or more event_schemas
     * @param {CreateFeatureRequest} createFeatureRequest Payload to create a Feature along the association with event_schemas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public createFeature(createFeatureRequest: CreateFeatureRequest, options?: AxiosRequestConfig) {
        return FeatureApiFp(this.configuration).createFeature(createFeatureRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a Feature
     * @summary Get a Feature
     * @param {string} featureId feature_id corresponding to a feature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public getFeature(featureId: string, options?: AxiosRequestConfig) {
        return FeatureApiFp(this.configuration).getFeature(featureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of features along with its associations
     * @summary List Feature
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public getFeatures(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return FeatureApiFp(this.configuration).getFeatures(nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing feature and its eventSchema associations 
     * @summary Update a Feature
     * @param {string} featureId feature_id corresponding to a feature
     * @param {UpdateFeatureRequest} updateFeatureRequest Payload to update a Feature along the associations with event_schemas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public updateFeature(featureId: string, updateFeatureRequest: UpdateFeatureRequest, options?: AxiosRequestConfig) {
        return FeatureApiFp(this.configuration).updateFeature(featureId, updateFeatureRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvoicesApi - axios parameter creator
 * @export
 */
export const InvoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get invoice
         * @summary Get an invoice
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice: async (invoiceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('getInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/invoices/{invoice_id}`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update payment status in Invoice
         * @summary Update payment status in Invoice
         * @param {string} invoiceId 
         * @param {InvoicePaymentsRequest} invoicePaymentsRequest Payload to update payments of invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicePayments: async (invoiceId: string, invoicePaymentsRequest: InvoicePaymentsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('invoicePayments', 'invoiceId', invoiceId)
            // verify required parameter 'invoicePaymentsRequest' is not null or undefined
            assertParamExists('invoicePayments', 'invoicePaymentsRequest', invoicePaymentsRequest)
            const localVarPath = `/invoices/{invoice_id}/payments`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoicePaymentsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List invoices
         * @summary List invoices
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [customerId] Filter option to filter based on customer id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {number} [startTime] Start time filter in epoch milli seconds
         * @param {number} [endTime] End time filter in epoch milli seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvoices: async (nextToken?: string, status?: string, accountId?: string, customerId?: string, pageSize?: number, startTime?: number, endTime?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customer_id'] = customerId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add or update miscellaneous charges in upcoming Invoice for a account
         * @summary Add or update miscellaneous charges in upcoming Invoice for a account
         * @param {string} accountId account_id corresponding to an account
         * @param {ManageMiscellaneousChargesRequest} [manageMiscellaneousChargesRequest] Payload to update custom line items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageMiscellaneousChargesInAccount: async (accountId: string, manageMiscellaneousChargesRequest?: ManageMiscellaneousChargesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('manageMiscellaneousChargesInAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/miscellaneous_charges`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manageMiscellaneousChargesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add or update miscellaneous charges in Invoice
         * @summary Add or update miscellaneous charges in Invoice
         * @param {string} invoiceId 
         * @param {ManageMiscellaneousChargesRequest} [manageMiscellaneousChargesRequest] Payload to update custom line items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageMiscellaneousChargesInInvoice: async (invoiceId: string, manageMiscellaneousChargesRequest?: ManageMiscellaneousChargesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('manageMiscellaneousChargesInInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/invoices/{invoice_id}/miscellaneous_charges`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manageMiscellaneousChargesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicesApi - functional programming interface
 * @export
 */
export const InvoicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoicesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get invoice
         * @summary Get an invoice
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoice(invoiceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoice(invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update payment status in Invoice
         * @summary Update payment status in Invoice
         * @param {string} invoiceId 
         * @param {InvoicePaymentsRequest} invoicePaymentsRequest Payload to update payments of invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invoicePayments(invoiceId: string, invoicePaymentsRequest: InvoicePaymentsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invoicePayments(invoiceId, invoicePaymentsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List invoices
         * @summary List invoices
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [customerId] Filter option to filter based on customer id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {number} [startTime] Start time filter in epoch milli seconds
         * @param {number} [endTime] End time filter in epoch milli seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInvoices(nextToken?: string, status?: string, accountId?: string, customerId?: string, pageSize?: number, startTime?: number, endTime?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListInvoicesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInvoices(nextToken, status, accountId, customerId, pageSize, startTime, endTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add or update miscellaneous charges in upcoming Invoice for a account
         * @summary Add or update miscellaneous charges in upcoming Invoice for a account
         * @param {string} accountId account_id corresponding to an account
         * @param {ManageMiscellaneousChargesRequest} [manageMiscellaneousChargesRequest] Payload to update custom line items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async manageMiscellaneousChargesInAccount(accountId: string, manageMiscellaneousChargesRequest?: ManageMiscellaneousChargesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiscellaneousChargesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.manageMiscellaneousChargesInAccount(accountId, manageMiscellaneousChargesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add or update miscellaneous charges in Invoice
         * @summary Add or update miscellaneous charges in Invoice
         * @param {string} invoiceId 
         * @param {ManageMiscellaneousChargesRequest} [manageMiscellaneousChargesRequest] Payload to update custom line items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async manageMiscellaneousChargesInInvoice(invoiceId: string, manageMiscellaneousChargesRequest?: ManageMiscellaneousChargesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiscellaneousChargesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.manageMiscellaneousChargesInInvoice(invoiceId, manageMiscellaneousChargesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvoicesApi - factory interface
 * @export
 */
export const InvoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoicesApiFp(configuration)
    return {
        /**
         * Get invoice
         * @summary Get an invoice
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice(invoiceId: string, options?: any): AxiosPromise<Invoice> {
            return localVarFp.getInvoice(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update payment status in Invoice
         * @summary Update payment status in Invoice
         * @param {string} invoiceId 
         * @param {InvoicePaymentsRequest} invoicePaymentsRequest Payload to update payments of invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicePayments(invoiceId: string, invoicePaymentsRequest: InvoicePaymentsRequest, options?: any): AxiosPromise<Invoice> {
            return localVarFp.invoicePayments(invoiceId, invoicePaymentsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List invoices
         * @summary List invoices
         * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
         * @param {string} [status] Filter option to filter by status.
         * @param {string} [accountId] Filter option to filter based on account id.
         * @param {string} [customerId] Filter option to filter based on customer id.
         * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
         * @param {number} [startTime] Start time filter in epoch milli seconds
         * @param {number} [endTime] End time filter in epoch milli seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvoices(nextToken?: string, status?: string, accountId?: string, customerId?: string, pageSize?: number, startTime?: number, endTime?: number, options?: any): AxiosPromise<ListInvoicesResponse> {
            return localVarFp.listInvoices(nextToken, status, accountId, customerId, pageSize, startTime, endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Add or update miscellaneous charges in upcoming Invoice for a account
         * @summary Add or update miscellaneous charges in upcoming Invoice for a account
         * @param {string} accountId account_id corresponding to an account
         * @param {ManageMiscellaneousChargesRequest} [manageMiscellaneousChargesRequest] Payload to update custom line items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageMiscellaneousChargesInAccount(accountId: string, manageMiscellaneousChargesRequest?: ManageMiscellaneousChargesRequest, options?: any): AxiosPromise<MiscellaneousChargesResponse> {
            return localVarFp.manageMiscellaneousChargesInAccount(accountId, manageMiscellaneousChargesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add or update miscellaneous charges in Invoice
         * @summary Add or update miscellaneous charges in Invoice
         * @param {string} invoiceId 
         * @param {ManageMiscellaneousChargesRequest} [manageMiscellaneousChargesRequest] Payload to update custom line items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageMiscellaneousChargesInInvoice(invoiceId: string, manageMiscellaneousChargesRequest?: ManageMiscellaneousChargesRequest, options?: any): AxiosPromise<MiscellaneousChargesResponse> {
            return localVarFp.manageMiscellaneousChargesInInvoice(invoiceId, manageMiscellaneousChargesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
export class InvoicesApi extends BaseAPI {
    /**
     * Get invoice
     * @summary Get an invoice
     * @param {string} invoiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public getInvoice(invoiceId: string, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).getInvoice(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update payment status in Invoice
     * @summary Update payment status in Invoice
     * @param {string} invoiceId 
     * @param {InvoicePaymentsRequest} invoicePaymentsRequest Payload to update payments of invoice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public invoicePayments(invoiceId: string, invoicePaymentsRequest: InvoicePaymentsRequest, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).invoicePayments(invoiceId, invoicePaymentsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List invoices
     * @summary List invoices
     * @param {string} [nextToken] Pagination token used as a marker to get records from next page.
     * @param {string} [status] Filter option to filter by status.
     * @param {string} [accountId] Filter option to filter based on account id.
     * @param {string} [customerId] Filter option to filter based on customer id.
     * @param {number} [pageSize] Maximum page size expected by client to return the record list.    NOTE: Max page size cannot be more than 50. Also 50 is the default page size if no value is provided.
     * @param {number} [startTime] Start time filter in epoch milli seconds
     * @param {number} [endTime] End time filter in epoch milli seconds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public listInvoices(nextToken?: string, status?: string, accountId?: string, customerId?: string, pageSize?: number, startTime?: number, endTime?: number, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).listInvoices(nextToken, status, accountId, customerId, pageSize, startTime, endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add or update miscellaneous charges in upcoming Invoice for a account
     * @summary Add or update miscellaneous charges in upcoming Invoice for a account
     * @param {string} accountId account_id corresponding to an account
     * @param {ManageMiscellaneousChargesRequest} [manageMiscellaneousChargesRequest] Payload to update custom line items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public manageMiscellaneousChargesInAccount(accountId: string, manageMiscellaneousChargesRequest?: ManageMiscellaneousChargesRequest, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).manageMiscellaneousChargesInAccount(accountId, manageMiscellaneousChargesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add or update miscellaneous charges in Invoice
     * @summary Add or update miscellaneous charges in Invoice
     * @param {string} invoiceId 
     * @param {ManageMiscellaneousChargesRequest} [manageMiscellaneousChargesRequest] Payload to update custom line items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public manageMiscellaneousChargesInInvoice(invoiceId: string, manageMiscellaneousChargesRequest?: ManageMiscellaneousChargesRequest, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).manageMiscellaneousChargesInInvoice(invoiceId, manageMiscellaneousChargesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LicensesApi - axios parameter creator
 * @export
 */
export const LicensesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API let’s you to add a license entry
         * @summary Update a license entry
         * @param {LicenseUpdateRequest} [licenseUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLicenseUpdateEntry: async (licenseUpdateRequest?: LicenseUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/license_updates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(licenseUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let’s you to fetch a list of licenses updates with multiple query parameters
         * @summary Get a list of licenses updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseUpdates: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/license_updates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LicensesApi - functional programming interface
 * @export
 */
export const LicensesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LicensesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API let’s you to add a license entry
         * @summary Update a license entry
         * @param {LicenseUpdateRequest} [licenseUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addLicenseUpdateEntry(licenseUpdateRequest?: LicenseUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicenseUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addLicenseUpdateEntry(licenseUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let’s you to fetch a list of licenses updates with multiple query parameters
         * @summary Get a list of licenses updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicenseUpdates(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLicenseUpdatesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicenseUpdates(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LicensesApi - factory interface
 * @export
 */
export const LicensesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LicensesApiFp(configuration)
    return {
        /**
         * This API let’s you to add a license entry
         * @summary Update a license entry
         * @param {LicenseUpdateRequest} [licenseUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLicenseUpdateEntry(licenseUpdateRequest?: LicenseUpdateRequest, options?: any): AxiosPromise<LicenseUpdateResponse> {
            return localVarFp.addLicenseUpdateEntry(licenseUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let’s you to fetch a list of licenses updates with multiple query parameters
         * @summary Get a list of licenses updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseUpdates(options?: any): AxiosPromise<GetLicenseUpdatesResponse> {
            return localVarFp.getLicenseUpdates(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LicensesApi - object-oriented interface
 * @export
 * @class LicensesApi
 * @extends {BaseAPI}
 */
export class LicensesApi extends BaseAPI {
    /**
     * This API let’s you to add a license entry
     * @summary Update a license entry
     * @param {LicenseUpdateRequest} [licenseUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicensesApi
     */
    public addLicenseUpdateEntry(licenseUpdateRequest?: LicenseUpdateRequest, options?: AxiosRequestConfig) {
        return LicensesApiFp(this.configuration).addLicenseUpdateEntry(licenseUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let’s you to fetch a list of licenses updates with multiple query parameters
     * @summary Get a list of licenses updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicensesApi
     */
    public getLicenseUpdates(options?: AxiosRequestConfig) {
        return LicensesApiFp(this.configuration).getLicenseUpdates(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Togai Metrics API allows you to fetch different metrics from Events, Usage Meters and PricePlans with multiple queryable options. A single request can query up to five metrics.  Single response can contain a maximum of 100 data points. 
         * @summary Get Togai Metrics
         * @param {GetMetricsRequest} [getMetricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics: async (getMetricsRequest?: GetMetricsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getMetricsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * Togai Metrics API allows you to fetch different metrics from Events, Usage Meters and PricePlans with multiple queryable options. A single request can query up to five metrics.  Single response can contain a maximum of 100 data points. 
         * @summary Get Togai Metrics
         * @param {GetMetricsRequest} [getMetricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetrics(getMetricsRequest?: GetMetricsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetrics(getMetricsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * Togai Metrics API allows you to fetch different metrics from Events, Usage Meters and PricePlans with multiple queryable options. A single request can query up to five metrics.  Single response can contain a maximum of 100 data points. 
         * @summary Get Togai Metrics
         * @param {GetMetricsRequest} [getMetricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(getMetricsRequest?: GetMetricsRequest, options?: any): AxiosPromise<GetMetricsResponse> {
            return localVarFp.getMetrics(getMetricsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * Togai Metrics API allows you to fetch different metrics from Events, Usage Meters and PricePlans with multiple queryable options. A single request can query up to five metrics.  Single response can contain a maximum of 100 data points. 
     * @summary Get Togai Metrics
     * @param {GetMetricsRequest} [getMetricsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetrics(getMetricsRequest?: GetMetricsRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getMetrics(getMetricsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MigrationsApi - axios parameter creator
 * @export
 */
export const MigrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the status of a migration
         * @summary Get the status of a migration
         * @param {string} migrationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMigrationStatus: async (migrationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'migrationId' is not null or undefined
            assertParamExists('getMigrationStatus', 'migrationId', migrationId)
            const localVarPath = `/migrations/{migration_id}`
                .replace(`{${"migration_id"}}`, encodeURIComponent(String(migrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of migrations with pagination and sort.
         * @summary List migrations
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMigrations: async (nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/migrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Migrates accounts which are associated to one price plan to another price plan
         * @summary Migrates accounts which are associated to one price plan to another price plan
         * @param {CreatePricePlanMigrationRequest} createPricePlanMigrationRequest Payload to update organization setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        migratePricePlan: async (createPricePlanMigrationRequest: CreatePricePlanMigrationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPricePlanMigrationRequest' is not null or undefined
            assertParamExists('migratePricePlan', 'createPricePlanMigrationRequest', createPricePlanMigrationRequest)
            const localVarPath = `/migrations/price_plan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPricePlanMigrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MigrationsApi - functional programming interface
 * @export
 */
export const MigrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MigrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the status of a migration
         * @summary Get the status of a migration
         * @param {string} migrationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMigrationStatus(migrationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMigrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMigrationStatus(migrationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of migrations with pagination and sort.
         * @summary List migrations
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMigrations(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MigrationsPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMigrations(nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Migrates accounts which are associated to one price plan to another price plan
         * @summary Migrates accounts which are associated to one price plan to another price plan
         * @param {CreatePricePlanMigrationRequest} createPricePlanMigrationRequest Payload to update organization setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async migratePricePlan(createPricePlanMigrationRequest: CreatePricePlanMigrationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.migratePricePlan(createPricePlanMigrationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MigrationsApi - factory interface
 * @export
 */
export const MigrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MigrationsApiFp(configuration)
    return {
        /**
         * Get the status of a migration
         * @summary Get the status of a migration
         * @param {string} migrationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMigrationStatus(migrationId: string, options?: any): AxiosPromise<GetMigrationResponse> {
            return localVarFp.getMigrationStatus(migrationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of migrations with pagination and sort.
         * @summary List migrations
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMigrations(nextToken?: string, pageSize?: number, options?: any): AxiosPromise<MigrationsPaginatedResponse> {
            return localVarFp.getMigrations(nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Migrates accounts which are associated to one price plan to another price plan
         * @summary Migrates accounts which are associated to one price plan to another price plan
         * @param {CreatePricePlanMigrationRequest} createPricePlanMigrationRequest Payload to update organization setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        migratePricePlan(createPricePlanMigrationRequest: CreatePricePlanMigrationRequest, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.migratePricePlan(createPricePlanMigrationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MigrationsApi - object-oriented interface
 * @export
 * @class MigrationsApi
 * @extends {BaseAPI}
 */
export class MigrationsApi extends BaseAPI {
    /**
     * Get the status of a migration
     * @summary Get the status of a migration
     * @param {string} migrationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationsApi
     */
    public getMigrationStatus(migrationId: string, options?: AxiosRequestConfig) {
        return MigrationsApiFp(this.configuration).getMigrationStatus(migrationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of migrations with pagination and sort.
     * @summary List migrations
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationsApi
     */
    public getMigrations(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return MigrationsApiFp(this.configuration).getMigrations(nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Migrates accounts which are associated to one price plan to another price plan
     * @summary Migrates accounts which are associated to one price plan to another price plan
     * @param {CreatePricePlanMigrationRequest} createPricePlanMigrationRequest Payload to update organization setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationsApi
     */
    public migratePricePlan(createPricePlanMigrationRequest: CreatePricePlanMigrationRequest, options?: AxiosRequestConfig) {
        return MigrationsApiFp(this.configuration).migratePricePlan(createPricePlanMigrationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PriceExperimentationApi - axios parameter creator
 * @export
 */
export const PriceExperimentationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calculate and return the revenue for a existing or new price plan
         * @summary Calculate and return the revenue for a existing or new price plan
         * @param {CalculateRevenueRequest} calculateRevenueRequest Request payload for calculateRevenueAPI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateRevenue: async (calculateRevenueRequest: CalculateRevenueRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'calculateRevenueRequest' is not null or undefined
            assertParamExists('calculateRevenue', 'calculateRevenueRequest', calculateRevenueRequest)
            const localVarPath = `/revenue_calculator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(calculateRevenueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PriceExperimentationApi - functional programming interface
 * @export
 */
export const PriceExperimentationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PriceExperimentationApiAxiosParamCreator(configuration)
    return {
        /**
         * Calculate and return the revenue for a existing or new price plan
         * @summary Calculate and return the revenue for a existing or new price plan
         * @param {CalculateRevenueRequest} calculateRevenueRequest Request payload for calculateRevenueAPI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calculateRevenue(calculateRevenueRequest: CalculateRevenueRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CalculateRevenueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calculateRevenue(calculateRevenueRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PriceExperimentationApi - factory interface
 * @export
 */
export const PriceExperimentationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PriceExperimentationApiFp(configuration)
    return {
        /**
         * Calculate and return the revenue for a existing or new price plan
         * @summary Calculate and return the revenue for a existing or new price plan
         * @param {CalculateRevenueRequest} calculateRevenueRequest Request payload for calculateRevenueAPI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateRevenue(calculateRevenueRequest: CalculateRevenueRequest, options?: any): AxiosPromise<CalculateRevenueResponse> {
            return localVarFp.calculateRevenue(calculateRevenueRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PriceExperimentationApi - object-oriented interface
 * @export
 * @class PriceExperimentationApi
 * @extends {BaseAPI}
 */
export class PriceExperimentationApi extends BaseAPI {
    /**
     * Calculate and return the revenue for a existing or new price plan
     * @summary Calculate and return the revenue for a existing or new price plan
     * @param {CalculateRevenueRequest} calculateRevenueRequest Request payload for calculateRevenueAPI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceExperimentationApi
     */
    public calculateRevenue(calculateRevenueRequest: CalculateRevenueRequest, options?: AxiosRequestConfig) {
        return PriceExperimentationApiFp(this.configuration).calculateRevenue(calculateRevenueRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PricePlansApi - axios parameter creator
 * @export
 */
export const PricePlansApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate a price plan details using price plan id
         * @summary Activate a price plan
         * @param {string} pricePlanId 
         * @param {ActivatePricePlanRequest} activatePricePlanRequest Payload to activate price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePricePlan: async (pricePlanId: string, activatePricePlanRequest: ActivatePricePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('activatePricePlan', 'pricePlanId', pricePlanId)
            // verify required parameter 'activatePricePlanRequest' is not null or undefined
            assertParamExists('activatePricePlan', 'activatePricePlanRequest', activatePricePlanRequest)
            const localVarPath = `/price_plans/{price_plan_id}/activate`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activatePricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add currencies to a price plan
         * @summary Add currencies to a price plan
         * @param {string} pricePlanId 
         * @param {AddCurrencyToPricePlanRequest} addCurrencyToPricePlanRequest Payload to add currency to price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCurrencyToPricePlan: async (pricePlanId: string, addCurrencyToPricePlanRequest: AddCurrencyToPricePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('addCurrencyToPricePlan', 'pricePlanId', pricePlanId)
            // verify required parameter 'addCurrencyToPricePlanRequest' is not null or undefined
            assertParamExists('addCurrencyToPricePlan', 'addCurrencyToPricePlanRequest', addCurrencyToPricePlanRequest)
            const localVarPath = `/price_plans/{price_plan_id}/currencies`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addCurrencyToPricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API let\'s you create and price plan Learn more about [Price Plans](https://docs.togai.com/docs/priceplan) 
         * @summary Create a price plan
         * @param {CreatePricePlanRequest} createPricePlanRequest Payload to create price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPricePlan: async (createPricePlanRequest: CreatePricePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPricePlanRequest' is not null or undefined
            assertParamExists('createPricePlan', 'createPricePlanRequest', createPricePlanRequest)
            const localVarPath = `/price_plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a price plan details using price plan id
         * @summary Get a price plan
         * @param {string} pricePlanId 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricePlan: async (pricePlanId: string, version?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('getPricePlan', 'pricePlanId', pricePlanId)
            const localVarPath = `/price_plans/{price_plan_id}`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of price plans
         * @summary List price plans
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricePlans: async (nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/price_plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a draft currency from a price plan
         * @summary Remove a draft currency from a price plan
         * @param {string} pricePlanId 
         * @param {string} currencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCurrencyFromPricePlan: async (pricePlanId: string, currencyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('removeCurrencyFromPricePlan', 'pricePlanId', pricePlanId)
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('removeCurrencyFromPricePlan', 'currencyId', currencyId)
            const localVarPath = `/price_plans/{price_plan_id}/currencies/{currency_id}`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)))
                .replace(`{${"currency_id"}}`, encodeURIComponent(String(currencyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing price plan Price Plans with status as DRAFT alone can be updated . Learn more about [Price plans](https://docs.togai.com/docs/priceplan) from our Guides 
         * @summary Update a price plan
         * @param {string} pricePlanId 
         * @param {UpdatePricePlanRequest} updatePricePlanRequest Payload to update price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricePlan: async (pricePlanId: string, updatePricePlanRequest: UpdatePricePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricePlanId' is not null or undefined
            assertParamExists('updatePricePlan', 'pricePlanId', pricePlanId)
            // verify required parameter 'updatePricePlanRequest' is not null or undefined
            assertParamExists('updatePricePlan', 'updatePricePlanRequest', updatePricePlanRequest)
            const localVarPath = `/price_plans/{price_plan_id}`
                .replace(`{${"price_plan_id"}}`, encodeURIComponent(String(pricePlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePricePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PricePlansApi - functional programming interface
 * @export
 */
export const PricePlansApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PricePlansApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate a price plan details using price plan id
         * @summary Activate a price plan
         * @param {string} pricePlanId 
         * @param {ActivatePricePlanRequest} activatePricePlanRequest Payload to activate price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activatePricePlan(pricePlanId: string, activatePricePlanRequest: ActivatePricePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activatePricePlan(pricePlanId, activatePricePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add currencies to a price plan
         * @summary Add currencies to a price plan
         * @param {string} pricePlanId 
         * @param {AddCurrencyToPricePlanRequest} addCurrencyToPricePlanRequest Payload to add currency to price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCurrencyToPricePlan(pricePlanId: string, addCurrencyToPricePlanRequest: AddCurrencyToPricePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCurrencyToPricePlan(pricePlanId, addCurrencyToPricePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API let\'s you create and price plan Learn more about [Price Plans](https://docs.togai.com/docs/priceplan) 
         * @summary Create a price plan
         * @param {CreatePricePlanRequest} createPricePlanRequest Payload to create price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPricePlan(createPricePlanRequest: CreatePricePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPricePlan(createPricePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a price plan details using price plan id
         * @summary Get a price plan
         * @param {string} pricePlanId 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricePlan(pricePlanId: string, version?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricePlan(pricePlanId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of price plans
         * @summary List price plans
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricePlans(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlanPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricePlans(nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a draft currency from a price plan
         * @summary Remove a draft currency from a price plan
         * @param {string} pricePlanId 
         * @param {string} currencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeCurrencyFromPricePlan(pricePlanId: string, currencyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeCurrencyFromPricePlan(pricePlanId, currencyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing price plan Price Plans with status as DRAFT alone can be updated . Learn more about [Price plans](https://docs.togai.com/docs/priceplan) from our Guides 
         * @summary Update a price plan
         * @param {string} pricePlanId 
         * @param {UpdatePricePlanRequest} updatePricePlanRequest Payload to update price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePricePlan(pricePlanId: string, updatePricePlanRequest: UpdatePricePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePricePlan(pricePlanId, updatePricePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PricePlansApi - factory interface
 * @export
 */
export const PricePlansApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PricePlansApiFp(configuration)
    return {
        /**
         * Activate a price plan details using price plan id
         * @summary Activate a price plan
         * @param {string} pricePlanId 
         * @param {ActivatePricePlanRequest} activatePricePlanRequest Payload to activate price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePricePlan(pricePlanId: string, activatePricePlanRequest: ActivatePricePlanRequest, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.activatePricePlan(pricePlanId, activatePricePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add currencies to a price plan
         * @summary Add currencies to a price plan
         * @param {string} pricePlanId 
         * @param {AddCurrencyToPricePlanRequest} addCurrencyToPricePlanRequest Payload to add currency to price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCurrencyToPricePlan(pricePlanId: string, addCurrencyToPricePlanRequest: AddCurrencyToPricePlanRequest, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.addCurrencyToPricePlan(pricePlanId, addCurrencyToPricePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This API let\'s you create and price plan Learn more about [Price Plans](https://docs.togai.com/docs/priceplan) 
         * @summary Create a price plan
         * @param {CreatePricePlanRequest} createPricePlanRequest Payload to create price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPricePlan(createPricePlanRequest: CreatePricePlanRequest, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.createPricePlan(createPricePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a price plan details using price plan id
         * @summary Get a price plan
         * @param {string} pricePlanId 
         * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricePlan(pricePlanId: string, version?: number, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.getPricePlan(pricePlanId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of price plans
         * @summary List price plans
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricePlans(nextToken?: string, pageSize?: number, options?: any): AxiosPromise<PricePlanPaginatedResponse> {
            return localVarFp.getPricePlans(nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a draft currency from a price plan
         * @summary Remove a draft currency from a price plan
         * @param {string} pricePlanId 
         * @param {string} currencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCurrencyFromPricePlan(pricePlanId: string, currencyId: string, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.removeCurrencyFromPricePlan(pricePlanId, currencyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing price plan Price Plans with status as DRAFT alone can be updated . Learn more about [Price plans](https://docs.togai.com/docs/priceplan) from our Guides 
         * @summary Update a price plan
         * @param {string} pricePlanId 
         * @param {UpdatePricePlanRequest} updatePricePlanRequest Payload to update price plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricePlan(pricePlanId: string, updatePricePlanRequest: UpdatePricePlanRequest, options?: any): AxiosPromise<PricePlan> {
            return localVarFp.updatePricePlan(pricePlanId, updatePricePlanRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PricePlansApi - object-oriented interface
 * @export
 * @class PricePlansApi
 * @extends {BaseAPI}
 */
export class PricePlansApi extends BaseAPI {
    /**
     * Activate a price plan details using price plan id
     * @summary Activate a price plan
     * @param {string} pricePlanId 
     * @param {ActivatePricePlanRequest} activatePricePlanRequest Payload to activate price plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public activatePricePlan(pricePlanId: string, activatePricePlanRequest: ActivatePricePlanRequest, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).activatePricePlan(pricePlanId, activatePricePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add currencies to a price plan
     * @summary Add currencies to a price plan
     * @param {string} pricePlanId 
     * @param {AddCurrencyToPricePlanRequest} addCurrencyToPricePlanRequest Payload to add currency to price plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public addCurrencyToPricePlan(pricePlanId: string, addCurrencyToPricePlanRequest: AddCurrencyToPricePlanRequest, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).addCurrencyToPricePlan(pricePlanId, addCurrencyToPricePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API let\'s you create and price plan Learn more about [Price Plans](https://docs.togai.com/docs/priceplan) 
     * @summary Create a price plan
     * @param {CreatePricePlanRequest} createPricePlanRequest Payload to create price plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public createPricePlan(createPricePlanRequest: CreatePricePlanRequest, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).createPricePlan(createPricePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a price plan details using price plan id
     * @summary Get a price plan
     * @param {string} pricePlanId 
     * @param {number} [version] Optional version to get a specific version. Gets latest version if it is not provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public getPricePlan(pricePlanId: string, version?: number, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).getPricePlan(pricePlanId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of price plans
     * @summary List price plans
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public getPricePlans(nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).getPricePlans(nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a draft currency from a price plan
     * @summary Remove a draft currency from a price plan
     * @param {string} pricePlanId 
     * @param {string} currencyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public removeCurrencyFromPricePlan(pricePlanId: string, currencyId: string, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).removeCurrencyFromPricePlan(pricePlanId, currencyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing price plan Price Plans with status as DRAFT alone can be updated . Learn more about [Price plans](https://docs.togai.com/docs/priceplan) from our Guides 
     * @summary Update a price plan
     * @param {string} pricePlanId 
     * @param {UpdatePricePlanRequest} updatePricePlanRequest Payload to update price plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricePlansApi
     */
    public updatePricePlan(pricePlanId: string, updatePricePlanRequest: UpdatePricePlanRequest, options?: AxiosRequestConfig) {
        return PricePlansApiFp(this.configuration).updatePricePlan(pricePlanId, updatePricePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a setting
         * @summary Get a setting
         * @param {string} settingIdStr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetting: async (settingIdStr: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'settingIdStr' is not null or undefined
            assertParamExists('getSetting', 'settingIdStr', settingIdStr)
            const localVarPath = `/settings/{setting_id_str}`
                .replace(`{${"setting_id_str"}}`, encodeURIComponent(String(settingIdStr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a setting
         * @summary Create a setting
         * @param {Setting} setting Payload to insert setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertSetting: async (setting: Setting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setting' is not null or undefined
            assertParamExists('insertSetting', 'setting', setting)
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List settings
         * @summary Lists settings
         * @param {string} [entityType] 
         * @param {string} [entityId] 
         * @param {string} [settingId] 
         * @param {string} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSetting: async (entityType?: string, entityId?: string, settingId?: string, namespace?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (entityType !== undefined) {
                localVarQueryParameter['entity_type'] = entityType;
            }

            if (entityId !== undefined) {
                localVarQueryParameter['entity_id'] = entityId;
            }

            if (settingId !== undefined) {
                localVarQueryParameter['setting_id'] = settingId;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a setting
         * @summary Update a setting
         * @param {string} settingIdStr 
         * @param {UpdateSettingRequest} updateSettingRequest Payload to update setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting: async (settingIdStr: string, updateSettingRequest: UpdateSettingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'settingIdStr' is not null or undefined
            assertParamExists('updateSetting', 'settingIdStr', settingIdStr)
            // verify required parameter 'updateSettingRequest' is not null or undefined
            assertParamExists('updateSetting', 'updateSettingRequest', updateSettingRequest)
            const localVarPath = `/settings/{setting_id_str}`
                .replace(`{${"setting_id_str"}}`, encodeURIComponent(String(settingIdStr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSettingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a setting
         * @summary Get a setting
         * @param {string} settingIdStr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSetting(settingIdStr: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSetting(settingIdStr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a setting
         * @summary Create a setting
         * @param {Setting} setting Payload to insert setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertSetting(setting: Setting, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertSetting(setting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List settings
         * @summary Lists settings
         * @param {string} [entityType] 
         * @param {string} [entityId] 
         * @param {string} [settingId] 
         * @param {string} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSetting(entityType?: string, entityId?: string, settingId?: string, namespace?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSetting(entityType, entityId, settingId, namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a setting
         * @summary Update a setting
         * @param {string} settingIdStr 
         * @param {UpdateSettingRequest} updateSettingRequest Payload to update setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSetting(settingIdStr: string, updateSettingRequest: UpdateSettingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSetting(settingIdStr, updateSettingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         * Get a setting
         * @summary Get a setting
         * @param {string} settingIdStr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetting(settingIdStr: string, options?: any): AxiosPromise<Setting> {
            return localVarFp.getSetting(settingIdStr, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a setting
         * @summary Create a setting
         * @param {Setting} setting Payload to insert setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertSetting(setting: Setting, options?: any): AxiosPromise<Setting> {
            return localVarFp.insertSetting(setting, options).then((request) => request(axios, basePath));
        },
        /**
         * List settings
         * @summary Lists settings
         * @param {string} [entityType] 
         * @param {string} [entityId] 
         * @param {string} [settingId] 
         * @param {string} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSetting(entityType?: string, entityId?: string, settingId?: string, namespace?: string, options?: any): AxiosPromise<SettingPaginatedResponse> {
            return localVarFp.listSetting(entityType, entityId, settingId, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a setting
         * @summary Update a setting
         * @param {string} settingIdStr 
         * @param {UpdateSettingRequest} updateSettingRequest Payload to update setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting(settingIdStr: string, updateSettingRequest: UpdateSettingRequest, options?: any): AxiosPromise<Setting> {
            return localVarFp.updateSetting(settingIdStr, updateSettingRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * Get a setting
     * @summary Get a setting
     * @param {string} settingIdStr 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getSetting(settingIdStr: string, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).getSetting(settingIdStr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a setting
     * @summary Create a setting
     * @param {Setting} setting Payload to insert setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public insertSetting(setting: Setting, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).insertSetting(setting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List settings
     * @summary Lists settings
     * @param {string} [entityType] 
     * @param {string} [entityId] 
     * @param {string} [settingId] 
     * @param {string} [namespace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public listSetting(entityType?: string, entityId?: string, settingId?: string, namespace?: string, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).listSetting(entityType, entityId, settingId, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a setting
     * @summary Update a setting
     * @param {string} settingIdStr 
     * @param {UpdateSettingRequest} updateSettingRequest Payload to update setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public updateSetting(settingIdStr: string, updateSettingRequest: UpdateSettingRequest, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).updateSetting(settingIdStr, updateSettingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsageMetersApi - axios parameter creator
 * @export
 */
export const UsageMetersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate usage meter
         * @summary Activate usage meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUsageMeter: async (usageMeterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usageMeterId' is not null or undefined
            assertParamExists('activateUsageMeter', 'usageMeterId', usageMeterId)
            const localVarPath = `/usage_meters/{usage_meter_id}/activate`
                .replace(`{${"usage_meter_id"}}`, encodeURIComponent(String(usageMeterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an usage meter and associate with an event schema
         * @summary Create an usage meter
         * @param {CreateUsageMeterRequest} createUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsageMeter: async (createUsageMeterRequest: CreateUsageMeterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUsageMeterRequest' is not null or undefined
            assertParamExists('createUsageMeter', 'createUsageMeterRequest', createUsageMeterRequest)
            const localVarPath = `/usage_meters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUsageMeterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make an existing active usage meter to be inactive Active Usage Meters with active Pricing Plan attached can also be deactivated. 
         * @summary Deactivate usage meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUsageMeter: async (usageMeterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usageMeterId' is not null or undefined
            assertParamExists('deactivateUsageMeter', 'usageMeterId', usageMeterId)
            const localVarPath = `/usage_meters/{usage_meter_id}/deactivate`
                .replace(`{${"usage_meter_id"}}`, encodeURIComponent(String(usageMeterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an Usage Meter
         * @summary Delete an Usage Meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsageMeter: async (usageMeterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usageMeterId' is not null or undefined
            assertParamExists('deleteUsageMeter', 'usageMeterId', usageMeterId)
            const localVarPath = `/usage_meters/{usage_meter_id}`
                .replace(`{${"usage_meter_id"}}`, encodeURIComponent(String(usageMeterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an usage meter using event schema name and usage meter id.
         * @summary Get usage meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMeter: async (usageMeterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usageMeterId' is not null or undefined
            assertParamExists('getUsageMeter', 'usageMeterId', usageMeterId)
            const localVarPath = `/usage_meters/{usage_meter_id}`
                .replace(`{${"usage_meter_id"}}`, encodeURIComponent(String(usageMeterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of usage meters associated with an event schema
         * @summary List usage meters for event schema
         * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by status 
         * @param {'COUNT' | 'SUM'} [aggregations] Filter by aggregations 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMetersForEventSchema: async (status?: 'ACTIVE' | 'INACTIVE', aggregations?: 'COUNT' | 'SUM', nextToken?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/usage_meters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (aggregations !== undefined) {
                localVarQueryParameter['aggregations'] = aggregations;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['nextToken'] = nextToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API lets you update an existing usage meter.
         * @summary Update an usage meter
         * @param {string} usageMeterId 
         * @param {UpdateUsageMeterRequest} updateUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsageMeter: async (usageMeterId: string, updateUsageMeterRequest: UpdateUsageMeterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usageMeterId' is not null or undefined
            assertParamExists('updateUsageMeter', 'usageMeterId', usageMeterId)
            // verify required parameter 'updateUsageMeterRequest' is not null or undefined
            assertParamExists('updateUsageMeter', 'updateUsageMeterRequest', updateUsageMeterRequest)
            const localVarPath = `/usage_meters/{usage_meter_id}`
                .replace(`{${"usage_meter_id"}}`, encodeURIComponent(String(usageMeterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUsageMeterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsageMetersApi - functional programming interface
 * @export
 */
export const UsageMetersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsageMetersApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate usage meter
         * @summary Activate usage meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateUsageMeter(usageMeterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateUsageMeter(usageMeterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an usage meter and associate with an event schema
         * @summary Create an usage meter
         * @param {CreateUsageMeterRequest} createUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUsageMeter(createUsageMeterRequest: CreateUsageMeterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUsageMeter(createUsageMeterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Make an existing active usage meter to be inactive Active Usage Meters with active Pricing Plan attached can also be deactivated. 
         * @summary Deactivate usage meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateUsageMeter(usageMeterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateUsageMeter(usageMeterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an Usage Meter
         * @summary Delete an Usage Meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsageMeter(usageMeterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUsageMeter(usageMeterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an usage meter using event schema name and usage meter id.
         * @summary Get usage meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsageMeter(usageMeterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageMeter(usageMeterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of usage meters associated with an event schema
         * @summary List usage meters for event schema
         * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by status 
         * @param {'COUNT' | 'SUM'} [aggregations] Filter by aggregations 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsageMetersForEventSchema(status?: 'ACTIVE' | 'INACTIVE', aggregations?: 'COUNT' | 'SUM', nextToken?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeterPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageMetersForEventSchema(status, aggregations, nextToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API lets you update an existing usage meter.
         * @summary Update an usage meter
         * @param {string} usageMeterId 
         * @param {UpdateUsageMeterRequest} updateUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUsageMeter(usageMeterId: string, updateUsageMeterRequest: UpdateUsageMeterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMeter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUsageMeter(usageMeterId, updateUsageMeterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsageMetersApi - factory interface
 * @export
 */
export const UsageMetersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsageMetersApiFp(configuration)
    return {
        /**
         * Activate usage meter
         * @summary Activate usage meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUsageMeter(usageMeterId: string, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.activateUsageMeter(usageMeterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an usage meter and associate with an event schema
         * @summary Create an usage meter
         * @param {CreateUsageMeterRequest} createUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsageMeter(createUsageMeterRequest: CreateUsageMeterRequest, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.createUsageMeter(createUsageMeterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Make an existing active usage meter to be inactive Active Usage Meters with active Pricing Plan attached can also be deactivated. 
         * @summary Deactivate usage meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUsageMeter(usageMeterId: string, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.deactivateUsageMeter(usageMeterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an Usage Meter
         * @summary Delete an Usage Meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsageMeter(usageMeterId: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteUsageMeter(usageMeterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an usage meter using event schema name and usage meter id.
         * @summary Get usage meter
         * @param {string} usageMeterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMeter(usageMeterId: string, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.getUsageMeter(usageMeterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of usage meters associated with an event schema
         * @summary List usage meters for event schema
         * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by status 
         * @param {'COUNT' | 'SUM'} [aggregations] Filter by aggregations 
         * @param {string} [nextToken] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMetersForEventSchema(status?: 'ACTIVE' | 'INACTIVE', aggregations?: 'COUNT' | 'SUM', nextToken?: string, pageSize?: number, options?: any): AxiosPromise<UsageMeterPaginatedResponse> {
            return localVarFp.getUsageMetersForEventSchema(status, aggregations, nextToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * This API lets you update an existing usage meter.
         * @summary Update an usage meter
         * @param {string} usageMeterId 
         * @param {UpdateUsageMeterRequest} updateUsageMeterRequest Payload to create usage meter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsageMeter(usageMeterId: string, updateUsageMeterRequest: UpdateUsageMeterRequest, options?: any): AxiosPromise<UsageMeter> {
            return localVarFp.updateUsageMeter(usageMeterId, updateUsageMeterRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsageMetersApi - object-oriented interface
 * @export
 * @class UsageMetersApi
 * @extends {BaseAPI}
 */
export class UsageMetersApi extends BaseAPI {
    /**
     * Activate usage meter
     * @summary Activate usage meter
     * @param {string} usageMeterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public activateUsageMeter(usageMeterId: string, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).activateUsageMeter(usageMeterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an usage meter and associate with an event schema
     * @summary Create an usage meter
     * @param {CreateUsageMeterRequest} createUsageMeterRequest Payload to create usage meter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public createUsageMeter(createUsageMeterRequest: CreateUsageMeterRequest, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).createUsageMeter(createUsageMeterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Make an existing active usage meter to be inactive Active Usage Meters with active Pricing Plan attached can also be deactivated. 
     * @summary Deactivate usage meter
     * @param {string} usageMeterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public deactivateUsageMeter(usageMeterId: string, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).deactivateUsageMeter(usageMeterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an Usage Meter
     * @summary Delete an Usage Meter
     * @param {string} usageMeterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public deleteUsageMeter(usageMeterId: string, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).deleteUsageMeter(usageMeterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an usage meter using event schema name and usage meter id.
     * @summary Get usage meter
     * @param {string} usageMeterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public getUsageMeter(usageMeterId: string, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).getUsageMeter(usageMeterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of usage meters associated with an event schema
     * @summary List usage meters for event schema
     * @param {'ACTIVE' | 'INACTIVE'} [status] Filter by status 
     * @param {'COUNT' | 'SUM'} [aggregations] Filter by aggregations 
     * @param {string} [nextToken] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public getUsageMetersForEventSchema(status?: 'ACTIVE' | 'INACTIVE', aggregations?: 'COUNT' | 'SUM', nextToken?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).getUsageMetersForEventSchema(status, aggregations, nextToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API lets you update an existing usage meter.
     * @summary Update an usage meter
     * @param {string} usageMeterId 
     * @param {UpdateUsageMeterRequest} updateUsageMeterRequest Payload to create usage meter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageMetersApi
     */
    public updateUsageMeter(usageMeterId: string, updateUsageMeterRequest: UpdateUsageMeterRequest, options?: AxiosRequestConfig) {
        return UsageMetersApiFp(this.configuration).updateUsageMeter(usageMeterId, updateUsageMeterRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


